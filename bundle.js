(function () { function r(e, n, t) { function o(i, f) { if (!n[i]) { if (!e[i]) { var c = "function" == typeof require && require; if (!f && c) return c(i, !0); if (u) return u(i, !0); var a = new Error("Cannot find module '" + i + "'"); throw a.code = "MODULE_NOT_FOUND", a } var p = n[i] = { exports: {} }; e[i][0].call(p.exports, function (r) { var n = e[i][1][r]; return o(n || r) }, p, p.exports, r, e, n, t) } return n[i].exports } for (var u = "function" == typeof require && require, i = 0; i < t.length; i++)o(t[i]); return o } return r })()({
  1: [function (require, module, exports) {
    'use strict'

    exports.byteLength = byteLength
    exports.toByteArray = toByteArray
    exports.fromByteArray = fromByteArray

    var lookup = []
    var revLookup = []
    var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

    var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
    for (var i = 0, len = code.length; i < len; ++i) {
      lookup[i] = code[i]
      revLookup[code.charCodeAt(i)] = i
    }

    // Support decoding URL-safe base64 strings, as Node.js does.
    // See: https://en.wikipedia.org/wiki/Base64#URL_applications
    revLookup['-'.charCodeAt(0)] = 62
    revLookup['_'.charCodeAt(0)] = 63

    function getLens(b64) {
      var len = b64.length

      if (len % 4 > 0) {
        throw new Error('Invalid string. Length must be a multiple of 4')
      }

      // Trim off extra bytes after placeholder bytes are found
      // See: https://github.com/beatgammit/base64-js/issues/42
      var validLen = b64.indexOf('=')
      if (validLen === -1) validLen = len

      var placeHoldersLen = validLen === len
        ? 0
        : 4 - (validLen % 4)

      return [validLen, placeHoldersLen]
    }

    // base64 is 4/3 + up to two characters of the original data
    function byteLength(b64) {
      var lens = getLens(b64)
      var validLen = lens[0]
      var placeHoldersLen = lens[1]
      return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
    }

    function _byteLength(b64, validLen, placeHoldersLen) {
      return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
    }

    function toByteArray(b64) {
      var tmp
      var lens = getLens(b64)
      var validLen = lens[0]
      var placeHoldersLen = lens[1]

      var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

      var curByte = 0

      // if there are placeholders, only get up to the last complete 4 chars
      var len = placeHoldersLen > 0
        ? validLen - 4
        : validLen

      var i
      for (i = 0; i < len; i += 4) {
        tmp =
          (revLookup[b64.charCodeAt(i)] << 18) |
          (revLookup[b64.charCodeAt(i + 1)] << 12) |
          (revLookup[b64.charCodeAt(i + 2)] << 6) |
          revLookup[b64.charCodeAt(i + 3)]
        arr[curByte++] = (tmp >> 16) & 0xFF
        arr[curByte++] = (tmp >> 8) & 0xFF
        arr[curByte++] = tmp & 0xFF
      }

      if (placeHoldersLen === 2) {
        tmp =
          (revLookup[b64.charCodeAt(i)] << 2) |
          (revLookup[b64.charCodeAt(i + 1)] >> 4)
        arr[curByte++] = tmp & 0xFF
      }

      if (placeHoldersLen === 1) {
        tmp =
          (revLookup[b64.charCodeAt(i)] << 10) |
          (revLookup[b64.charCodeAt(i + 1)] << 4) |
          (revLookup[b64.charCodeAt(i + 2)] >> 2)
        arr[curByte++] = (tmp >> 8) & 0xFF
        arr[curByte++] = tmp & 0xFF
      }

      return arr
    }

    function tripletToBase64(num) {
      return lookup[num >> 18 & 0x3F] +
        lookup[num >> 12 & 0x3F] +
        lookup[num >> 6 & 0x3F] +
        lookup[num & 0x3F]
    }

    function encodeChunk(uint8, start, end) {
      var tmp
      var output = []
      for (var i = start; i < end; i += 3) {
        tmp =
          ((uint8[i] << 16) & 0xFF0000) +
          ((uint8[i + 1] << 8) & 0xFF00) +
          (uint8[i + 2] & 0xFF)
        output.push(tripletToBase64(tmp))
      }
      return output.join('')
    }

    function fromByteArray(uint8) {
      var tmp
      var len = uint8.length
      var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
      var parts = []
      var maxChunkLength = 16383 // must be multiple of 3

      // go through the array every three bytes, we'll deal with trailing stuff later
      for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
        parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
      }

      // pad the end with zeros, but make sure to not forget the extra bytes
      if (extraBytes === 1) {
        tmp = uint8[len - 1]
        parts.push(
          lookup[tmp >> 2] +
          lookup[(tmp << 4) & 0x3F] +
          '=='
        )
      } else if (extraBytes === 2) {
        tmp = (uint8[len - 2] << 8) + uint8[len - 1]
        parts.push(
          lookup[tmp >> 10] +
          lookup[(tmp >> 4) & 0x3F] +
          lookup[(tmp << 2) & 0x3F] +
          '='
        )
      }

      return parts.join('')
    }

  }, {}], 2: [function (require, module, exports) {
    (function (Buffer) {
      (function () {
        /*!
         * The buffer module from node.js, for the browser.
         *
         * @author   Feross Aboukhadijeh <https://feross.org>
         * @license  MIT
         */
        /* eslint-disable no-proto */

        'use strict'

        var base64 = require('base64-js')
        var ieee754 = require('ieee754')

        exports.Buffer = Buffer
        exports.SlowBuffer = SlowBuffer
        exports.INSPECT_MAX_BYTES = 50

        var K_MAX_LENGTH = 0x7fffffff
        exports.kMaxLength = K_MAX_LENGTH

        /**
         * If `Buffer.TYPED_ARRAY_SUPPORT`:
         *   === true    Use Uint8Array implementation (fastest)
         *   === false   Print warning and recommend using `buffer` v4.x which has an Object
         *               implementation (most compatible, even IE6)
         *
         * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
         * Opera 11.6+, iOS 4.2+.
         *
         * We report that the browser does not support typed arrays if the are not subclassable
         * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
         * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
         * for __proto__ and has a buggy typed array implementation.
         */
        Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

        if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
          typeof console.error === 'function') {
          console.error(
            'This browser lacks typed array (Uint8Array) support which is required by ' +
            '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
          )
        }

        function typedArraySupport() {
          // Can typed array instances can be augmented?
          try {
            var arr = new Uint8Array(1)
            arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function () { return 42 } }
            return arr.foo() === 42
          } catch (e) {
            return false
          }
        }

        Object.defineProperty(Buffer.prototype, 'parent', {
          enumerable: true,
          get: function () {
            if (!Buffer.isBuffer(this)) return undefined
            return this.buffer
          }
        })

        Object.defineProperty(Buffer.prototype, 'offset', {
          enumerable: true,
          get: function () {
            if (!Buffer.isBuffer(this)) return undefined
            return this.byteOffset
          }
        })

        function createBuffer(length) {
          if (length > K_MAX_LENGTH) {
            throw new RangeError('The value "' + length + '" is invalid for option "size"')
          }
          // Return an augmented `Uint8Array` instance
          var buf = new Uint8Array(length)
          buf.__proto__ = Buffer.prototype
          return buf
        }

        /**
         * The Buffer constructor returns instances of `Uint8Array` that have their
         * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
         * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
         * and the `Uint8Array` methods. Square bracket notation works as expected -- it
         * returns a single octet.
         *
         * The `Uint8Array` prototype remains unmodified.
         */

        function Buffer(arg, encodingOrOffset, length) {
          // Common case.
          if (typeof arg === 'number') {
            if (typeof encodingOrOffset === 'string') {
              throw new TypeError(
                'The "string" argument must be of type string. Received type number'
              )
            }
            return allocUnsafe(arg)
          }
          return from(arg, encodingOrOffset, length)
        }

        // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
        if (typeof Symbol !== 'undefined' && Symbol.species != null &&
          Buffer[Symbol.species] === Buffer) {
          Object.defineProperty(Buffer, Symbol.species, {
            value: null,
            configurable: true,
            enumerable: false,
            writable: false
          })
        }

        Buffer.poolSize = 8192 // not used by this implementation

        function from(value, encodingOrOffset, length) {
          if (typeof value === 'string') {
            return fromString(value, encodingOrOffset)
          }

          if (ArrayBuffer.isView(value)) {
            return fromArrayLike(value)
          }

          if (value == null) {
            throw TypeError(
              'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
              'or Array-like Object. Received type ' + (typeof value)
            )
          }

          if (isInstance(value, ArrayBuffer) ||
            (value && isInstance(value.buffer, ArrayBuffer))) {
            return fromArrayBuffer(value, encodingOrOffset, length)
          }

          if (typeof value === 'number') {
            throw new TypeError(
              'The "value" argument must not be of type number. Received type number'
            )
          }

          var valueOf = value.valueOf && value.valueOf()
          if (valueOf != null && valueOf !== value) {
            return Buffer.from(valueOf, encodingOrOffset, length)
          }

          var b = fromObject(value)
          if (b) return b

          if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
            typeof value[Symbol.toPrimitive] === 'function') {
            return Buffer.from(
              value[Symbol.toPrimitive]('string'), encodingOrOffset, length
            )
          }

          throw new TypeError(
            'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
            'or Array-like Object. Received type ' + (typeof value)
          )
        }

        /**
         * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
         * if value is a number.
         * Buffer.from(str[, encoding])
         * Buffer.from(array)
         * Buffer.from(buffer)
         * Buffer.from(arrayBuffer[, byteOffset[, length]])
         **/
        Buffer.from = function (value, encodingOrOffset, length) {
          return from(value, encodingOrOffset, length)
        }

        // Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
        // https://github.com/feross/buffer/pull/148
        Buffer.prototype.__proto__ = Uint8Array.prototype
        Buffer.__proto__ = Uint8Array

        function assertSize(size) {
          if (typeof size !== 'number') {
            throw new TypeError('"size" argument must be of type number')
          } else if (size < 0) {
            throw new RangeError('The value "' + size + '" is invalid for option "size"')
          }
        }

        function alloc(size, fill, encoding) {
          assertSize(size)
          if (size <= 0) {
            return createBuffer(size)
          }
          if (fill !== undefined) {
            // Only pay attention to encoding if it's a string. This
            // prevents accidentally sending in a number that would
            // be interpretted as a start offset.
            return typeof encoding === 'string'
              ? createBuffer(size).fill(fill, encoding)
              : createBuffer(size).fill(fill)
          }
          return createBuffer(size)
        }

        /**
         * Creates a new filled Buffer instance.
         * alloc(size[, fill[, encoding]])
         **/
        Buffer.alloc = function (size, fill, encoding) {
          return alloc(size, fill, encoding)
        }

        function allocUnsafe(size) {
          assertSize(size)
          return createBuffer(size < 0 ? 0 : checked(size) | 0)
        }

        /**
         * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
         * */
        Buffer.allocUnsafe = function (size) {
          return allocUnsafe(size)
        }
        /**
         * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
         */
        Buffer.allocUnsafeSlow = function (size) {
          return allocUnsafe(size)
        }

        function fromString(string, encoding) {
          if (typeof encoding !== 'string' || encoding === '') {
            encoding = 'utf8'
          }

          if (!Buffer.isEncoding(encoding)) {
            throw new TypeError('Unknown encoding: ' + encoding)
          }

          var length = byteLength(string, encoding) | 0
          var buf = createBuffer(length)

          var actual = buf.write(string, encoding)

          if (actual !== length) {
            // Writing a hex string, for example, that contains invalid characters will
            // cause everything after the first invalid character to be ignored. (e.g.
            // 'abxxcd' will be treated as 'ab')
            buf = buf.slice(0, actual)
          }

          return buf
        }

        function fromArrayLike(array) {
          var length = array.length < 0 ? 0 : checked(array.length) | 0
          var buf = createBuffer(length)
          for (var i = 0; i < length; i += 1) {
            buf[i] = array[i] & 255
          }
          return buf
        }

        function fromArrayBuffer(array, byteOffset, length) {
          if (byteOffset < 0 || array.byteLength < byteOffset) {
            throw new RangeError('"offset" is outside of buffer bounds')
          }

          if (array.byteLength < byteOffset + (length || 0)) {
            throw new RangeError('"length" is outside of buffer bounds')
          }

          var buf
          if (byteOffset === undefined && length === undefined) {
            buf = new Uint8Array(array)
          } else if (length === undefined) {
            buf = new Uint8Array(array, byteOffset)
          } else {
            buf = new Uint8Array(array, byteOffset, length)
          }

          // Return an augmented `Uint8Array` instance
          buf.__proto__ = Buffer.prototype
          return buf
        }

        function fromObject(obj) {
          if (Buffer.isBuffer(obj)) {
            var len = checked(obj.length) | 0
            var buf = createBuffer(len)

            if (buf.length === 0) {
              return buf
            }

            obj.copy(buf, 0, 0, len)
            return buf
          }

          if (obj.length !== undefined) {
            if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
              return createBuffer(0)
            }
            return fromArrayLike(obj)
          }

          if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
            return fromArrayLike(obj.data)
          }
        }

        function checked(length) {
          // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
          // length is NaN (which is otherwise coerced to zero.)
          if (length >= K_MAX_LENGTH) {
            throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
              'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
          }
          return length | 0
        }

        function SlowBuffer(length) {
          if (+length != length) { // eslint-disable-line eqeqeq
            length = 0
          }
          return Buffer.alloc(+length)
        }

        Buffer.isBuffer = function isBuffer(b) {
          return b != null && b._isBuffer === true &&
            b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
        }

        Buffer.compare = function compare(a, b) {
          if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)
          if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)
          if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
            throw new TypeError(
              'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
            )
          }

          if (a === b) return 0

          var x = a.length
          var y = b.length

          for (var i = 0, len = Math.min(x, y); i < len; ++i) {
            if (a[i] !== b[i]) {
              x = a[i]
              y = b[i]
              break
            }
          }

          if (x < y) return -1
          if (y < x) return 1
          return 0
        }

        Buffer.isEncoding = function isEncoding(encoding) {
          switch (String(encoding).toLowerCase()) {
            case 'hex':
            case 'utf8':
            case 'utf-8':
            case 'ascii':
            case 'latin1':
            case 'binary':
            case 'base64':
            case 'ucs2':
            case 'ucs-2':
            case 'utf16le':
            case 'utf-16le':
              return true
            default:
              return false
          }
        }

        Buffer.concat = function concat(list, length) {
          if (!Array.isArray(list)) {
            throw new TypeError('"list" argument must be an Array of Buffers')
          }

          if (list.length === 0) {
            return Buffer.alloc(0)
          }

          var i
          if (length === undefined) {
            length = 0
            for (i = 0; i < list.length; ++i) {
              length += list[i].length
            }
          }

          var buffer = Buffer.allocUnsafe(length)
          var pos = 0
          for (i = 0; i < list.length; ++i) {
            var buf = list[i]
            if (isInstance(buf, Uint8Array)) {
              buf = Buffer.from(buf)
            }
            if (!Buffer.isBuffer(buf)) {
              throw new TypeError('"list" argument must be an Array of Buffers')
            }
            buf.copy(buffer, pos)
            pos += buf.length
          }
          return buffer
        }

        function byteLength(string, encoding) {
          if (Buffer.isBuffer(string)) {
            return string.length
          }
          if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
            return string.byteLength
          }
          if (typeof string !== 'string') {
            throw new TypeError(
              'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
              'Received type ' + typeof string
            )
          }

          var len = string.length
          var mustMatch = (arguments.length > 2 && arguments[2] === true)
          if (!mustMatch && len === 0) return 0

          // Use a for loop to avoid recursion
          var loweredCase = false
          for (; ;) {
            switch (encoding) {
              case 'ascii':
              case 'latin1':
              case 'binary':
                return len
              case 'utf8':
              case 'utf-8':
                return utf8ToBytes(string).length
              case 'ucs2':
              case 'ucs-2':
              case 'utf16le':
              case 'utf-16le':
                return len * 2
              case 'hex':
                return len >>> 1
              case 'base64':
                return base64ToBytes(string).length
              default:
                if (loweredCase) {
                  return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
                }
                encoding = ('' + encoding).toLowerCase()
                loweredCase = true
            }
          }
        }
        Buffer.byteLength = byteLength

        function slowToString(encoding, start, end) {
          var loweredCase = false

          // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
          // property of a typed array.

          // This behaves neither like String nor Uint8Array in that we set start/end
          // to their upper/lower bounds if the value passed is out of range.
          // undefined is handled specially as per ECMA-262 6th Edition,
          // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
          if (start === undefined || start < 0) {
            start = 0
          }
          // Return early if start > this.length. Done here to prevent potential uint32
          // coercion fail below.
          if (start > this.length) {
            return ''
          }

          if (end === undefined || end > this.length) {
            end = this.length
          }

          if (end <= 0) {
            return ''
          }

          // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
          end >>>= 0
          start >>>= 0

          if (end <= start) {
            return ''
          }

          if (!encoding) encoding = 'utf8'

          while (true) {
            switch (encoding) {
              case 'hex':
                return hexSlice(this, start, end)

              case 'utf8':
              case 'utf-8':
                return utf8Slice(this, start, end)

              case 'ascii':
                return asciiSlice(this, start, end)

              case 'latin1':
              case 'binary':
                return latin1Slice(this, start, end)

              case 'base64':
                return base64Slice(this, start, end)

              case 'ucs2':
              case 'ucs-2':
              case 'utf16le':
              case 'utf-16le':
                return utf16leSlice(this, start, end)

              default:
                if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
                encoding = (encoding + '').toLowerCase()
                loweredCase = true
            }
          }
        }

        // This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
        // to detect a Buffer instance. It's not possible to use `instanceof Buffer`
        // reliably in a browserify context because there could be multiple different
        // copies of the 'buffer' package in use. This method works even for Buffer
        // instances that were created from another copy of the `buffer` package.
        // See: https://github.com/feross/buffer/issues/154
        Buffer.prototype._isBuffer = true

        function swap(b, n, m) {
          var i = b[n]
          b[n] = b[m]
          b[m] = i
        }

        Buffer.prototype.swap16 = function swap16() {
          var len = this.length
          if (len % 2 !== 0) {
            throw new RangeError('Buffer size must be a multiple of 16-bits')
          }
          for (var i = 0; i < len; i += 2) {
            swap(this, i, i + 1)
          }
          return this
        }

        Buffer.prototype.swap32 = function swap32() {
          var len = this.length
          if (len % 4 !== 0) {
            throw new RangeError('Buffer size must be a multiple of 32-bits')
          }
          for (var i = 0; i < len; i += 4) {
            swap(this, i, i + 3)
            swap(this, i + 1, i + 2)
          }
          return this
        }

        Buffer.prototype.swap64 = function swap64() {
          var len = this.length
          if (len % 8 !== 0) {
            throw new RangeError('Buffer size must be a multiple of 64-bits')
          }
          for (var i = 0; i < len; i += 8) {
            swap(this, i, i + 7)
            swap(this, i + 1, i + 6)
            swap(this, i + 2, i + 5)
            swap(this, i + 3, i + 4)
          }
          return this
        }

        Buffer.prototype.toString = function toString() {
          var length = this.length
          if (length === 0) return ''
          if (arguments.length === 0) return utf8Slice(this, 0, length)
          return slowToString.apply(this, arguments)
        }

        Buffer.prototype.toLocaleString = Buffer.prototype.toString

        Buffer.prototype.equals = function equals(b) {
          if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
          if (this === b) return true
          return Buffer.compare(this, b) === 0
        }

        Buffer.prototype.inspect = function inspect() {
          var str = ''
          var max = exports.INSPECT_MAX_BYTES
          str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
          if (this.length > max) str += ' ... '
          return '<Buffer ' + str + '>'
        }

        Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
          if (isInstance(target, Uint8Array)) {
            target = Buffer.from(target, target.offset, target.byteLength)
          }
          if (!Buffer.isBuffer(target)) {
            throw new TypeError(
              'The "target" argument must be one of type Buffer or Uint8Array. ' +
              'Received type ' + (typeof target)
            )
          }

          if (start === undefined) {
            start = 0
          }
          if (end === undefined) {
            end = target ? target.length : 0
          }
          if (thisStart === undefined) {
            thisStart = 0
          }
          if (thisEnd === undefined) {
            thisEnd = this.length
          }

          if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
            throw new RangeError('out of range index')
          }

          if (thisStart >= thisEnd && start >= end) {
            return 0
          }
          if (thisStart >= thisEnd) {
            return -1
          }
          if (start >= end) {
            return 1
          }

          start >>>= 0
          end >>>= 0
          thisStart >>>= 0
          thisEnd >>>= 0

          if (this === target) return 0

          var x = thisEnd - thisStart
          var y = end - start
          var len = Math.min(x, y)

          var thisCopy = this.slice(thisStart, thisEnd)
          var targetCopy = target.slice(start, end)

          for (var i = 0; i < len; ++i) {
            if (thisCopy[i] !== targetCopy[i]) {
              x = thisCopy[i]
              y = targetCopy[i]
              break
            }
          }

          if (x < y) return -1
          if (y < x) return 1
          return 0
        }

        // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
        // OR the last index of `val` in `buffer` at offset <= `byteOffset`.
        //
        // Arguments:
        // - buffer - a Buffer to search
        // - val - a string, Buffer, or number
        // - byteOffset - an index into `buffer`; will be clamped to an int32
        // - encoding - an optional encoding, relevant is val is a string
        // - dir - true for indexOf, false for lastIndexOf
        function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
          // Empty buffer means no match
          if (buffer.length === 0) return -1

          // Normalize byteOffset
          if (typeof byteOffset === 'string') {
            encoding = byteOffset
            byteOffset = 0
          } else if (byteOffset > 0x7fffffff) {
            byteOffset = 0x7fffffff
          } else if (byteOffset < -0x80000000) {
            byteOffset = -0x80000000
          }
          byteOffset = +byteOffset // Coerce to Number.
          if (numberIsNaN(byteOffset)) {
            // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
            byteOffset = dir ? 0 : (buffer.length - 1)
          }

          // Normalize byteOffset: negative offsets start from the end of the buffer
          if (byteOffset < 0) byteOffset = buffer.length + byteOffset
          if (byteOffset >= buffer.length) {
            if (dir) return -1
            else byteOffset = buffer.length - 1
          } else if (byteOffset < 0) {
            if (dir) byteOffset = 0
            else return -1
          }

          // Normalize val
          if (typeof val === 'string') {
            val = Buffer.from(val, encoding)
          }

          // Finally, search either indexOf (if dir is true) or lastIndexOf
          if (Buffer.isBuffer(val)) {
            // Special case: looking for empty string/buffer always fails
            if (val.length === 0) {
              return -1
            }
            return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
          } else if (typeof val === 'number') {
            val = val & 0xFF // Search for a byte value [0-255]
            if (typeof Uint8Array.prototype.indexOf === 'function') {
              if (dir) {
                return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
              } else {
                return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
              }
            }
            return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)
          }

          throw new TypeError('val must be string, number or Buffer')
        }

        function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
          var indexSize = 1
          var arrLength = arr.length
          var valLength = val.length

          if (encoding !== undefined) {
            encoding = String(encoding).toLowerCase()
            if (encoding === 'ucs2' || encoding === 'ucs-2' ||
              encoding === 'utf16le' || encoding === 'utf-16le') {
              if (arr.length < 2 || val.length < 2) {
                return -1
              }
              indexSize = 2
              arrLength /= 2
              valLength /= 2
              byteOffset /= 2
            }
          }

          function read(buf, i) {
            if (indexSize === 1) {
              return buf[i]
            } else {
              return buf.readUInt16BE(i * indexSize)
            }
          }

          var i
          if (dir) {
            var foundIndex = -1
            for (i = byteOffset; i < arrLength; i++) {
              if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
                if (foundIndex === -1) foundIndex = i
                if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
              } else {
                if (foundIndex !== -1) i -= i - foundIndex
                foundIndex = -1
              }
            }
          } else {
            if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
            for (i = byteOffset; i >= 0; i--) {
              var found = true
              for (var j = 0; j < valLength; j++) {
                if (read(arr, i + j) !== read(val, j)) {
                  found = false
                  break
                }
              }
              if (found) return i
            }
          }

          return -1
        }

        Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
          return this.indexOf(val, byteOffset, encoding) !== -1
        }

        Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
          return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
        }

        Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
          return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
        }

        function hexWrite(buf, string, offset, length) {
          offset = Number(offset) || 0
          var remaining = buf.length - offset
          if (!length) {
            length = remaining
          } else {
            length = Number(length)
            if (length > remaining) {
              length = remaining
            }
          }

          var strLen = string.length

          if (length > strLen / 2) {
            length = strLen / 2
          }
          for (var i = 0; i < length; ++i) {
            var parsed = parseInt(string.substr(i * 2, 2), 16)
            if (numberIsNaN(parsed)) return i
            buf[offset + i] = parsed
          }
          return i
        }

        function utf8Write(buf, string, offset, length) {
          return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
        }

        function asciiWrite(buf, string, offset, length) {
          return blitBuffer(asciiToBytes(string), buf, offset, length)
        }

        function latin1Write(buf, string, offset, length) {
          return asciiWrite(buf, string, offset, length)
        }

        function base64Write(buf, string, offset, length) {
          return blitBuffer(base64ToBytes(string), buf, offset, length)
        }

        function ucs2Write(buf, string, offset, length) {
          return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
        }

        Buffer.prototype.write = function write(string, offset, length, encoding) {
          // Buffer#write(string)
          if (offset === undefined) {
            encoding = 'utf8'
            length = this.length
            offset = 0
            // Buffer#write(string, encoding)
          } else if (length === undefined && typeof offset === 'string') {
            encoding = offset
            length = this.length
            offset = 0
            // Buffer#write(string, offset[, length][, encoding])
          } else if (isFinite(offset)) {
            offset = offset >>> 0
            if (isFinite(length)) {
              length = length >>> 0
              if (encoding === undefined) encoding = 'utf8'
            } else {
              encoding = length
              length = undefined
            }
          } else {
            throw new Error(
              'Buffer.write(string, encoding, offset[, length]) is no longer supported'
            )
          }

          var remaining = this.length - offset
          if (length === undefined || length > remaining) length = remaining

          if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
            throw new RangeError('Attempt to write outside buffer bounds')
          }

          if (!encoding) encoding = 'utf8'

          var loweredCase = false
          for (; ;) {
            switch (encoding) {
              case 'hex':
                return hexWrite(this, string, offset, length)

              case 'utf8':
              case 'utf-8':
                return utf8Write(this, string, offset, length)

              case 'ascii':
                return asciiWrite(this, string, offset, length)

              case 'latin1':
              case 'binary':
                return latin1Write(this, string, offset, length)

              case 'base64':
                // Warning: maxLength not taken into account in base64Write
                return base64Write(this, string, offset, length)

              case 'ucs2':
              case 'ucs-2':
              case 'utf16le':
              case 'utf-16le':
                return ucs2Write(this, string, offset, length)

              default:
                if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
                encoding = ('' + encoding).toLowerCase()
                loweredCase = true
            }
          }
        }

        Buffer.prototype.toJSON = function toJSON() {
          return {
            type: 'Buffer',
            data: Array.prototype.slice.call(this._arr || this, 0)
          }
        }

        function base64Slice(buf, start, end) {
          if (start === 0 && end === buf.length) {
            return base64.fromByteArray(buf)
          } else {
            return base64.fromByteArray(buf.slice(start, end))
          }
        }

        function utf8Slice(buf, start, end) {
          end = Math.min(buf.length, end)
          var res = []

          var i = start
          while (i < end) {
            var firstByte = buf[i]
            var codePoint = null
            var bytesPerSequence = (firstByte > 0xEF) ? 4
              : (firstByte > 0xDF) ? 3
                : (firstByte > 0xBF) ? 2
                  : 1

            if (i + bytesPerSequence <= end) {
              var secondByte, thirdByte, fourthByte, tempCodePoint

              switch (bytesPerSequence) {
                case 1:
                  if (firstByte < 0x80) {
                    codePoint = firstByte
                  }
                  break
                case 2:
                  secondByte = buf[i + 1]
                  if ((secondByte & 0xC0) === 0x80) {
                    tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
                    if (tempCodePoint > 0x7F) {
                      codePoint = tempCodePoint
                    }
                  }
                  break
                case 3:
                  secondByte = buf[i + 1]
                  thirdByte = buf[i + 2]
                  if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
                    tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
                    if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
                      codePoint = tempCodePoint
                    }
                  }
                  break
                case 4:
                  secondByte = buf[i + 1]
                  thirdByte = buf[i + 2]
                  fourthByte = buf[i + 3]
                  if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
                    tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
                    if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
                      codePoint = tempCodePoint
                    }
                  }
              }
            }

            if (codePoint === null) {
              // we did not generate a valid codePoint so insert a
              // replacement char (U+FFFD) and advance only 1 byte
              codePoint = 0xFFFD
              bytesPerSequence = 1
            } else if (codePoint > 0xFFFF) {
              // encode to utf16 (surrogate pair dance)
              codePoint -= 0x10000
              res.push(codePoint >>> 10 & 0x3FF | 0xD800)
              codePoint = 0xDC00 | codePoint & 0x3FF
            }

            res.push(codePoint)
            i += bytesPerSequence
          }

          return decodeCodePointsArray(res)
        }

        // Based on http://stackoverflow.com/a/22747272/680742, the browser with
        // the lowest limit is Chrome, with 0x10000 args.
        // We go 1 magnitude less, for safety
        var MAX_ARGUMENTS_LENGTH = 0x1000

        function decodeCodePointsArray(codePoints) {
          var len = codePoints.length
          if (len <= MAX_ARGUMENTS_LENGTH) {
            return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
          }

          // Decode in chunks to avoid "call stack size exceeded".
          var res = ''
          var i = 0
          while (i < len) {
            res += String.fromCharCode.apply(
              String,
              codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
            )
          }
          return res
        }

        function asciiSlice(buf, start, end) {
          var ret = ''
          end = Math.min(buf.length, end)

          for (var i = start; i < end; ++i) {
            ret += String.fromCharCode(buf[i] & 0x7F)
          }
          return ret
        }

        function latin1Slice(buf, start, end) {
          var ret = ''
          end = Math.min(buf.length, end)

          for (var i = start; i < end; ++i) {
            ret += String.fromCharCode(buf[i])
          }
          return ret
        }

        function hexSlice(buf, start, end) {
          var len = buf.length

          if (!start || start < 0) start = 0
          if (!end || end < 0 || end > len) end = len

          var out = ''
          for (var i = start; i < end; ++i) {
            out += toHex(buf[i])
          }
          return out
        }

        function utf16leSlice(buf, start, end) {
          var bytes = buf.slice(start, end)
          var res = ''
          for (var i = 0; i < bytes.length; i += 2) {
            res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
          }
          return res
        }

        Buffer.prototype.slice = function slice(start, end) {
          var len = this.length
          start = ~~start
          end = end === undefined ? len : ~~end

          if (start < 0) {
            start += len
            if (start < 0) start = 0
          } else if (start > len) {
            start = len
          }

          if (end < 0) {
            end += len
            if (end < 0) end = 0
          } else if (end > len) {
            end = len
          }

          if (end < start) end = start

          var newBuf = this.subarray(start, end)
          // Return an augmented `Uint8Array` instance
          newBuf.__proto__ = Buffer.prototype
          return newBuf
        }

        /*
         * Need to make sure that buffer isn't trying to write out of bounds.
         */
        function checkOffset(offset, ext, length) {
          if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
          if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
        }

        Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
          offset = offset >>> 0
          byteLength = byteLength >>> 0
          if (!noAssert) checkOffset(offset, byteLength, this.length)

          var val = this[offset]
          var mul = 1
          var i = 0
          while (++i < byteLength && (mul *= 0x100)) {
            val += this[offset + i] * mul
          }

          return val
        }

        Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
          offset = offset >>> 0
          byteLength = byteLength >>> 0
          if (!noAssert) {
            checkOffset(offset, byteLength, this.length)
          }

          var val = this[offset + --byteLength]
          var mul = 1
          while (byteLength > 0 && (mul *= 0x100)) {
            val += this[offset + --byteLength] * mul
          }

          return val
        }

        Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
          offset = offset >>> 0
          if (!noAssert) checkOffset(offset, 1, this.length)
          return this[offset]
        }

        Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
          offset = offset >>> 0
          if (!noAssert) checkOffset(offset, 2, this.length)
          return this[offset] | (this[offset + 1] << 8)
        }

        Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
          offset = offset >>> 0
          if (!noAssert) checkOffset(offset, 2, this.length)
          return (this[offset] << 8) | this[offset + 1]
        }

        Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
          offset = offset >>> 0
          if (!noAssert) checkOffset(offset, 4, this.length)

          return ((this[offset]) |
            (this[offset + 1] << 8) |
            (this[offset + 2] << 16)) +
            (this[offset + 3] * 0x1000000)
        }

        Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
          offset = offset >>> 0
          if (!noAssert) checkOffset(offset, 4, this.length)

          return (this[offset] * 0x1000000) +
            ((this[offset + 1] << 16) |
              (this[offset + 2] << 8) |
              this[offset + 3])
        }

        Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
          offset = offset >>> 0
          byteLength = byteLength >>> 0
          if (!noAssert) checkOffset(offset, byteLength, this.length)

          var val = this[offset]
          var mul = 1
          var i = 0
          while (++i < byteLength && (mul *= 0x100)) {
            val += this[offset + i] * mul
          }
          mul *= 0x80

          if (val >= mul) val -= Math.pow(2, 8 * byteLength)

          return val
        }

        Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
          offset = offset >>> 0
          byteLength = byteLength >>> 0
          if (!noAssert) checkOffset(offset, byteLength, this.length)

          var i = byteLength
          var mul = 1
          var val = this[offset + --i]
          while (i > 0 && (mul *= 0x100)) {
            val += this[offset + --i] * mul
          }
          mul *= 0x80

          if (val >= mul) val -= Math.pow(2, 8 * byteLength)

          return val
        }

        Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
          offset = offset >>> 0
          if (!noAssert) checkOffset(offset, 1, this.length)
          if (!(this[offset] & 0x80)) return (this[offset])
          return ((0xff - this[offset] + 1) * -1)
        }

        Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
          offset = offset >>> 0
          if (!noAssert) checkOffset(offset, 2, this.length)
          var val = this[offset] | (this[offset + 1] << 8)
          return (val & 0x8000) ? val | 0xFFFF0000 : val
        }

        Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
          offset = offset >>> 0
          if (!noAssert) checkOffset(offset, 2, this.length)
          var val = this[offset + 1] | (this[offset] << 8)
          return (val & 0x8000) ? val | 0xFFFF0000 : val
        }

        Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
          offset = offset >>> 0
          if (!noAssert) checkOffset(offset, 4, this.length)

          return (this[offset]) |
            (this[offset + 1] << 8) |
            (this[offset + 2] << 16) |
            (this[offset + 3] << 24)
        }

        Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
          offset = offset >>> 0
          if (!noAssert) checkOffset(offset, 4, this.length)

          return (this[offset] << 24) |
            (this[offset + 1] << 16) |
            (this[offset + 2] << 8) |
            (this[offset + 3])
        }

        Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
          offset = offset >>> 0
          if (!noAssert) checkOffset(offset, 4, this.length)
          return ieee754.read(this, offset, true, 23, 4)
        }

        Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
          offset = offset >>> 0
          if (!noAssert) checkOffset(offset, 4, this.length)
          return ieee754.read(this, offset, false, 23, 4)
        }

        Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
          offset = offset >>> 0
          if (!noAssert) checkOffset(offset, 8, this.length)
          return ieee754.read(this, offset, true, 52, 8)
        }

        Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
          offset = offset >>> 0
          if (!noAssert) checkOffset(offset, 8, this.length)
          return ieee754.read(this, offset, false, 52, 8)
        }

        function checkInt(buf, value, offset, ext, max, min) {
          if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
          if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
          if (offset + ext > buf.length) throw new RangeError('Index out of range')
        }

        Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
          value = +value
          offset = offset >>> 0
          byteLength = byteLength >>> 0
          if (!noAssert) {
            var maxBytes = Math.pow(2, 8 * byteLength) - 1
            checkInt(this, value, offset, byteLength, maxBytes, 0)
          }

          var mul = 1
          var i = 0
          this[offset] = value & 0xFF
          while (++i < byteLength && (mul *= 0x100)) {
            this[offset + i] = (value / mul) & 0xFF
          }

          return offset + byteLength
        }

        Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
          value = +value
          offset = offset >>> 0
          byteLength = byteLength >>> 0
          if (!noAssert) {
            var maxBytes = Math.pow(2, 8 * byteLength) - 1
            checkInt(this, value, offset, byteLength, maxBytes, 0)
          }

          var i = byteLength - 1
          var mul = 1
          this[offset + i] = value & 0xFF
          while (--i >= 0 && (mul *= 0x100)) {
            this[offset + i] = (value / mul) & 0xFF
          }

          return offset + byteLength
        }

        Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
          value = +value
          offset = offset >>> 0
          if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
          this[offset] = (value & 0xff)
          return offset + 1
        }

        Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
          value = +value
          offset = offset >>> 0
          if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
          this[offset] = (value & 0xff)
          this[offset + 1] = (value >>> 8)
          return offset + 2
        }

        Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
          value = +value
          offset = offset >>> 0
          if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
          this[offset] = (value >>> 8)
          this[offset + 1] = (value & 0xff)
          return offset + 2
        }

        Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
          value = +value
          offset = offset >>> 0
          if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
          this[offset + 3] = (value >>> 24)
          this[offset + 2] = (value >>> 16)
          this[offset + 1] = (value >>> 8)
          this[offset] = (value & 0xff)
          return offset + 4
        }

        Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
          value = +value
          offset = offset >>> 0
          if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
          this[offset] = (value >>> 24)
          this[offset + 1] = (value >>> 16)
          this[offset + 2] = (value >>> 8)
          this[offset + 3] = (value & 0xff)
          return offset + 4
        }

        Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
          value = +value
          offset = offset >>> 0
          if (!noAssert) {
            var limit = Math.pow(2, (8 * byteLength) - 1)

            checkInt(this, value, offset, byteLength, limit - 1, -limit)
          }

          var i = 0
          var mul = 1
          var sub = 0
          this[offset] = value & 0xFF
          while (++i < byteLength && (mul *= 0x100)) {
            if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
              sub = 1
            }
            this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
          }

          return offset + byteLength
        }

        Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
          value = +value
          offset = offset >>> 0
          if (!noAssert) {
            var limit = Math.pow(2, (8 * byteLength) - 1)

            checkInt(this, value, offset, byteLength, limit - 1, -limit)
          }

          var i = byteLength - 1
          var mul = 1
          var sub = 0
          this[offset + i] = value & 0xFF
          while (--i >= 0 && (mul *= 0x100)) {
            if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
              sub = 1
            }
            this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
          }

          return offset + byteLength
        }

        Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
          value = +value
          offset = offset >>> 0
          if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
          if (value < 0) value = 0xff + value + 1
          this[offset] = (value & 0xff)
          return offset + 1
        }

        Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
          value = +value
          offset = offset >>> 0
          if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
          this[offset] = (value & 0xff)
          this[offset + 1] = (value >>> 8)
          return offset + 2
        }

        Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
          value = +value
          offset = offset >>> 0
          if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
          this[offset] = (value >>> 8)
          this[offset + 1] = (value & 0xff)
          return offset + 2
        }

        Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
          value = +value
          offset = offset >>> 0
          if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
          this[offset] = (value & 0xff)
          this[offset + 1] = (value >>> 8)
          this[offset + 2] = (value >>> 16)
          this[offset + 3] = (value >>> 24)
          return offset + 4
        }

        Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
          value = +value
          offset = offset >>> 0
          if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
          if (value < 0) value = 0xffffffff + value + 1
          this[offset] = (value >>> 24)
          this[offset + 1] = (value >>> 16)
          this[offset + 2] = (value >>> 8)
          this[offset + 3] = (value & 0xff)
          return offset + 4
        }

        function checkIEEE754(buf, value, offset, ext, max, min) {
          if (offset + ext > buf.length) throw new RangeError('Index out of range')
          if (offset < 0) throw new RangeError('Index out of range')
        }

        function writeFloat(buf, value, offset, littleEndian, noAssert) {
          value = +value
          offset = offset >>> 0
          if (!noAssert) {
            checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
          }
          ieee754.write(buf, value, offset, littleEndian, 23, 4)
          return offset + 4
        }

        Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
          return writeFloat(this, value, offset, true, noAssert)
        }

        Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
          return writeFloat(this, value, offset, false, noAssert)
        }

        function writeDouble(buf, value, offset, littleEndian, noAssert) {
          value = +value
          offset = offset >>> 0
          if (!noAssert) {
            checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
          }
          ieee754.write(buf, value, offset, littleEndian, 52, 8)
          return offset + 8
        }

        Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
          return writeDouble(this, value, offset, true, noAssert)
        }

        Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
          return writeDouble(this, value, offset, false, noAssert)
        }

        // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
        Buffer.prototype.copy = function copy(target, targetStart, start, end) {
          if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
          if (!start) start = 0
          if (!end && end !== 0) end = this.length
          if (targetStart >= target.length) targetStart = target.length
          if (!targetStart) targetStart = 0
          if (end > 0 && end < start) end = start

          // Copy 0 bytes; we're done
          if (end === start) return 0
          if (target.length === 0 || this.length === 0) return 0

          // Fatal error conditions
          if (targetStart < 0) {
            throw new RangeError('targetStart out of bounds')
          }
          if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
          if (end < 0) throw new RangeError('sourceEnd out of bounds')

          // Are we oob?
          if (end > this.length) end = this.length
          if (target.length - targetStart < end - start) {
            end = target.length - targetStart + start
          }

          var len = end - start

          if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
            // Use built-in when available, missing from IE11
            this.copyWithin(targetStart, start, end)
          } else if (this === target && start < targetStart && targetStart < end) {
            // descending copy from end
            for (var i = len - 1; i >= 0; --i) {
              target[i + targetStart] = this[i + start]
            }
          } else {
            Uint8Array.prototype.set.call(
              target,
              this.subarray(start, end),
              targetStart
            )
          }

          return len
        }

        // Usage:
        //    buffer.fill(number[, offset[, end]])
        //    buffer.fill(buffer[, offset[, end]])
        //    buffer.fill(string[, offset[, end]][, encoding])
        Buffer.prototype.fill = function fill(val, start, end, encoding) {
          // Handle string cases:
          if (typeof val === 'string') {
            if (typeof start === 'string') {
              encoding = start
              start = 0
              end = this.length
            } else if (typeof end === 'string') {
              encoding = end
              end = this.length
            }
            if (encoding !== undefined && typeof encoding !== 'string') {
              throw new TypeError('encoding must be a string')
            }
            if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
              throw new TypeError('Unknown encoding: ' + encoding)
            }
            if (val.length === 1) {
              var code = val.charCodeAt(0)
              if ((encoding === 'utf8' && code < 128) ||
                encoding === 'latin1') {
                // Fast path: If `val` fits into a single byte, use that numeric value.
                val = code
              }
            }
          } else if (typeof val === 'number') {
            val = val & 255
          }

          // Invalid ranges are not set to a default, so can range check early.
          if (start < 0 || this.length < start || this.length < end) {
            throw new RangeError('Out of range index')
          }

          if (end <= start) {
            return this
          }

          start = start >>> 0
          end = end === undefined ? this.length : end >>> 0

          if (!val) val = 0

          var i
          if (typeof val === 'number') {
            for (i = start; i < end; ++i) {
              this[i] = val
            }
          } else {
            var bytes = Buffer.isBuffer(val)
              ? val
              : Buffer.from(val, encoding)
            var len = bytes.length
            if (len === 0) {
              throw new TypeError('The value "' + val +
                '" is invalid for argument "value"')
            }
            for (i = 0; i < end - start; ++i) {
              this[i + start] = bytes[i % len]
            }
          }

          return this
        }

        // HELPER FUNCTIONS
        // ================

        var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

        function base64clean(str) {
          // Node takes equal signs as end of the Base64 encoding
          str = str.split('=')[0]
          // Node strips out invalid characters like \n and \t from the string, base64-js does not
          str = str.trim().replace(INVALID_BASE64_RE, '')
          // Node converts strings with length < 2 to ''
          if (str.length < 2) return ''
          // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
          while (str.length % 4 !== 0) {
            str = str + '='
          }
          return str
        }

        function toHex(n) {
          if (n < 16) return '0' + n.toString(16)
          return n.toString(16)
        }

        function utf8ToBytes(string, units) {
          units = units || Infinity
          var codePoint
          var length = string.length
          var leadSurrogate = null
          var bytes = []

          for (var i = 0; i < length; ++i) {
            codePoint = string.charCodeAt(i)

            // is surrogate component
            if (codePoint > 0xD7FF && codePoint < 0xE000) {
              // last char was a lead
              if (!leadSurrogate) {
                // no lead yet
                if (codePoint > 0xDBFF) {
                  // unexpected trail
                  if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
                  continue
                } else if (i + 1 === length) {
                  // unpaired lead
                  if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
                  continue
                }

                // valid lead
                leadSurrogate = codePoint

                continue
              }

              // 2 leads in a row
              if (codePoint < 0xDC00) {
                if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
                leadSurrogate = codePoint
                continue
              }

              // valid surrogate pair
              codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
            } else if (leadSurrogate) {
              // valid bmp char, but last char was a lead
              if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
            }

            leadSurrogate = null

            // encode utf8
            if (codePoint < 0x80) {
              if ((units -= 1) < 0) break
              bytes.push(codePoint)
            } else if (codePoint < 0x800) {
              if ((units -= 2) < 0) break
              bytes.push(
                codePoint >> 0x6 | 0xC0,
                codePoint & 0x3F | 0x80
              )
            } else if (codePoint < 0x10000) {
              if ((units -= 3) < 0) break
              bytes.push(
                codePoint >> 0xC | 0xE0,
                codePoint >> 0x6 & 0x3F | 0x80,
                codePoint & 0x3F | 0x80
              )
            } else if (codePoint < 0x110000) {
              if ((units -= 4) < 0) break
              bytes.push(
                codePoint >> 0x12 | 0xF0,
                codePoint >> 0xC & 0x3F | 0x80,
                codePoint >> 0x6 & 0x3F | 0x80,
                codePoint & 0x3F | 0x80
              )
            } else {
              throw new Error('Invalid code point')
            }
          }

          return bytes
        }

        function asciiToBytes(str) {
          var byteArray = []
          for (var i = 0; i < str.length; ++i) {
            // Node's code seems to be doing this and not & 0x7F..
            byteArray.push(str.charCodeAt(i) & 0xFF)
          }
          return byteArray
        }

        function utf16leToBytes(str, units) {
          var c, hi, lo
          var byteArray = []
          for (var i = 0; i < str.length; ++i) {
            if ((units -= 2) < 0) break

            c = str.charCodeAt(i)
            hi = c >> 8
            lo = c % 256
            byteArray.push(lo)
            byteArray.push(hi)
          }

          return byteArray
        }

        function base64ToBytes(str) {
          return base64.toByteArray(base64clean(str))
        }

        function blitBuffer(src, dst, offset, length) {
          for (var i = 0; i < length; ++i) {
            if ((i + offset >= dst.length) || (i >= src.length)) break
            dst[i + offset] = src[i]
          }
          return i
        }

        // ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
        // the `instanceof` check but they should be treated as of that type.
        // See: https://github.com/feross/buffer/issues/166
        function isInstance(obj, type) {
          return obj instanceof type ||
            (obj != null && obj.constructor != null && obj.constructor.name != null &&
              obj.constructor.name === type.name)
        }
        function numberIsNaN(obj) {
          // For IE11 support
          return obj !== obj // eslint-disable-line no-self-compare
        }

      }).call(this)
    }).call(this, require("buffer").Buffer)
  }, { "base64-js": 1, "buffer": 2, "ieee754": 3 }], 3: [function (require, module, exports) {
    /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
    exports.read = function (buffer, offset, isLE, mLen, nBytes) {
      var e, m
      var eLen = (nBytes * 8) - mLen - 1
      var eMax = (1 << eLen) - 1
      var eBias = eMax >> 1
      var nBits = -7
      var i = isLE ? (nBytes - 1) : 0
      var d = isLE ? -1 : 1
      var s = buffer[offset + i]

      i += d

      e = s & ((1 << (-nBits)) - 1)
      s >>= (-nBits)
      nBits += eLen
      for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) { }

      m = e & ((1 << (-nBits)) - 1)
      e >>= (-nBits)
      nBits += mLen
      for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) { }

      if (e === 0) {
        e = 1 - eBias
      } else if (e === eMax) {
        return m ? NaN : ((s ? -1 : 1) * Infinity)
      } else {
        m = m + Math.pow(2, mLen)
        e = e - eBias
      }
      return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
    }

    exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
      var e, m, c
      var eLen = (nBytes * 8) - mLen - 1
      var eMax = (1 << eLen) - 1
      var eBias = eMax >> 1
      var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
      var i = isLE ? 0 : (nBytes - 1)
      var d = isLE ? 1 : -1
      var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

      value = Math.abs(value)

      if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0
        e = eMax
      } else {
        e = Math.floor(Math.log(value) / Math.LN2)
        if (value * (c = Math.pow(2, -e)) < 1) {
          e--
          c *= 2
        }
        if (e + eBias >= 1) {
          value += rt / c
        } else {
          value += rt * Math.pow(2, 1 - eBias)
        }
        if (value * c >= 2) {
          e++
          c /= 2
        }

        if (e + eBias >= eMax) {
          m = 0
          e = eMax
        } else if (e + eBias >= 1) {
          m = ((value * c) - 1) * Math.pow(2, mLen)
          e = e + eBias
        } else {
          m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
          e = 0
        }
      }

      for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) { }

      e = (e << mLen) | m
      eLen += mLen
      for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) { }

      buffer[offset + i - d] |= s * 128
    }

  }, {}], 4: [function (require, module, exports) {
    // shim for using process in browser
    var process = module.exports = {};

    // cached from whatever global is present so that test runners that stub it
    // don't break things.  But we need to wrap it in a try catch in case it is
    // wrapped in strict mode code which doesn't define any globals.  It's inside a
    // function because try/catches deoptimize in certain engines.

    var cachedSetTimeout;
    var cachedClearTimeout;

    function defaultSetTimout() {
      throw new Error('setTimeout has not been defined');
    }
    function defaultClearTimeout() {
      throw new Error('clearTimeout has not been defined');
    }
    (function () {
      try {
        if (typeof setTimeout === 'function') {
          cachedSetTimeout = setTimeout;
        } else {
          cachedSetTimeout = defaultSetTimout;
        }
      } catch (e) {
        cachedSetTimeout = defaultSetTimout;
      }
      try {
        if (typeof clearTimeout === 'function') {
          cachedClearTimeout = clearTimeout;
        } else {
          cachedClearTimeout = defaultClearTimeout;
        }
      } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
      }
    }())
    function runTimeout(fun) {
      if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
      }
      // if setTimeout wasn't available but was latter defined
      if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
      }
      try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
      } catch (e) {
        try {
          // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
          return cachedSetTimeout.call(null, fun, 0);
        } catch (e) {
          // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
          return cachedSetTimeout.call(this, fun, 0);
        }
      }


    }
    function runClearTimeout(marker) {
      if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
      }
      // if clearTimeout wasn't available but was latter defined
      if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
      }
      try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
      } catch (e) {
        try {
          // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
          return cachedClearTimeout.call(null, marker);
        } catch (e) {
          // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
          // Some versions of I.E. have different rules for clearTimeout vs setTimeout
          return cachedClearTimeout.call(this, marker);
        }
      }



    }
    var queue = [];
    var draining = false;
    var currentQueue;
    var queueIndex = -1;

    function cleanUpNextTick() {
      if (!draining || !currentQueue) {
        return;
      }
      draining = false;
      if (currentQueue.length) {
        queue = currentQueue.concat(queue);
      } else {
        queueIndex = -1;
      }
      if (queue.length) {
        drainQueue();
      }
    }

    function drainQueue() {
      if (draining) {
        return;
      }
      var timeout = runTimeout(cleanUpNextTick);
      draining = true;

      var len = queue.length;
      while (len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
          if (currentQueue) {
            currentQueue[queueIndex].run();
          }
        }
        queueIndex = -1;
        len = queue.length;
      }
      currentQueue = null;
      draining = false;
      runClearTimeout(timeout);
    }

    process.nextTick = function (fun) {
      var args = new Array(arguments.length - 1);
      if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
          args[i - 1] = arguments[i];
        }
      }
      queue.push(new Item(fun, args));
      if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
      }
    };

    // v8 likes predictible objects
    function Item(fun, array) {
      this.fun = fun;
      this.array = array;
    }
    Item.prototype.run = function () {
      this.fun.apply(null, this.array);
    };
    process.title = 'browser';
    process.browser = true;
    process.env = {};
    process.argv = [];
    process.version = ''; // empty string to avoid regexp issues
    process.versions = {};

    function noop() { }

    process.on = noop;
    process.addListener = noop;
    process.once = noop;
    process.off = noop;
    process.removeListener = noop;
    process.removeAllListeners = noop;
    process.emit = noop;
    process.prependListener = noop;
    process.prependOnceListener = noop;

    process.listeners = function (name) { return [] }

    process.binding = function (name) {
      throw new Error('process.binding is not supported');
    };

    process.cwd = function () { return '/' };
    process.chdir = function (dir) {
      throw new Error('process.chdir is not supported');
    };
    process.umask = function () { return 0; };

  }, {}], 5: [function (require, module, exports) {
    (function (global) {
      (function () {
        var vop = require('@vaxxnz/nzcp').verifyPassURIOffline;
        global.window.vop = vop;
      }).call(this)
    }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
  }, { "@vaxxnz/nzcp": 6 }], 6: [function (require, module, exports) {
    (function (process, Buffer) {
      (function () {
        var u6 = Object.create, Ha = Object.defineProperty, c6 = Object.defineProperties, d6 = Object.getOwnPropertyDescriptor, l6 = Object.getOwnPropertyDescriptors, p6 = Object.getOwnPropertyNames, Kf = Object.getOwnPropertySymbols, v6 = Object.getPrototypeOf, hh = Object.prototype.hasOwnProperty, Bc = Object.prototype.propertyIsEnumerable, He = Math.pow, Ic = (t, e, r) => e in t ? Ha(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, Xe = (t, e) => { for (var r in e || (e = {})) hh.call(e, r) && Ic(t, r, e[r]); if (Kf) for (var r of Kf(e)) Bc.call(e, r) && Ic(t, r, e[r]); return t }, vr = (t, e) => c6(t, l6(e)), Rc = t => Ha(t, "__esModule", { value: !0 }); var Mt = (t, e) => { var r = {}; for (var i in t) hh.call(t, i) && e.indexOf(i) < 0 && (r[i] = t[i]); if (t != null && Kf) for (var i of Kf(t)) e.indexOf(i) < 0 && Bc.call(t, i) && (r[i] = t[i]); return r }; var I = (t, e) => () => (e || t((e = { exports: {} }).exports, e), e.exports), b6 = (t, e) => { for (var r in e) Ha(t, r, { get: e[r], enumerable: !0 }) }, y6 = (t, e, r) => { if (e && typeof e == "object" || typeof e == "function") for (let i of p6(e)) !hh.call(t, i) && i !== "default" && Ha(t, i, { get: () => e[i], enumerable: !(r = d6(e, i)) || r.enumerable }); return t }, qi = t => y6(Rc(Ha(t != null ? u6(v6(t)) : {}, "default", t && t.__esModule && "default" in t ? { get: () => t.default, enumerable: !0 } : { value: t, enumerable: !0 })), t); var Vf = (t, e, r) => new Promise((i, n) => { var f = y => { try { c(r.next(y)) } catch (x) { n(x) } }, h = y => { try { c(r.throw(y)) } catch (x) { n(x) } }, c = y => y.done ? i(y.value) : Promise.resolve(y.value).then(f, h); c((r = r.apply(t, e)).next()) }); var Oc = I(ki => { "use strict"; Object.defineProperty(ki, "__esModule", { value: !0 }); function Ln(t, e, r) { var i; if (r === void 0 && (r = {}), !e.codes) { e.codes = {}; for (var n = 0; n < e.chars.length; ++n)e.codes[e.chars[n]] = n } if (!r.loose && t.length * e.bits & 7) throw new SyntaxError("Invalid padding"); for (var f = t.length; t[f - 1] === "=";)if (--f, !r.loose && !((t.length - f) * e.bits & 7)) throw new SyntaxError("Invalid padding"); for (var h = new ((i = r.out) != null ? i : Uint8Array)(f * e.bits / 8 | 0), c = 0, y = 0, x = 0, M = 0; M < f; ++M) { var E = e.codes[t[M]]; if (E === void 0) throw new SyntaxError("Invalid character " + t[M]); y = y << e.bits | E, c += e.bits, c >= 8 && (c -= 8, h[x++] = 255 & y >> c) } if (c >= e.bits || 255 & y << 8 - c) throw new SyntaxError("Unexpected end of data"); return h } function Hn(t, e, r) { r === void 0 && (r = {}); for (var i = r, n = i.pad, f = n === void 0 ? !0 : n, h = (1 << e.bits) - 1, c = "", y = 0, x = 0, M = 0; M < t.length; ++M)for (x = x << 8 | 255 & t[M], y += 8; y > e.bits;)y -= e.bits, c += e.chars[h & x >> y]; if (y && (c += e.chars[h & x << e.bits - y]), f) for (; c.length * e.bits & 7;)c += "="; return c } var Tc = { chars: "0123456789ABCDEF", bits: 4 }, qc = { chars: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567", bits: 5 }, kc = { chars: "0123456789ABCDEFGHIJKLMNOPQRSTUV", bits: 5 }, Pc = { chars: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", bits: 6 }, Cc = { chars: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_", bits: 6 }, m6 = { parse: function (e, r) { return Ln(e.toUpperCase(), Tc, r) }, stringify: function (e, r) { return Hn(e, Tc, r) } }, g6 = { parse: function (e, r) { return r === void 0 && (r = {}), Ln(r.loose ? e.toUpperCase().replace(/0/g, "O").replace(/1/g, "L").replace(/8/g, "B") : e, qc, r) }, stringify: function (e, r) { return Hn(e, qc, r) } }, w6 = { parse: function (e, r) { return Ln(e, kc, r) }, stringify: function (e, r) { return Hn(e, kc, r) } }, _6 = { parse: function (e, r) { return Ln(e, Pc, r) }, stringify: function (e, r) { return Hn(e, Pc, r) } }, x6 = { parse: function (e, r) { return Ln(e, Cc, r) }, stringify: function (e, r) { return Hn(e, Cc, r) } }, M6 = { parse: Ln, stringify: Hn }; ki.base16 = m6; ki.base32 = g6; ki.base32hex = w6; ki.base64 = _6; ki.base64url = x6; ki.codec = M6 }); var Hc = I((Gr, Lc) => { var Nc = typeof self != "undefined" ? self : Gr, $f = function () { function t() { this.fetch = !1, this.DOMException = Nc.DOMException } return t.prototype = Nc, new t }(); (function (t) { var e = function (r) { var i = { searchParams: "URLSearchParams" in t, iterable: "Symbol" in t && "iterator" in Symbol, blob: "FileReader" in t && "Blob" in t && function () { try { return new Blob, !0 } catch (S) { return !1 } }(), formData: "FormData" in t, arrayBuffer: "ArrayBuffer" in t }; function n(S) { return S && DataView.prototype.isPrototypeOf(S) } if (i.arrayBuffer) var f = ["[object Int8Array]", "[object Uint8Array]", "[object Uint8ClampedArray]", "[object Int16Array]", "[object Uint16Array]", "[object Int32Array]", "[object Uint32Array]", "[object Float32Array]", "[object Float64Array]"], h = ArrayBuffer.isView || function (S) { return S && f.indexOf(Object.prototype.toString.call(S)) > -1 }; function c(S) { if (typeof S != "string" && (S = String(S)), /[^a-z0-9\-#$%&'*+.^_`|~]/i.test(S)) throw new TypeError("Invalid character in header field name"); return S.toLowerCase() } function y(S) { return typeof S != "string" && (S = String(S)), S } function x(S) { var b = { next: function () { var _ = S.shift(); return { done: _ === void 0, value: _ } } }; return i.iterable && (b[Symbol.iterator] = function () { return b }), b } function M(S) { this.map = {}, S instanceof M ? S.forEach(function (b, _) { this.append(_, b) }, this) : Array.isArray(S) ? S.forEach(function (b) { this.append(b[0], b[1]) }, this) : S && Object.getOwnPropertyNames(S).forEach(function (b) { this.append(b, S[b]) }, this) } M.prototype.append = function (S, b) { S = c(S), b = y(b); var _ = this.map[S]; this.map[S] = _ ? _ + ", " + b : b }, M.prototype.delete = function (S) { delete this.map[c(S)] }, M.prototype.get = function (S) { return S = c(S), this.has(S) ? this.map[S] : null }, M.prototype.has = function (S) { return this.map.hasOwnProperty(c(S)) }, M.prototype.set = function (S, b) { this.map[c(S)] = y(b) }, M.prototype.forEach = function (S, b) { for (var _ in this.map) this.map.hasOwnProperty(_) && S.call(b, this.map[_], _, this) }, M.prototype.keys = function () { var S = []; return this.forEach(function (b, _) { S.push(_) }), x(S) }, M.prototype.values = function () { var S = []; return this.forEach(function (b) { S.push(b) }), x(S) }, M.prototype.entries = function () { var S = []; return this.forEach(function (b, _) { S.push([_, b]) }), x(S) }, i.iterable && (M.prototype[Symbol.iterator] = M.prototype.entries); function E(S) { if (S.bodyUsed) return Promise.reject(new TypeError("Already read")); S.bodyUsed = !0 } function A(S) { return new Promise(function (b, _) { S.onload = function () { b(S.result) }, S.onerror = function () { _(S.error) } }) } function B(S) { var b = new FileReader, _ = A(b); return b.readAsArrayBuffer(S), _ } function T(S) { var b = new FileReader, _ = A(b); return b.readAsText(S), _ } function C(S) { for (var b = new Uint8Array(S), _ = new Array(b.length), l = 0; l < b.length; l++)_[l] = String.fromCharCode(b[l]); return _.join("") } function H(S) { if (S.slice) return S.slice(0); var b = new Uint8Array(S.byteLength); return b.set(new Uint8Array(S)), b.buffer } function F() { return this.bodyUsed = !1, this._initBody = function (S) { this._bodyInit = S, S ? typeof S == "string" ? this._bodyText = S : i.blob && Blob.prototype.isPrototypeOf(S) ? this._bodyBlob = S : i.formData && FormData.prototype.isPrototypeOf(S) ? this._bodyFormData = S : i.searchParams && URLSearchParams.prototype.isPrototypeOf(S) ? this._bodyText = S.toString() : i.arrayBuffer && i.blob && n(S) ? (this._bodyArrayBuffer = H(S.buffer), this._bodyInit = new Blob([this._bodyArrayBuffer])) : i.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(S) || h(S)) ? this._bodyArrayBuffer = H(S) : this._bodyText = S = Object.prototype.toString.call(S) : this._bodyText = "", this.headers.get("content-type") || (typeof S == "string" ? this.headers.set("content-type", "text/plain;charset=UTF-8") : this._bodyBlob && this._bodyBlob.type ? this.headers.set("content-type", this._bodyBlob.type) : i.searchParams && URLSearchParams.prototype.isPrototypeOf(S) && this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8")) }, i.blob && (this.blob = function () { var S = E(this); if (S) return S; if (this._bodyBlob) return Promise.resolve(this._bodyBlob); if (this._bodyArrayBuffer) return Promise.resolve(new Blob([this._bodyArrayBuffer])); if (this._bodyFormData) throw new Error("could not read FormData body as blob"); return Promise.resolve(new Blob([this._bodyText])) }, this.arrayBuffer = function () { return this._bodyArrayBuffer ? E(this) || Promise.resolve(this._bodyArrayBuffer) : this.blob().then(B) }), this.text = function () { var S = E(this); if (S) return S; if (this._bodyBlob) return T(this._bodyBlob); if (this._bodyArrayBuffer) return Promise.resolve(C(this._bodyArrayBuffer)); if (this._bodyFormData) throw new Error("could not read FormData body as text"); return Promise.resolve(this._bodyText) }, i.formData && (this.formData = function () { return this.text().then(Le) }), this.json = function () { return this.text().then(JSON.parse) }, this } var we = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"]; function Be(S) { var b = S.toUpperCase(); return we.indexOf(b) > -1 ? b : S } function xe(S, b) { b = b || {}; var _ = b.body; if (S instanceof xe) { if (S.bodyUsed) throw new TypeError("Already read"); this.url = S.url, this.credentials = S.credentials, b.headers || (this.headers = new M(S.headers)), this.method = S.method, this.mode = S.mode, this.signal = S.signal, !_ && S._bodyInit != null && (_ = S._bodyInit, S.bodyUsed = !0) } else this.url = String(S); if (this.credentials = b.credentials || this.credentials || "same-origin", (b.headers || !this.headers) && (this.headers = new M(b.headers)), this.method = Be(b.method || this.method || "GET"), this.mode = b.mode || this.mode || null, this.signal = b.signal || this.signal, this.referrer = null, (this.method === "GET" || this.method === "HEAD") && _) throw new TypeError("Body not allowed for GET or HEAD requests"); this._initBody(_) } xe.prototype.clone = function () { return new xe(this, { body: this._bodyInit }) }; function Le(S) { var b = new FormData; return S.trim().split("&").forEach(function (_) { if (_) { var l = _.split("="), a = l.shift().replace(/\+/g, " "), s = l.join("=").replace(/\+/g, " "); b.append(decodeURIComponent(a), decodeURIComponent(s)) } }), b } function Me(S) { var b = new M, _ = S.replace(/\r?\n[\t ]+/g, " "); return _.split(/\r?\n/).forEach(function (l) { var a = l.split(":"), s = a.shift().trim(); if (s) { var d = a.join(":").trim(); b.append(s, d) } }), b } F.call(xe.prototype); function De(S, b) { b || (b = {}), this.type = "default", this.status = b.status === void 0 ? 200 : b.status, this.ok = this.status >= 200 && this.status < 300, this.statusText = "statusText" in b ? b.statusText : "OK", this.headers = new M(b.headers), this.url = b.url || "", this._initBody(S) } F.call(De.prototype), De.prototype.clone = function () { return new De(this._bodyInit, { status: this.status, statusText: this.statusText, headers: new M(this.headers), url: this.url }) }, De.error = function () { var S = new De(null, { status: 0, statusText: "" }); return S.type = "error", S }; var Ie = [301, 302, 303, 307, 308]; De.redirect = function (S, b) { if (Ie.indexOf(b) === -1) throw new RangeError("Invalid status code"); return new De(null, { status: b, headers: { location: S } }) }, r.DOMException = t.DOMException; try { new r.DOMException } catch (S) { r.DOMException = function (b, _) { this.message = b, this.name = _; var l = Error(b); this.stack = l.stack }, r.DOMException.prototype = Object.create(Error.prototype), r.DOMException.prototype.constructor = r.DOMException } function je(S, b) { return new Promise(function (_, l) { var a = new xe(S, b); if (a.signal && a.signal.aborted) return l(new r.DOMException("Aborted", "AbortError")); var s = new XMLHttpRequest; function d() { s.abort() } s.onload = function () { var v = { status: s.status, statusText: s.statusText, headers: Me(s.getAllResponseHeaders() || "") }; v.url = "responseURL" in s ? s.responseURL : v.headers.get("X-Request-URL"); var p = "response" in s ? s.response : s.responseText; _(new De(p, v)) }, s.onerror = function () { l(new TypeError("Network request failed")) }, s.ontimeout = function () { l(new TypeError("Network request failed")) }, s.onabort = function () { l(new r.DOMException("Aborted", "AbortError")) }, s.open(a.method, a.url, !0), a.credentials === "include" ? s.withCredentials = !0 : a.credentials === "omit" && (s.withCredentials = !1), "responseType" in s && i.blob && (s.responseType = "blob"), a.headers.forEach(function (v, p) { s.setRequestHeader(p, v) }), a.signal && (a.signal.addEventListener("abort", d), s.onreadystatechange = function () { s.readyState === 4 && a.signal.removeEventListener("abort", d) }), s.send(typeof a._bodyInit == "undefined" ? null : a._bodyInit) }) } return je.polyfill = !0, t.fetch || (t.fetch = je, t.Headers = M, t.Request = xe, t.Response = De), r.Headers = M, r.Request = xe, r.Response = De, r.fetch = je, Object.defineProperty(r, "__esModule", { value: !0 }), r }({}) })($f); $f.fetch.ponyfill = !0; delete $f.fetch.polyfill; var jn = $f; Gr = jn.fetch; Gr.default = jn.fetch; Gr.fetch = jn.fetch; Gr.Headers = jn.Headers; Gr.Request = jn.Request; Gr.Response = jn.Response; Lc.exports = Gr }); var Vc = I((exports, module) => { (function () { "use strict"; var ERROR = "input is invalid type", WINDOW = typeof window == "object", root = WINDOW ? window : {}; root.JS_SHA256_NO_WINDOW && (WINDOW = !1); var WEB_WORKER = !WINDOW && typeof self == "object", NODE_JS = !root.JS_SHA256_NO_NODE_JS && typeof process == "object" && process.versions && process.versions.node; NODE_JS ? root = window : WEB_WORKER && (root = self); var COMMON_JS = !root.JS_SHA256_NO_COMMON_JS && typeof module == "object" && module.exports, AMD = typeof define == "function" && define.amd, ARRAY_BUFFER = !root.JS_SHA256_NO_ARRAY_BUFFER && typeof ArrayBuffer != "undefined", HEX_CHARS = "0123456789abcdef".split(""), EXTRA = [-2147483648, 8388608, 32768, 128], SHIFT = [24, 16, 8, 0], K = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298], OUTPUT_TYPES = ["hex", "array", "digest", "arrayBuffer"], blocks = []; (root.JS_SHA256_NO_NODE_JS || !Array.isArray) && (Array.isArray = function (t) { return Object.prototype.toString.call(t) === "[object Array]" }), ARRAY_BUFFER && (root.JS_SHA256_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView) && (ArrayBuffer.isView = function (t) { return typeof t == "object" && t.buffer && t.buffer.constructor === ArrayBuffer }); var createOutputMethod = function (t, e) { return function (r) { return new Sha256(e, !0).update(r)[t]() } }, createMethod = function (t) { var e = createOutputMethod("hex", t); NODE_JS && (e = nodeWrap(e, t)), e.create = function () { return new Sha256(t) }, e.update = function (n) { return e.create().update(n) }; for (var r = 0; r < OUTPUT_TYPES.length; ++r) { var i = OUTPUT_TYPES[r]; e[i] = createOutputMethod(i, t) } return e }, nodeWrap = function (method, is224) { var crypto = eval("require('crypto')"), Buffer = eval("require('buffer').Buffer"), algorithm = is224 ? "sha224" : "sha256", nodeMethod = function (t) { if (typeof t == "string") return crypto.createHash(algorithm).update(t, "utf8").digest("hex"); if (t == null) throw new Error(ERROR); return t.constructor === ArrayBuffer && (t = new Uint8Array(t)), Array.isArray(t) || ArrayBuffer.isView(t) || t.constructor === Buffer ? crypto.createHash(algorithm).update(new Buffer(t)).digest("hex") : method(t) }; return nodeMethod }, createHmacOutputMethod = function (t, e) { return function (r, i) { return new HmacSha256(r, e, !0).update(i)[t]() } }, createHmacMethod = function (t) { var e = createHmacOutputMethod("hex", t); e.create = function (n) { return new HmacSha256(n, t) }, e.update = function (n, f) { return e.create(n).update(f) }; for (var r = 0; r < OUTPUT_TYPES.length; ++r) { var i = OUTPUT_TYPES[r]; e[i] = createHmacOutputMethod(i, t) } return e }; function Sha256(t, e) { e ? (blocks[0] = blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0, this.blocks = blocks) : this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], t ? (this.h0 = 3238371032, this.h1 = 914150663, this.h2 = 812702999, this.h3 = 4144912697, this.h4 = 4290775857, this.h5 = 1750603025, this.h6 = 1694076839, this.h7 = 3204075428) : (this.h0 = 1779033703, this.h1 = 3144134277, this.h2 = 1013904242, this.h3 = 2773480762, this.h4 = 1359893119, this.h5 = 2600822924, this.h6 = 528734635, this.h7 = 1541459225), this.block = this.start = this.bytes = this.hBytes = 0, this.finalized = this.hashed = !1, this.first = !0, this.is224 = t } Sha256.prototype.update = function (t) { if (!this.finalized) { var e, r = typeof t; if (r !== "string") { if (r === "object") { if (t === null) throw new Error(ERROR); if (ARRAY_BUFFER && t.constructor === ArrayBuffer) t = new Uint8Array(t); else if (!Array.isArray(t) && (!ARRAY_BUFFER || !ArrayBuffer.isView(t))) throw new Error(ERROR) } else throw new Error(ERROR); e = !0 } for (var i, n = 0, f, h = t.length, c = this.blocks; n < h;) { if (this.hashed && (this.hashed = !1, c[0] = this.block, c[16] = c[1] = c[2] = c[3] = c[4] = c[5] = c[6] = c[7] = c[8] = c[9] = c[10] = c[11] = c[12] = c[13] = c[14] = c[15] = 0), e) for (f = this.start; n < h && f < 64; ++n)c[f >> 2] |= t[n] << SHIFT[f++ & 3]; else for (f = this.start; n < h && f < 64; ++n)i = t.charCodeAt(n), i < 128 ? c[f >> 2] |= i << SHIFT[f++ & 3] : i < 2048 ? (c[f >> 2] |= (192 | i >> 6) << SHIFT[f++ & 3], c[f >> 2] |= (128 | i & 63) << SHIFT[f++ & 3]) : i < 55296 || i >= 57344 ? (c[f >> 2] |= (224 | i >> 12) << SHIFT[f++ & 3], c[f >> 2] |= (128 | i >> 6 & 63) << SHIFT[f++ & 3], c[f >> 2] |= (128 | i & 63) << SHIFT[f++ & 3]) : (i = 65536 + ((i & 1023) << 10 | t.charCodeAt(++n) & 1023), c[f >> 2] |= (240 | i >> 18) << SHIFT[f++ & 3], c[f >> 2] |= (128 | i >> 12 & 63) << SHIFT[f++ & 3], c[f >> 2] |= (128 | i >> 6 & 63) << SHIFT[f++ & 3], c[f >> 2] |= (128 | i & 63) << SHIFT[f++ & 3]); this.lastByteIndex = f, this.bytes += f - this.start, f >= 64 ? (this.block = c[16], this.start = f - 64, this.hash(), this.hashed = !0) : this.start = f } return this.bytes > 4294967295 && (this.hBytes += this.bytes / 4294967296 << 0, this.bytes = this.bytes % 4294967296), this } }, Sha256.prototype.finalize = function () { if (!this.finalized) { this.finalized = !0; var t = this.blocks, e = this.lastByteIndex; t[16] = this.block, t[e >> 2] |= EXTRA[e & 3], this.block = t[16], e >= 56 && (this.hashed || this.hash(), t[0] = this.block, t[16] = t[1] = t[2] = t[3] = t[4] = t[5] = t[6] = t[7] = t[8] = t[9] = t[10] = t[11] = t[12] = t[13] = t[14] = t[15] = 0), t[14] = this.hBytes << 3 | this.bytes >>> 29, t[15] = this.bytes << 3, this.hash() } }, Sha256.prototype.hash = function () { var t = this.h0, e = this.h1, r = this.h2, i = this.h3, n = this.h4, f = this.h5, h = this.h6, c = this.h7, y = this.blocks, x, M, E, A, B, T, C, H, F, we, Be; for (x = 16; x < 64; ++x)B = y[x - 15], M = (B >>> 7 | B << 25) ^ (B >>> 18 | B << 14) ^ B >>> 3, B = y[x - 2], E = (B >>> 17 | B << 15) ^ (B >>> 19 | B << 13) ^ B >>> 10, y[x] = y[x - 16] + M + y[x - 7] + E << 0; for (Be = e & r, x = 0; x < 64; x += 4)this.first ? (this.is224 ? (H = 300032, B = y[0] - 1413257819, c = B - 150054599 << 0, i = B + 24177077 << 0) : (H = 704751109, B = y[0] - 210244248, c = B - 1521486534 << 0, i = B + 143694565 << 0), this.first = !1) : (M = (t >>> 2 | t << 30) ^ (t >>> 13 | t << 19) ^ (t >>> 22 | t << 10), E = (n >>> 6 | n << 26) ^ (n >>> 11 | n << 21) ^ (n >>> 25 | n << 7), H = t & e, A = H ^ t & r ^ Be, C = n & f ^ ~n & h, B = c + E + C + K[x] + y[x], T = M + A, c = i + B << 0, i = B + T << 0), M = (i >>> 2 | i << 30) ^ (i >>> 13 | i << 19) ^ (i >>> 22 | i << 10), E = (c >>> 6 | c << 26) ^ (c >>> 11 | c << 21) ^ (c >>> 25 | c << 7), F = i & t, A = F ^ i & e ^ H, C = c & n ^ ~c & f, B = h + E + C + K[x + 1] + y[x + 1], T = M + A, h = r + B << 0, r = B + T << 0, M = (r >>> 2 | r << 30) ^ (r >>> 13 | r << 19) ^ (r >>> 22 | r << 10), E = (h >>> 6 | h << 26) ^ (h >>> 11 | h << 21) ^ (h >>> 25 | h << 7), we = r & i, A = we ^ r & t ^ F, C = h & c ^ ~h & n, B = f + E + C + K[x + 2] + y[x + 2], T = M + A, f = e + B << 0, e = B + T << 0, M = (e >>> 2 | e << 30) ^ (e >>> 13 | e << 19) ^ (e >>> 22 | e << 10), E = (f >>> 6 | f << 26) ^ (f >>> 11 | f << 21) ^ (f >>> 25 | f << 7), Be = e & r, A = Be ^ e & i ^ we, C = f & h ^ ~f & c, B = n + E + C + K[x + 3] + y[x + 3], T = M + A, n = t + B << 0, t = B + T << 0; this.h0 = this.h0 + t << 0, this.h1 = this.h1 + e << 0, this.h2 = this.h2 + r << 0, this.h3 = this.h3 + i << 0, this.h4 = this.h4 + n << 0, this.h5 = this.h5 + f << 0, this.h6 = this.h6 + h << 0, this.h7 = this.h7 + c << 0 }, Sha256.prototype.hex = function () { this.finalize(); var t = this.h0, e = this.h1, r = this.h2, i = this.h3, n = this.h4, f = this.h5, h = this.h6, c = this.h7, y = HEX_CHARS[t >> 28 & 15] + HEX_CHARS[t >> 24 & 15] + HEX_CHARS[t >> 20 & 15] + HEX_CHARS[t >> 16 & 15] + HEX_CHARS[t >> 12 & 15] + HEX_CHARS[t >> 8 & 15] + HEX_CHARS[t >> 4 & 15] + HEX_CHARS[t & 15] + HEX_CHARS[e >> 28 & 15] + HEX_CHARS[e >> 24 & 15] + HEX_CHARS[e >> 20 & 15] + HEX_CHARS[e >> 16 & 15] + HEX_CHARS[e >> 12 & 15] + HEX_CHARS[e >> 8 & 15] + HEX_CHARS[e >> 4 & 15] + HEX_CHARS[e & 15] + HEX_CHARS[r >> 28 & 15] + HEX_CHARS[r >> 24 & 15] + HEX_CHARS[r >> 20 & 15] + HEX_CHARS[r >> 16 & 15] + HEX_CHARS[r >> 12 & 15] + HEX_CHARS[r >> 8 & 15] + HEX_CHARS[r >> 4 & 15] + HEX_CHARS[r & 15] + HEX_CHARS[i >> 28 & 15] + HEX_CHARS[i >> 24 & 15] + HEX_CHARS[i >> 20 & 15] + HEX_CHARS[i >> 16 & 15] + HEX_CHARS[i >> 12 & 15] + HEX_CHARS[i >> 8 & 15] + HEX_CHARS[i >> 4 & 15] + HEX_CHARS[i & 15] + HEX_CHARS[n >> 28 & 15] + HEX_CHARS[n >> 24 & 15] + HEX_CHARS[n >> 20 & 15] + HEX_CHARS[n >> 16 & 15] + HEX_CHARS[n >> 12 & 15] + HEX_CHARS[n >> 8 & 15] + HEX_CHARS[n >> 4 & 15] + HEX_CHARS[n & 15] + HEX_CHARS[f >> 28 & 15] + HEX_CHARS[f >> 24 & 15] + HEX_CHARS[f >> 20 & 15] + HEX_CHARS[f >> 16 & 15] + HEX_CHARS[f >> 12 & 15] + HEX_CHARS[f >> 8 & 15] + HEX_CHARS[f >> 4 & 15] + HEX_CHARS[f & 15] + HEX_CHARS[h >> 28 & 15] + HEX_CHARS[h >> 24 & 15] + HEX_CHARS[h >> 20 & 15] + HEX_CHARS[h >> 16 & 15] + HEX_CHARS[h >> 12 & 15] + HEX_CHARS[h >> 8 & 15] + HEX_CHARS[h >> 4 & 15] + HEX_CHARS[h & 15]; return this.is224 || (y += HEX_CHARS[c >> 28 & 15] + HEX_CHARS[c >> 24 & 15] + HEX_CHARS[c >> 20 & 15] + HEX_CHARS[c >> 16 & 15] + HEX_CHARS[c >> 12 & 15] + HEX_CHARS[c >> 8 & 15] + HEX_CHARS[c >> 4 & 15] + HEX_CHARS[c & 15]), y }, Sha256.prototype.toString = Sha256.prototype.hex, Sha256.prototype.digest = function () { this.finalize(); var t = this.h0, e = this.h1, r = this.h2, i = this.h3, n = this.h4, f = this.h5, h = this.h6, c = this.h7, y = [t >> 24 & 255, t >> 16 & 255, t >> 8 & 255, t & 255, e >> 24 & 255, e >> 16 & 255, e >> 8 & 255, e & 255, r >> 24 & 255, r >> 16 & 255, r >> 8 & 255, r & 255, i >> 24 & 255, i >> 16 & 255, i >> 8 & 255, i & 255, n >> 24 & 255, n >> 16 & 255, n >> 8 & 255, n & 255, f >> 24 & 255, f >> 16 & 255, f >> 8 & 255, f & 255, h >> 24 & 255, h >> 16 & 255, h >> 8 & 255, h & 255]; return this.is224 || y.push(c >> 24 & 255, c >> 16 & 255, c >> 8 & 255, c & 255), y }, Sha256.prototype.array = Sha256.prototype.digest, Sha256.prototype.arrayBuffer = function () { this.finalize(); var t = new ArrayBuffer(this.is224 ? 28 : 32), e = new DataView(t); return e.setUint32(0, this.h0), e.setUint32(4, this.h1), e.setUint32(8, this.h2), e.setUint32(12, this.h3), e.setUint32(16, this.h4), e.setUint32(20, this.h5), e.setUint32(24, this.h6), this.is224 || e.setUint32(28, this.h7), t }; function HmacSha256(t, e, r) { var i, n = typeof t; if (n === "string") { var f = [], h = t.length, c = 0, y; for (i = 0; i < h; ++i)y = t.charCodeAt(i), y < 128 ? f[c++] = y : y < 2048 ? (f[c++] = 192 | y >> 6, f[c++] = 128 | y & 63) : y < 55296 || y >= 57344 ? (f[c++] = 224 | y >> 12, f[c++] = 128 | y >> 6 & 63, f[c++] = 128 | y & 63) : (y = 65536 + ((y & 1023) << 10 | t.charCodeAt(++i) & 1023), f[c++] = 240 | y >> 18, f[c++] = 128 | y >> 12 & 63, f[c++] = 128 | y >> 6 & 63, f[c++] = 128 | y & 63); t = f } else if (n === "object") { if (t === null) throw new Error(ERROR); if (ARRAY_BUFFER && t.constructor === ArrayBuffer) t = new Uint8Array(t); else if (!Array.isArray(t) && (!ARRAY_BUFFER || !ArrayBuffer.isView(t))) throw new Error(ERROR) } else throw new Error(ERROR); t.length > 64 && (t = new Sha256(e, !0).update(t).array()); var x = [], M = []; for (i = 0; i < 64; ++i) { var E = t[i] || 0; x[i] = 92 ^ E, M[i] = 54 ^ E } Sha256.call(this, e, r), this.update(M), this.oKeyPad = x, this.inner = !0, this.sharedMemory = r } HmacSha256.prototype = new Sha256, HmacSha256.prototype.finalize = function () { if (Sha256.prototype.finalize.call(this), this.inner) { this.inner = !1; var t = this.array(); Sha256.call(this, this.is224, this.sharedMemory), this.update(this.oKeyPad), this.update(t), Sha256.prototype.finalize.call(this) } }; var exports = createMethod(); exports.sha256 = exports, exports.sha224 = createMethod(!0), exports.sha256.hmac = createHmacMethod(), exports.sha224.hmac = createHmacMethod(!0), COMMON_JS ? module.exports = exports : (root.sha256 = exports.sha256, root.sha224 = exports.sha224, AMD && define(function () { return exports })) })() }); var Gc = I((rE, K6) => { K6.exports = { name: "elliptic", version: "6.5.4", description: "EC cryptography", main: "lib/elliptic.js", files: ["lib"], scripts: { lint: "eslint lib test", "lint:fix": "npm run lint -- --fix", unit: "istanbul test _mocha --reporter=spec test/index.js", test: "npm run lint && npm run unit", version: "grunt dist && git add dist/" }, repository: { type: "git", url: "git@github.com:indutny/elliptic" }, keywords: ["EC", "Elliptic", "curve", "Cryptography"], author: "Fedor Indutny <fedor@indutny.com>", license: "MIT", bugs: { url: "https://github.com/indutny/elliptic/issues" }, homepage: "https://github.com/indutny/elliptic", devDependencies: { brfs: "^2.0.2", coveralls: "^3.1.0", eslint: "^7.6.0", grunt: "^1.2.1", "grunt-browserify": "^5.3.0", "grunt-cli": "^1.3.2", "grunt-contrib-connect": "^3.0.0", "grunt-contrib-copy": "^1.0.0", "grunt-contrib-uglify": "^5.0.0", "grunt-mocha-istanbul": "^5.0.2", "grunt-saucelabs": "^9.0.1", istanbul: "^0.4.5", mocha: "^8.0.1" }, dependencies: { "bn.js": "^4.11.9", brorand: "^1.1.0", "hash.js": "^1.0.0", "hmac-drbg": "^1.0.1", inherits: "^2.0.4", "minimalistic-assert": "^1.0.1", "minimalistic-crypto-utils": "^1.0.1" } } }); var Xc = I(Xf => { "use strict"; Xf.byteLength = $6; Xf.toByteArray = Y6; Xf.fromByteArray = Q6; var Rr = [], Dt = [], V6 = typeof Uint8Array != "undefined" ? Uint8Array : Array, lh = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"; for (var Wn = 0, G6 = lh.length; Wn < G6; ++Wn)Rr[Wn] = lh[Wn], Dt[lh.charCodeAt(Wn)] = Wn; Dt["-".charCodeAt(0)] = 62; Dt["_".charCodeAt(0)] = 63; function $c(t) { var e = t.length; if (e % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4"); var r = t.indexOf("="); r === -1 && (r = e); var i = r === e ? 0 : 4 - r % 4; return [r, i] } function $6(t) { var e = $c(t), r = e[0], i = e[1]; return (r + i) * 3 / 4 - i } function X6(t, e, r) { return (e + r) * 3 / 4 - r } function Y6(t) { var e, r = $c(t), i = r[0], n = r[1], f = new V6(X6(t, i, n)), h = 0, c = n > 0 ? i - 4 : i, y; for (y = 0; y < c; y += 4)e = Dt[t.charCodeAt(y)] << 18 | Dt[t.charCodeAt(y + 1)] << 12 | Dt[t.charCodeAt(y + 2)] << 6 | Dt[t.charCodeAt(y + 3)], f[h++] = e >> 16 & 255, f[h++] = e >> 8 & 255, f[h++] = e & 255; return n === 2 && (e = Dt[t.charCodeAt(y)] << 2 | Dt[t.charCodeAt(y + 1)] >> 4, f[h++] = e & 255), n === 1 && (e = Dt[t.charCodeAt(y)] << 10 | Dt[t.charCodeAt(y + 1)] << 4 | Dt[t.charCodeAt(y + 2)] >> 2, f[h++] = e >> 8 & 255, f[h++] = e & 255), f } function Z6(t) { return Rr[t >> 18 & 63] + Rr[t >> 12 & 63] + Rr[t >> 6 & 63] + Rr[t & 63] } function J6(t, e, r) { for (var i, n = [], f = e; f < r; f += 3)i = (t[f] << 16 & 16711680) + (t[f + 1] << 8 & 65280) + (t[f + 2] & 255), n.push(Z6(i)); return n.join("") } function Q6(t) { for (var e, r = t.length, i = r % 3, n = [], f = 16383, h = 0, c = r - i; h < c; h += f)n.push(J6(t, h, h + f > c ? c : h + f)); return i === 1 ? (e = t[r - 1], n.push(Rr[e >> 2] + Rr[e << 4 & 63] + "==")) : i === 2 && (e = (t[r - 2] << 8) + t[r - 1], n.push(Rr[e >> 10] + Rr[e >> 4 & 63] + Rr[e << 2 & 63] + "=")), n.join("") } }); var Yc = I(ph => { ph.read = function (t, e, r, i, n) { var f, h, c = n * 8 - i - 1, y = (1 << c) - 1, x = y >> 1, M = -7, E = r ? n - 1 : 0, A = r ? -1 : 1, B = t[e + E]; for (E += A, f = B & (1 << -M) - 1, B >>= -M, M += c; M > 0; f = f * 256 + t[e + E], E += A, M -= 8); for (h = f & (1 << -M) - 1, f >>= -M, M += i; M > 0; h = h * 256 + t[e + E], E += A, M -= 8); if (f === 0) f = 1 - x; else { if (f === y) return h ? NaN : (B ? -1 : 1) * Infinity; h = h + Math.pow(2, i), f = f - x } return (B ? -1 : 1) * h * Math.pow(2, f - i) }; ph.write = function (t, e, r, i, n, f) { var h, c, y, x = f * 8 - n - 1, M = (1 << x) - 1, E = M >> 1, A = n === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, B = i ? 0 : f - 1, T = i ? 1 : -1, C = e < 0 || e === 0 && 1 / e < 0 ? 1 : 0; for (e = Math.abs(e), isNaN(e) || e === Infinity ? (c = isNaN(e) ? 1 : 0, h = M) : (h = Math.floor(Math.log(e) / Math.LN2), e * (y = Math.pow(2, -h)) < 1 && (h--, y *= 2), h + E >= 1 ? e += A / y : e += A * Math.pow(2, 1 - E), e * y >= 2 && (h++, y /= 2), h + E >= M ? (c = 0, h = M) : h + E >= 1 ? (c = (e * y - 1) * Math.pow(2, n), h = h + E) : (c = e * Math.pow(2, E - 1) * Math.pow(2, n), h = 0)); n >= 8; t[r + B] = c & 255, B += T, c /= 256, n -= 8); for (h = h << n | c, x += n; x > 0; t[r + B] = h & 255, B += T, h /= 256, x -= 8); t[r + B - T] |= C * 128 } }); var ct = I($n => { "use strict"; var vh = Xc(), Kn = Yc(), Zc = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null; $n.Buffer = P; $n.SlowBuffer = a3; $n.INSPECT_MAX_BYTES = 50; var Yf = 2147483647; $n.kMaxLength = Yf; P.TYPED_ARRAY_SUPPORT = e3(); !P.TYPED_ARRAY_SUPPORT && typeof console != "undefined" && typeof console.error == "function" && console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."); function e3() { try { let t = new Uint8Array(1), e = { foo: function () { return 42 } }; return Object.setPrototypeOf(e, Uint8Array.prototype), Object.setPrototypeOf(t, e), t.foo() === 42 } catch (t) { return !1 } } Object.defineProperty(P.prototype, "parent", { enumerable: !0, get: function () { if (!!P.isBuffer(this)) return this.buffer } }); Object.defineProperty(P.prototype, "offset", { enumerable: !0, get: function () { if (!!P.isBuffer(this)) return this.byteOffset } }); function $r(t) { if (t > Yf) throw new RangeError('The value "' + t + '" is invalid for option "size"'); let e = new Uint8Array(t); return Object.setPrototypeOf(e, P.prototype), e } function P(t, e, r) { if (typeof t == "number") { if (typeof e == "string") throw new TypeError('The "string" argument must be of type string. Received type number'); return bh(t) } return Jc(t, e, r) } P.poolSize = 8192; function Jc(t, e, r) { if (typeof t == "string") return r3(t, e); if (ArrayBuffer.isView(t)) return i3(t); if (t == null) throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof t); if (Tr(t, ArrayBuffer) || t && Tr(t.buffer, ArrayBuffer) || typeof SharedArrayBuffer != "undefined" && (Tr(t, SharedArrayBuffer) || t && Tr(t.buffer, SharedArrayBuffer))) return mh(t, e, r); if (typeof t == "number") throw new TypeError('The "value" argument must not be of type number. Received type number'); let i = t.valueOf && t.valueOf(); if (i != null && i !== t) return P.from(i, e, r); let n = n3(t); if (n) return n; if (typeof Symbol != "undefined" && Symbol.toPrimitive != null && typeof t[Symbol.toPrimitive] == "function") return P.from(t[Symbol.toPrimitive]("string"), e, r); throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof t) } P.from = function (t, e, r) { return Jc(t, e, r) }; Object.setPrototypeOf(P.prototype, Uint8Array.prototype); Object.setPrototypeOf(P, Uint8Array); function Qc(t) { if (typeof t != "number") throw new TypeError('"size" argument must be of type number'); if (t < 0) throw new RangeError('The value "' + t + '" is invalid for option "size"') } function t3(t, e, r) { return Qc(t), t <= 0 ? $r(t) : e !== void 0 ? typeof r == "string" ? $r(t).fill(e, r) : $r(t).fill(e) : $r(t) } P.alloc = function (t, e, r) { return t3(t, e, r) }; function bh(t) { return Qc(t), $r(t < 0 ? 0 : gh(t) | 0) } P.allocUnsafe = function (t) { return bh(t) }; P.allocUnsafeSlow = function (t) { return bh(t) }; function r3(t, e) { if ((typeof e != "string" || e === "") && (e = "utf8"), !P.isEncoding(e)) throw new TypeError("Unknown encoding: " + e); let r = ed(t, e) | 0, i = $r(r), n = i.write(t, e); return n !== r && (i = i.slice(0, n)), i } function yh(t) { let e = t.length < 0 ? 0 : gh(t.length) | 0, r = $r(e); for (let i = 0; i < e; i += 1)r[i] = t[i] & 255; return r } function i3(t) { if (Tr(t, Uint8Array)) { let e = new Uint8Array(t); return mh(e.buffer, e.byteOffset, e.byteLength) } return yh(t) } function mh(t, e, r) { if (e < 0 || t.byteLength < e) throw new RangeError('"offset" is outside of buffer bounds'); if (t.byteLength < e + (r || 0)) throw new RangeError('"length" is outside of buffer bounds'); let i; return e === void 0 && r === void 0 ? i = new Uint8Array(t) : r === void 0 ? i = new Uint8Array(t, e) : i = new Uint8Array(t, e, r), Object.setPrototypeOf(i, P.prototype), i } function n3(t) { if (P.isBuffer(t)) { let e = gh(t.length) | 0, r = $r(e); return r.length === 0 || t.copy(r, 0, 0, e), r } if (t.length !== void 0) return typeof t.length != "number" || xh(t.length) ? $r(0) : yh(t); if (t.type === "Buffer" && Array.isArray(t.data)) return yh(t.data) } function gh(t) { if (t >= Yf) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + Yf.toString(16) + " bytes"); return t | 0 } function a3(t) { return +t != t && (t = 0), P.alloc(+t) } P.isBuffer = function (e) { return e != null && e._isBuffer === !0 && e !== P.prototype }; P.compare = function (e, r) { if (Tr(e, Uint8Array) && (e = P.from(e, e.offset, e.byteLength)), Tr(r, Uint8Array) && (r = P.from(r, r.offset, r.byteLength)), !P.isBuffer(e) || !P.isBuffer(r)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'); if (e === r) return 0; let i = e.length, n = r.length; for (let f = 0, h = Math.min(i, n); f < h; ++f)if (e[f] !== r[f]) { i = e[f], n = r[f]; break } return i < n ? -1 : n < i ? 1 : 0 }; P.isEncoding = function (e) { switch (String(e).toLowerCase()) { case "hex": case "utf8": case "utf-8": case "ascii": case "latin1": case "binary": case "base64": case "ucs2": case "ucs-2": case "utf16le": case "utf-16le": return !0; default: return !1 } }; P.concat = function (e, r) { if (!Array.isArray(e)) throw new TypeError('"list" argument must be an Array of Buffers'); if (e.length === 0) return P.alloc(0); let i; if (r === void 0) for (r = 0, i = 0; i < e.length; ++i)r += e[i].length; let n = P.allocUnsafe(r), f = 0; for (i = 0; i < e.length; ++i) { let h = e[i]; if (Tr(h, Uint8Array)) f + h.length > n.length ? (P.isBuffer(h) || (h = P.from(h)), h.copy(n, f)) : Uint8Array.prototype.set.call(n, h, f); else if (P.isBuffer(h)) h.copy(n, f); else throw new TypeError('"list" argument must be an Array of Buffers'); f += h.length } return n }; function ed(t, e) { if (P.isBuffer(t)) return t.length; if (ArrayBuffer.isView(t) || Tr(t, ArrayBuffer)) return t.byteLength; if (typeof t != "string") throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof t); let r = t.length, i = arguments.length > 2 && arguments[2] === !0; if (!i && r === 0) return 0; let n = !1; for (; ;)switch (e) { case "ascii": case "latin1": case "binary": return r; case "utf8": case "utf-8": return _h(t).length; case "ucs2": case "ucs-2": case "utf16le": case "utf-16le": return r * 2; case "hex": return r >>> 1; case "base64": return dd(t).length; default: if (n) return i ? -1 : _h(t).length; e = ("" + e).toLowerCase(), n = !0 } } P.byteLength = ed; function f3(t, e, r) { let i = !1; if ((e === void 0 || e < 0) && (e = 0), e > this.length || ((r === void 0 || r > this.length) && (r = this.length), r <= 0) || (r >>>= 0, e >>>= 0, r <= e)) return ""; for (t || (t = "utf8"); ;)switch (t) { case "hex": return b3(this, e, r); case "utf8": case "utf-8": return id(this, e, r); case "ascii": return p3(this, e, r); case "latin1": case "binary": return v3(this, e, r); case "base64": return d3(this, e, r); case "ucs2": case "ucs-2": case "utf16le": case "utf-16le": return y3(this, e, r); default: if (i) throw new TypeError("Unknown encoding: " + t); t = (t + "").toLowerCase(), i = !0 } } P.prototype._isBuffer = !0; function rn(t, e, r) { let i = t[e]; t[e] = t[r], t[r] = i } P.prototype.swap16 = function () { let e = this.length; if (e % 2 != 0) throw new RangeError("Buffer size must be a multiple of 16-bits"); for (let r = 0; r < e; r += 2)rn(this, r, r + 1); return this }; P.prototype.swap32 = function () { let e = this.length; if (e % 4 != 0) throw new RangeError("Buffer size must be a multiple of 32-bits"); for (let r = 0; r < e; r += 4)rn(this, r, r + 3), rn(this, r + 1, r + 2); return this }; P.prototype.swap64 = function () { let e = this.length; if (e % 8 != 0) throw new RangeError("Buffer size must be a multiple of 64-bits"); for (let r = 0; r < e; r += 8)rn(this, r, r + 7), rn(this, r + 1, r + 6), rn(this, r + 2, r + 5), rn(this, r + 3, r + 4); return this }; P.prototype.toString = function () { let e = this.length; return e === 0 ? "" : arguments.length === 0 ? id(this, 0, e) : f3.apply(this, arguments) }; P.prototype.toLocaleString = P.prototype.toString; P.prototype.equals = function (e) { if (!P.isBuffer(e)) throw new TypeError("Argument must be a Buffer"); return this === e ? !0 : P.compare(this, e) === 0 }; P.prototype.inspect = function () { let e = "", r = $n.INSPECT_MAX_BYTES; return e = this.toString("hex", 0, r).replace(/(.{2})/g, "$1 ").trim(), this.length > r && (e += " ... "), "<Buffer " + e + ">" }; Zc && (P.prototype[Zc] = P.prototype.inspect); P.prototype.compare = function (e, r, i, n, f) { if (Tr(e, Uint8Array) && (e = P.from(e, e.offset, e.byteLength)), !P.isBuffer(e)) throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof e); if (r === void 0 && (r = 0), i === void 0 && (i = e ? e.length : 0), n === void 0 && (n = 0), f === void 0 && (f = this.length), r < 0 || i > e.length || n < 0 || f > this.length) throw new RangeError("out of range index"); if (n >= f && r >= i) return 0; if (n >= f) return -1; if (r >= i) return 1; if (r >>>= 0, i >>>= 0, n >>>= 0, f >>>= 0, this === e) return 0; let h = f - n, c = i - r, y = Math.min(h, c), x = this.slice(n, f), M = e.slice(r, i); for (let E = 0; E < y; ++E)if (x[E] !== M[E]) { h = x[E], c = M[E]; break } return h < c ? -1 : c < h ? 1 : 0 }; function td(t, e, r, i, n) { if (t.length === 0) return -1; if (typeof r == "string" ? (i = r, r = 0) : r > 2147483647 ? r = 2147483647 : r < -2147483648 && (r = -2147483648), r = +r, xh(r) && (r = n ? 0 : t.length - 1), r < 0 && (r = t.length + r), r >= t.length) { if (n) return -1; r = t.length - 1 } else if (r < 0) if (n) r = 0; else return -1; if (typeof e == "string" && (e = P.from(e, i)), P.isBuffer(e)) return e.length === 0 ? -1 : rd(t, e, r, i, n); if (typeof e == "number") return e = e & 255, typeof Uint8Array.prototype.indexOf == "function" ? n ? Uint8Array.prototype.indexOf.call(t, e, r) : Uint8Array.prototype.lastIndexOf.call(t, e, r) : rd(t, [e], r, i, n); throw new TypeError("val must be string, number or Buffer") } function rd(t, e, r, i, n) { let f = 1, h = t.length, c = e.length; if (i !== void 0 && (i = String(i).toLowerCase(), i === "ucs2" || i === "ucs-2" || i === "utf16le" || i === "utf-16le")) { if (t.length < 2 || e.length < 2) return -1; f = 2, h /= 2, c /= 2, r /= 2 } function y(M, E) { return f === 1 ? M[E] : M.readUInt16BE(E * f) } let x; if (n) { let M = -1; for (x = r; x < h; x++)if (y(t, x) === y(e, M === -1 ? 0 : x - M)) { if (M === -1 && (M = x), x - M + 1 === c) return M * f } else M !== -1 && (x -= x - M), M = -1 } else for (r + c > h && (r = h - c), x = r; x >= 0; x--) { let M = !0; for (let E = 0; E < c; E++)if (y(t, x + E) !== y(e, E)) { M = !1; break } if (M) return x } return -1 } P.prototype.includes = function (e, r, i) { return this.indexOf(e, r, i) !== -1 }; P.prototype.indexOf = function (e, r, i) { return td(this, e, r, i, !0) }; P.prototype.lastIndexOf = function (e, r, i) { return td(this, e, r, i, !1) }; function s3(t, e, r, i) { r = Number(r) || 0; let n = t.length - r; i ? (i = Number(i), i > n && (i = n)) : i = n; let f = e.length; i > f / 2 && (i = f / 2); let h; for (h = 0; h < i; ++h) { let c = parseInt(e.substr(h * 2, 2), 16); if (xh(c)) return h; t[r + h] = c } return h } function o3(t, e, r, i) { return Zf(_h(e, t.length - r), t, r, i) } function h3(t, e, r, i) { return Zf(_3(e), t, r, i) } function u3(t, e, r, i) { return Zf(dd(e), t, r, i) } function c3(t, e, r, i) { return Zf(x3(e, t.length - r), t, r, i) } P.prototype.write = function (e, r, i, n) { if (r === void 0) n = "utf8", i = this.length, r = 0; else if (i === void 0 && typeof r == "string") n = r, i = this.length, r = 0; else if (isFinite(r)) r = r >>> 0, isFinite(i) ? (i = i >>> 0, n === void 0 && (n = "utf8")) : (n = i, i = void 0); else throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported"); let f = this.length - r; if ((i === void 0 || i > f) && (i = f), e.length > 0 && (i < 0 || r < 0) || r > this.length) throw new RangeError("Attempt to write outside buffer bounds"); n || (n = "utf8"); let h = !1; for (; ;)switch (n) { case "hex": return s3(this, e, r, i); case "utf8": case "utf-8": return o3(this, e, r, i); case "ascii": case "latin1": case "binary": return h3(this, e, r, i); case "base64": return u3(this, e, r, i); case "ucs2": case "ucs-2": case "utf16le": case "utf-16le": return c3(this, e, r, i); default: if (h) throw new TypeError("Unknown encoding: " + n); n = ("" + n).toLowerCase(), h = !0 } }; P.prototype.toJSON = function () { return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) } }; function d3(t, e, r) { return e === 0 && r === t.length ? vh.fromByteArray(t) : vh.fromByteArray(t.slice(e, r)) } function id(t, e, r) { r = Math.min(t.length, r); let i = [], n = e; for (; n < r;) { let f = t[n], h = null, c = f > 239 ? 4 : f > 223 ? 3 : f > 191 ? 2 : 1; if (n + c <= r) { let y, x, M, E; switch (c) { case 1: f < 128 && (h = f); break; case 2: y = t[n + 1], (y & 192) == 128 && (E = (f & 31) << 6 | y & 63, E > 127 && (h = E)); break; case 3: y = t[n + 1], x = t[n + 2], (y & 192) == 128 && (x & 192) == 128 && (E = (f & 15) << 12 | (y & 63) << 6 | x & 63, E > 2047 && (E < 55296 || E > 57343) && (h = E)); break; case 4: y = t[n + 1], x = t[n + 2], M = t[n + 3], (y & 192) == 128 && (x & 192) == 128 && (M & 192) == 128 && (E = (f & 15) << 18 | (y & 63) << 12 | (x & 63) << 6 | M & 63, E > 65535 && E < 1114112 && (h = E)) } } h === null ? (h = 65533, c = 1) : h > 65535 && (h -= 65536, i.push(h >>> 10 & 1023 | 55296), h = 56320 | h & 1023), i.push(h), n += c } return l3(i) } var nd = 4096; function l3(t) { let e = t.length; if (e <= nd) return String.fromCharCode.apply(String, t); let r = "", i = 0; for (; i < e;)r += String.fromCharCode.apply(String, t.slice(i, i += nd)); return r } function p3(t, e, r) { let i = ""; r = Math.min(t.length, r); for (let n = e; n < r; ++n)i += String.fromCharCode(t[n] & 127); return i } function v3(t, e, r) { let i = ""; r = Math.min(t.length, r); for (let n = e; n < r; ++n)i += String.fromCharCode(t[n]); return i } function b3(t, e, r) { let i = t.length; (!e || e < 0) && (e = 0), (!r || r < 0 || r > i) && (r = i); let n = ""; for (let f = e; f < r; ++f)n += M3[t[f]]; return n } function y3(t, e, r) { let i = t.slice(e, r), n = ""; for (let f = 0; f < i.length - 1; f += 2)n += String.fromCharCode(i[f] + i[f + 1] * 256); return n } P.prototype.slice = function (e, r) { let i = this.length; e = ~~e, r = r === void 0 ? i : ~~r, e < 0 ? (e += i, e < 0 && (e = 0)) : e > i && (e = i), r < 0 ? (r += i, r < 0 && (r = 0)) : r > i && (r = i), r < e && (r = e); let n = this.subarray(e, r); return Object.setPrototypeOf(n, P.prototype), n }; function at(t, e, r) { if (t % 1 != 0 || t < 0) throw new RangeError("offset is not uint"); if (t + e > r) throw new RangeError("Trying to access beyond buffer length") } P.prototype.readUintLE = P.prototype.readUIntLE = function (e, r, i) { e = e >>> 0, r = r >>> 0, i || at(e, r, this.length); let n = this[e], f = 1, h = 0; for (; ++h < r && (f *= 256);)n += this[e + h] * f; return n }; P.prototype.readUintBE = P.prototype.readUIntBE = function (e, r, i) { e = e >>> 0, r = r >>> 0, i || at(e, r, this.length); let n = this[e + --r], f = 1; for (; r > 0 && (f *= 256);)n += this[e + --r] * f; return n }; P.prototype.readUint8 = P.prototype.readUInt8 = function (e, r) { return e = e >>> 0, r || at(e, 1, this.length), this[e] }; P.prototype.readUint16LE = P.prototype.readUInt16LE = function (e, r) { return e = e >>> 0, r || at(e, 2, this.length), this[e] | this[e + 1] << 8 }; P.prototype.readUint16BE = P.prototype.readUInt16BE = function (e, r) { return e = e >>> 0, r || at(e, 2, this.length), this[e] << 8 | this[e + 1] }; P.prototype.readUint32LE = P.prototype.readUInt32LE = function (e, r) { return e = e >>> 0, r || at(e, 4, this.length), (this[e] | this[e + 1] << 8 | this[e + 2] << 16) + this[e + 3] * 16777216 }; P.prototype.readUint32BE = P.prototype.readUInt32BE = function (e, r) { return e = e >>> 0, r || at(e, 4, this.length), this[e] * 16777216 + (this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3]) }; P.prototype.readBigUInt64LE = Pi(function (e) { e = e >>> 0, Gn(e, "offset"); let r = this[e], i = this[e + 7]; (r === void 0 || i === void 0) && ja(e, this.length - 8); let n = r + this[++e] * He(2, 8) + this[++e] * He(2, 16) + this[++e] * He(2, 24), f = this[++e] + this[++e] * He(2, 8) + this[++e] * He(2, 16) + i * He(2, 24); return BigInt(n) + (BigInt(f) << BigInt(32)) }); P.prototype.readBigUInt64BE = Pi(function (e) { e = e >>> 0, Gn(e, "offset"); let r = this[e], i = this[e + 7]; (r === void 0 || i === void 0) && ja(e, this.length - 8); let n = r * He(2, 24) + this[++e] * He(2, 16) + this[++e] * He(2, 8) + this[++e], f = this[++e] * He(2, 24) + this[++e] * He(2, 16) + this[++e] * He(2, 8) + i; return (BigInt(n) << BigInt(32)) + BigInt(f) }); P.prototype.readIntLE = function (e, r, i) { e = e >>> 0, r = r >>> 0, i || at(e, r, this.length); let n = this[e], f = 1, h = 0; for (; ++h < r && (f *= 256);)n += this[e + h] * f; return f *= 128, n >= f && (n -= Math.pow(2, 8 * r)), n }; P.prototype.readIntBE = function (e, r, i) { e = e >>> 0, r = r >>> 0, i || at(e, r, this.length); let n = r, f = 1, h = this[e + --n]; for (; n > 0 && (f *= 256);)h += this[e + --n] * f; return f *= 128, h >= f && (h -= Math.pow(2, 8 * r)), h }; P.prototype.readInt8 = function (e, r) { return e = e >>> 0, r || at(e, 1, this.length), this[e] & 128 ? (255 - this[e] + 1) * -1 : this[e] }; P.prototype.readInt16LE = function (e, r) { e = e >>> 0, r || at(e, 2, this.length); let i = this[e] | this[e + 1] << 8; return i & 32768 ? i | 4294901760 : i }; P.prototype.readInt16BE = function (e, r) { e = e >>> 0, r || at(e, 2, this.length); let i = this[e + 1] | this[e] << 8; return i & 32768 ? i | 4294901760 : i }; P.prototype.readInt32LE = function (e, r) { return e = e >>> 0, r || at(e, 4, this.length), this[e] | this[e + 1] << 8 | this[e + 2] << 16 | this[e + 3] << 24 }; P.prototype.readInt32BE = function (e, r) { return e = e >>> 0, r || at(e, 4, this.length), this[e] << 24 | this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3] }; P.prototype.readBigInt64LE = Pi(function (e) { e = e >>> 0, Gn(e, "offset"); let r = this[e], i = this[e + 7]; (r === void 0 || i === void 0) && ja(e, this.length - 8); let n = this[e + 4] + this[e + 5] * He(2, 8) + this[e + 6] * He(2, 16) + (i << 24); return (BigInt(n) << BigInt(32)) + BigInt(r + this[++e] * He(2, 8) + this[++e] * He(2, 16) + this[++e] * He(2, 24)) }); P.prototype.readBigInt64BE = Pi(function (e) { e = e >>> 0, Gn(e, "offset"); let r = this[e], i = this[e + 7]; (r === void 0 || i === void 0) && ja(e, this.length - 8); let n = (r << 24) + this[++e] * He(2, 16) + this[++e] * He(2, 8) + this[++e]; return (BigInt(n) << BigInt(32)) + BigInt(this[++e] * He(2, 24) + this[++e] * He(2, 16) + this[++e] * He(2, 8) + i) }); P.prototype.readFloatLE = function (e, r) { return e = e >>> 0, r || at(e, 4, this.length), Kn.read(this, e, !0, 23, 4) }; P.prototype.readFloatBE = function (e, r) { return e = e >>> 0, r || at(e, 4, this.length), Kn.read(this, e, !1, 23, 4) }; P.prototype.readDoubleLE = function (e, r) { return e = e >>> 0, r || at(e, 8, this.length), Kn.read(this, e, !0, 52, 8) }; P.prototype.readDoubleBE = function (e, r) { return e = e >>> 0, r || at(e, 8, this.length), Kn.read(this, e, !1, 52, 8) }; function St(t, e, r, i, n, f) { if (!P.isBuffer(t)) throw new TypeError('"buffer" argument must be a Buffer instance'); if (e > n || e < f) throw new RangeError('"value" argument is out of bounds'); if (r + i > t.length) throw new RangeError("Index out of range") } P.prototype.writeUintLE = P.prototype.writeUIntLE = function (e, r, i, n) { if (e = +e, r = r >>> 0, i = i >>> 0, !n) { let c = Math.pow(2, 8 * i) - 1; St(this, e, r, i, c, 0) } let f = 1, h = 0; for (this[r] = e & 255; ++h < i && (f *= 256);)this[r + h] = e / f & 255; return r + i }; P.prototype.writeUintBE = P.prototype.writeUIntBE = function (e, r, i, n) { if (e = +e, r = r >>> 0, i = i >>> 0, !n) { let c = Math.pow(2, 8 * i) - 1; St(this, e, r, i, c, 0) } let f = i - 1, h = 1; for (this[r + f] = e & 255; --f >= 0 && (h *= 256);)this[r + f] = e / h & 255; return r + i }; P.prototype.writeUint8 = P.prototype.writeUInt8 = function (e, r, i) { return e = +e, r = r >>> 0, i || St(this, e, r, 1, 255, 0), this[r] = e & 255, r + 1 }; P.prototype.writeUint16LE = P.prototype.writeUInt16LE = function (e, r, i) { return e = +e, r = r >>> 0, i || St(this, e, r, 2, 65535, 0), this[r] = e & 255, this[r + 1] = e >>> 8, r + 2 }; P.prototype.writeUint16BE = P.prototype.writeUInt16BE = function (e, r, i) { return e = +e, r = r >>> 0, i || St(this, e, r, 2, 65535, 0), this[r] = e >>> 8, this[r + 1] = e & 255, r + 2 }; P.prototype.writeUint32LE = P.prototype.writeUInt32LE = function (e, r, i) { return e = +e, r = r >>> 0, i || St(this, e, r, 4, 4294967295, 0), this[r + 3] = e >>> 24, this[r + 2] = e >>> 16, this[r + 1] = e >>> 8, this[r] = e & 255, r + 4 }; P.prototype.writeUint32BE = P.prototype.writeUInt32BE = function (e, r, i) { return e = +e, r = r >>> 0, i || St(this, e, r, 4, 4294967295, 0), this[r] = e >>> 24, this[r + 1] = e >>> 16, this[r + 2] = e >>> 8, this[r + 3] = e & 255, r + 4 }; function ad(t, e, r, i, n) { cd(e, i, n, t, r, 7); let f = Number(e & BigInt(4294967295)); t[r++] = f, f = f >> 8, t[r++] = f, f = f >> 8, t[r++] = f, f = f >> 8, t[r++] = f; let h = Number(e >> BigInt(32) & BigInt(4294967295)); return t[r++] = h, h = h >> 8, t[r++] = h, h = h >> 8, t[r++] = h, h = h >> 8, t[r++] = h, r } function fd(t, e, r, i, n) { cd(e, i, n, t, r, 7); let f = Number(e & BigInt(4294967295)); t[r + 7] = f, f = f >> 8, t[r + 6] = f, f = f >> 8, t[r + 5] = f, f = f >> 8, t[r + 4] = f; let h = Number(e >> BigInt(32) & BigInt(4294967295)); return t[r + 3] = h, h = h >> 8, t[r + 2] = h, h = h >> 8, t[r + 1] = h, h = h >> 8, t[r] = h, r + 8 } P.prototype.writeBigUInt64LE = Pi(function (e, r = 0) { return ad(this, e, r, BigInt(0), BigInt("0xffffffffffffffff")) }); P.prototype.writeBigUInt64BE = Pi(function (e, r = 0) { return fd(this, e, r, BigInt(0), BigInt("0xffffffffffffffff")) }); P.prototype.writeIntLE = function (e, r, i, n) { if (e = +e, r = r >>> 0, !n) { let y = Math.pow(2, 8 * i - 1); St(this, e, r, i, y - 1, -y) } let f = 0, h = 1, c = 0; for (this[r] = e & 255; ++f < i && (h *= 256);)e < 0 && c === 0 && this[r + f - 1] !== 0 && (c = 1), this[r + f] = (e / h >> 0) - c & 255; return r + i }; P.prototype.writeIntBE = function (e, r, i, n) { if (e = +e, r = r >>> 0, !n) { let y = Math.pow(2, 8 * i - 1); St(this, e, r, i, y - 1, -y) } let f = i - 1, h = 1, c = 0; for (this[r + f] = e & 255; --f >= 0 && (h *= 256);)e < 0 && c === 0 && this[r + f + 1] !== 0 && (c = 1), this[r + f] = (e / h >> 0) - c & 255; return r + i }; P.prototype.writeInt8 = function (e, r, i) { return e = +e, r = r >>> 0, i || St(this, e, r, 1, 127, -128), e < 0 && (e = 255 + e + 1), this[r] = e & 255, r + 1 }; P.prototype.writeInt16LE = function (e, r, i) { return e = +e, r = r >>> 0, i || St(this, e, r, 2, 32767, -32768), this[r] = e & 255, this[r + 1] = e >>> 8, r + 2 }; P.prototype.writeInt16BE = function (e, r, i) { return e = +e, r = r >>> 0, i || St(this, e, r, 2, 32767, -32768), this[r] = e >>> 8, this[r + 1] = e & 255, r + 2 }; P.prototype.writeInt32LE = function (e, r, i) { return e = +e, r = r >>> 0, i || St(this, e, r, 4, 2147483647, -2147483648), this[r] = e & 255, this[r + 1] = e >>> 8, this[r + 2] = e >>> 16, this[r + 3] = e >>> 24, r + 4 }; P.prototype.writeInt32BE = function (e, r, i) { return e = +e, r = r >>> 0, i || St(this, e, r, 4, 2147483647, -2147483648), e < 0 && (e = 4294967295 + e + 1), this[r] = e >>> 24, this[r + 1] = e >>> 16, this[r + 2] = e >>> 8, this[r + 3] = e & 255, r + 4 }; P.prototype.writeBigInt64LE = Pi(function (e, r = 0) { return ad(this, e, r, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff")) }); P.prototype.writeBigInt64BE = Pi(function (e, r = 0) { return fd(this, e, r, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff")) }); function sd(t, e, r, i, n, f) { if (r + i > t.length) throw new RangeError("Index out of range"); if (r < 0) throw new RangeError("Index out of range") } function od(t, e, r, i, n) { return e = +e, r = r >>> 0, n || sd(t, e, r, 4, 34028234663852886e22, -34028234663852886e22), Kn.write(t, e, r, i, 23, 4), r + 4 } P.prototype.writeFloatLE = function (e, r, i) { return od(this, e, r, !0, i) }; P.prototype.writeFloatBE = function (e, r, i) { return od(this, e, r, !1, i) }; function hd(t, e, r, i, n) { return e = +e, r = r >>> 0, n || sd(t, e, r, 8, 17976931348623157e292, -17976931348623157e292), Kn.write(t, e, r, i, 52, 8), r + 8 } P.prototype.writeDoubleLE = function (e, r, i) { return hd(this, e, r, !0, i) }; P.prototype.writeDoubleBE = function (e, r, i) { return hd(this, e, r, !1, i) }; P.prototype.copy = function (e, r, i, n) { if (!P.isBuffer(e)) throw new TypeError("argument should be a Buffer"); if (i || (i = 0), !n && n !== 0 && (n = this.length), r >= e.length && (r = e.length), r || (r = 0), n > 0 && n < i && (n = i), n === i || e.length === 0 || this.length === 0) return 0; if (r < 0) throw new RangeError("targetStart out of bounds"); if (i < 0 || i >= this.length) throw new RangeError("Index out of range"); if (n < 0) throw new RangeError("sourceEnd out of bounds"); n > this.length && (n = this.length), e.length - r < n - i && (n = e.length - r + i); let f = n - i; return this === e && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(r, i, n) : Uint8Array.prototype.set.call(e, this.subarray(i, n), r), f }; P.prototype.fill = function (e, r, i, n) { if (typeof e == "string") { if (typeof r == "string" ? (n = r, r = 0, i = this.length) : typeof i == "string" && (n = i, i = this.length), n !== void 0 && typeof n != "string") throw new TypeError("encoding must be a string"); if (typeof n == "string" && !P.isEncoding(n)) throw new TypeError("Unknown encoding: " + n); if (e.length === 1) { let h = e.charCodeAt(0); (n === "utf8" && h < 128 || n === "latin1") && (e = h) } } else typeof e == "number" ? e = e & 255 : typeof e == "boolean" && (e = Number(e)); if (r < 0 || this.length < r || this.length < i) throw new RangeError("Out of range index"); if (i <= r) return this; r = r >>> 0, i = i === void 0 ? this.length : i >>> 0, e || (e = 0); let f; if (typeof e == "number") for (f = r; f < i; ++f)this[f] = e; else { let h = P.isBuffer(e) ? e : P.from(e, n), c = h.length; if (c === 0) throw new TypeError('The value "' + e + '" is invalid for argument "value"'); for (f = 0; f < i - r; ++f)this[f + r] = h[f % c] } return this }; var Vn = {}; function wh(t, e, r) { Vn[t] = class extends r { constructor() { super(); Object.defineProperty(this, "message", { value: e.apply(this, arguments), writable: !0, configurable: !0 }), this.name = `${this.name} [${t}]`, this.stack, delete this.name } get code() { return t } set code(n) { Object.defineProperty(this, "code", { configurable: !0, enumerable: !0, value: n, writable: !0 }) } toString() { return `${this.name} [${t}]: ${this.message}` } } } wh("ERR_BUFFER_OUT_OF_BOUNDS", function (t) { return t ? `${t} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds" }, RangeError); wh("ERR_INVALID_ARG_TYPE", function (t, e) { return `The "${t}" argument must be of type number. Received type ${typeof e}` }, TypeError); wh("ERR_OUT_OF_RANGE", function (t, e, r) { let i = `The value of "${t}" is out of range.`, n = r; return Number.isInteger(r) && Math.abs(r) > He(2, 32) ? n = ud(String(r)) : typeof r == "bigint" && (n = String(r), (r > He(BigInt(2), BigInt(32)) || r < -He(BigInt(2), BigInt(32))) && (n = ud(n)), n += "n"), i += ` It must be ${e}. Received ${n}`, i }, RangeError); function ud(t) { let e = "", r = t.length, i = t[0] === "-" ? 1 : 0; for (; r >= i + 4; r -= 3)e = `_${t.slice(r - 3, r)}${e}`; return `${t.slice(0, r)}${e}` } function m3(t, e, r) { Gn(e, "offset"), (t[e] === void 0 || t[e + r] === void 0) && ja(e, t.length - (r + 1)) } function cd(t, e, r, i, n, f) { if (t > r || t < e) { let h = typeof e == "bigint" ? "n" : "", c; throw f > 3 ? e === 0 || e === BigInt(0) ? c = `>= 0${h} and < 2${h} ** ${(f + 1) * 8}${h}` : c = `>= -(2${h} ** ${(f + 1) * 8 - 1}${h}) and < 2 ** ${(f + 1) * 8 - 1}${h}` : c = `>= ${e}${h} and <= ${r}${h}`, new Vn.ERR_OUT_OF_RANGE("value", c, t) } m3(i, n, f) } function Gn(t, e) { if (typeof t != "number") throw new Vn.ERR_INVALID_ARG_TYPE(e, "number", t) } function ja(t, e, r) { throw Math.floor(t) !== t ? (Gn(t, r), new Vn.ERR_OUT_OF_RANGE(r || "offset", "an integer", t)) : e < 0 ? new Vn.ERR_BUFFER_OUT_OF_BOUNDS : new Vn.ERR_OUT_OF_RANGE(r || "offset", `>= ${r ? 1 : 0} and <= ${e}`, t) } var g3 = /[^+/0-9A-Za-z-_]/g; function w3(t) { if (t = t.split("=")[0], t = t.trim().replace(g3, ""), t.length < 2) return ""; for (; t.length % 4 != 0;)t = t + "="; return t } function _h(t, e) { e = e || Infinity; let r, i = t.length, n = null, f = []; for (let h = 0; h < i; ++h) { if (r = t.charCodeAt(h), r > 55295 && r < 57344) { if (!n) { if (r > 56319) { (e -= 3) > -1 && f.push(239, 191, 189); continue } else if (h + 1 === i) { (e -= 3) > -1 && f.push(239, 191, 189); continue } n = r; continue } if (r < 56320) { (e -= 3) > -1 && f.push(239, 191, 189), n = r; continue } r = (n - 55296 << 10 | r - 56320) + 65536 } else n && (e -= 3) > -1 && f.push(239, 191, 189); if (n = null, r < 128) { if ((e -= 1) < 0) break; f.push(r) } else if (r < 2048) { if ((e -= 2) < 0) break; f.push(r >> 6 | 192, r & 63 | 128) } else if (r < 65536) { if ((e -= 3) < 0) break; f.push(r >> 12 | 224, r >> 6 & 63 | 128, r & 63 | 128) } else if (r < 1114112) { if ((e -= 4) < 0) break; f.push(r >> 18 | 240, r >> 12 & 63 | 128, r >> 6 & 63 | 128, r & 63 | 128) } else throw new Error("Invalid code point") } return f } function _3(t) { let e = []; for (let r = 0; r < t.length; ++r)e.push(t.charCodeAt(r) & 255); return e } function x3(t, e) { let r, i, n, f = []; for (let h = 0; h < t.length && !((e -= 2) < 0); ++h)r = t.charCodeAt(h), i = r >> 8, n = r % 256, f.push(n), f.push(i); return f } function dd(t) { return vh.toByteArray(w3(t)) } function Zf(t, e, r, i) { let n; for (n = 0; n < i && !(n + r >= e.length || n >= t.length); ++n)e[n + r] = t[n]; return n } function Tr(t, e) { return t instanceof e || t != null && t.constructor != null && t.constructor.name != null && t.constructor.name === e.name } function xh(t) { return t !== t } var M3 = function () { let t = "0123456789abcdef", e = new Array(256); for (let r = 0; r < 16; ++r) { let i = r * 16; for (let n = 0; n < 16; ++n)e[i + n] = t[r] + t[n] } return e }(); function Pi(t) { return typeof BigInt == "undefined" ? S3 : t } function S3() { throw new Error("BigInt not supported") } }); var rt = I((ld, Mh) => { (function (t, e) { "use strict"; function r(S, b) { if (!S) throw new Error(b || "Assertion failed") } function i(S, b) { S.super_ = b; var _ = function () { }; _.prototype = b.prototype, S.prototype = new _, S.prototype.constructor = S } function n(S, b, _) { if (n.isBN(S)) return S; this.negative = 0, this.words = null, this.length = 0, this.red = null, S !== null && ((b === "le" || b === "be") && (_ = b, b = 10), this._init(S || 0, b || 10, _ || "be")) } typeof t == "object" ? t.exports = n : e.BN = n, n.BN = n, n.wordSize = 26; var f; try { typeof window != "undefined" && typeof window.Buffer != "undefined" ? f = window.Buffer : f = ct().Buffer } catch (S) { } n.isBN = function (b) { return b instanceof n ? !0 : b !== null && typeof b == "object" && b.constructor.wordSize === n.wordSize && Array.isArray(b.words) }, n.max = function (b, _) { return b.cmp(_) > 0 ? b : _ }, n.min = function (b, _) { return b.cmp(_) < 0 ? b : _ }, n.prototype._init = function (b, _, l) { if (typeof b == "number") return this._initNumber(b, _, l); if (typeof b == "object") return this._initArray(b, _, l); _ === "hex" && (_ = 16), r(_ === (_ | 0) && _ >= 2 && _ <= 36), b = b.toString().replace(/\s+/g, ""); var a = 0; b[0] === "-" && (a++, this.negative = 1), a < b.length && (_ === 16 ? this._parseHex(b, a, l) : (this._parseBase(b, _, a), l === "le" && this._initArray(this.toArray(), _, l))) }, n.prototype._initNumber = function (b, _, l) { b < 0 && (this.negative = 1, b = -b), b < 67108864 ? (this.words = [b & 67108863], this.length = 1) : b < 4503599627370496 ? (this.words = [b & 67108863, b / 67108864 & 67108863], this.length = 2) : (r(b < 9007199254740992), this.words = [b & 67108863, b / 67108864 & 67108863, 1], this.length = 3), l === "le" && this._initArray(this.toArray(), _, l) }, n.prototype._initArray = function (b, _, l) { if (r(typeof b.length == "number"), b.length <= 0) return this.words = [0], this.length = 1, this; this.length = Math.ceil(b.length / 3), this.words = new Array(this.length); for (var a = 0; a < this.length; a++)this.words[a] = 0; var s, d, v = 0; if (l === "be") for (a = b.length - 1, s = 0; a >= 0; a -= 3)d = b[a] | b[a - 1] << 8 | b[a - 2] << 16, this.words[s] |= d << v & 67108863, this.words[s + 1] = d >>> 26 - v & 67108863, v += 24, v >= 26 && (v -= 26, s++); else if (l === "le") for (a = 0, s = 0; a < b.length; a += 3)d = b[a] | b[a + 1] << 8 | b[a + 2] << 16, this.words[s] |= d << v & 67108863, this.words[s + 1] = d >>> 26 - v & 67108863, v += 24, v >= 26 && (v -= 26, s++); return this.strip() }; function h(S, b) { var _ = S.charCodeAt(b); return _ >= 65 && _ <= 70 ? _ - 55 : _ >= 97 && _ <= 102 ? _ - 87 : _ - 48 & 15 } function c(S, b, _) { var l = h(S, _); return _ - 1 >= b && (l |= h(S, _ - 1) << 4), l } n.prototype._parseHex = function (b, _, l) { this.length = Math.ceil((b.length - _) / 6), this.words = new Array(this.length); for (var a = 0; a < this.length; a++)this.words[a] = 0; var s = 0, d = 0, v; if (l === "be") for (a = b.length - 1; a >= _; a -= 2)v = c(b, _, a) << s, this.words[d] |= v & 67108863, s >= 18 ? (s -= 18, d += 1, this.words[d] |= v >>> 26) : s += 8; else { var p = b.length - _; for (a = p % 2 == 0 ? _ + 1 : _; a < b.length; a += 2)v = c(b, _, a) << s, this.words[d] |= v & 67108863, s >= 18 ? (s -= 18, d += 1, this.words[d] |= v >>> 26) : s += 8 } this.strip() }; function y(S, b, _, l) { for (var a = 0, s = Math.min(S.length, _), d = b; d < s; d++) { var v = S.charCodeAt(d) - 48; a *= l, v >= 49 ? a += v - 49 + 10 : v >= 17 ? a += v - 17 + 10 : a += v } return a } n.prototype._parseBase = function (b, _, l) { this.words = [0], this.length = 1; for (var a = 0, s = 1; s <= 67108863; s *= _)a++; a--, s = s / _ | 0; for (var d = b.length - l, v = d % a, p = Math.min(d, d - v) + l, u = 0, m = l; m < p; m += a)u = y(b, m, m + a, _), this.imuln(s), this.words[0] + u < 67108864 ? this.words[0] += u : this._iaddn(u); if (v !== 0) { var g = 1; for (u = y(b, m, b.length, _), m = 0; m < v; m++)g *= _; this.imuln(g), this.words[0] + u < 67108864 ? this.words[0] += u : this._iaddn(u) } this.strip() }, n.prototype.copy = function (b) { b.words = new Array(this.length); for (var _ = 0; _ < this.length; _++)b.words[_] = this.words[_]; b.length = this.length, b.negative = this.negative, b.red = this.red }, n.prototype.clone = function () { var b = new n(null); return this.copy(b), b }, n.prototype._expand = function (b) { for (; this.length < b;)this.words[this.length++] = 0; return this }, n.prototype.strip = function () { for (; this.length > 1 && this.words[this.length - 1] === 0;)this.length--; return this._normSign() }, n.prototype._normSign = function () { return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this }, n.prototype.inspect = function () { return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">" }; var x = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], M = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], E = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176]; n.prototype.toString = function (b, _) { b = b || 10, _ = _ | 0 || 1; var l; if (b === 16 || b === "hex") { l = ""; for (var a = 0, s = 0, d = 0; d < this.length; d++) { var v = this.words[d], p = ((v << a | s) & 16777215).toString(16); s = v >>> 24 - a & 16777215, s !== 0 || d !== this.length - 1 ? l = x[6 - p.length] + p + l : l = p + l, a += 2, a >= 26 && (a -= 26, d--) } for (s !== 0 && (l = s.toString(16) + l); l.length % _ != 0;)l = "0" + l; return this.negative !== 0 && (l = "-" + l), l } if (b === (b | 0) && b >= 2 && b <= 36) { var u = M[b], m = E[b]; l = ""; var g = this.clone(); for (g.negative = 0; !g.isZero();) { var o = g.modn(m).toString(b); g = g.idivn(m), g.isZero() ? l = o + l : l = x[u - o.length] + o + l } for (this.isZero() && (l = "0" + l); l.length % _ != 0;)l = "0" + l; return this.negative !== 0 && (l = "-" + l), l } r(!1, "Base should be between 2 and 36") }, n.prototype.toNumber = function () { var b = this.words[0]; return this.length === 2 ? b += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? b += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && r(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -b : b }, n.prototype.toJSON = function () { return this.toString(16) }, n.prototype.toBuffer = function (b, _) { return r(typeof f != "undefined"), this.toArrayLike(f, b, _) }, n.prototype.toArray = function (b, _) { return this.toArrayLike(Array, b, _) }, n.prototype.toArrayLike = function (b, _, l) { var a = this.byteLength(), s = l || Math.max(1, a); r(a <= s, "byte array longer than desired length"), r(s > 0, "Requested array length <= 0"), this.strip(); var d = _ === "le", v = new b(s), p, u, m = this.clone(); if (d) { for (u = 0; !m.isZero(); u++)p = m.andln(255), m.iushrn(8), v[u] = p; for (; u < s; u++)v[u] = 0 } else { for (u = 0; u < s - a; u++)v[u] = 0; for (u = 0; !m.isZero(); u++)p = m.andln(255), m.iushrn(8), v[s - u - 1] = p } return v }, Math.clz32 ? n.prototype._countBits = function (b) { return 32 - Math.clz32(b) } : n.prototype._countBits = function (b) { var _ = b, l = 0; return _ >= 4096 && (l += 13, _ >>>= 13), _ >= 64 && (l += 7, _ >>>= 7), _ >= 8 && (l += 4, _ >>>= 4), _ >= 2 && (l += 2, _ >>>= 2), l + _ }, n.prototype._zeroBits = function (b) { if (b === 0) return 26; var _ = b, l = 0; return (_ & 8191) == 0 && (l += 13, _ >>>= 13), (_ & 127) == 0 && (l += 7, _ >>>= 7), (_ & 15) == 0 && (l += 4, _ >>>= 4), (_ & 3) == 0 && (l += 2, _ >>>= 2), (_ & 1) == 0 && l++, l }, n.prototype.bitLength = function () { var b = this.words[this.length - 1], _ = this._countBits(b); return (this.length - 1) * 26 + _ }; function A(S) { for (var b = new Array(S.bitLength()), _ = 0; _ < b.length; _++) { var l = _ / 26 | 0, a = _ % 26; b[_] = (S.words[l] & 1 << a) >>> a } return b } n.prototype.zeroBits = function () { if (this.isZero()) return 0; for (var b = 0, _ = 0; _ < this.length; _++) { var l = this._zeroBits(this.words[_]); if (b += l, l !== 26) break } return b }, n.prototype.byteLength = function () { return Math.ceil(this.bitLength() / 8) }, n.prototype.toTwos = function (b) { return this.negative !== 0 ? this.abs().inotn(b).iaddn(1) : this.clone() }, n.prototype.fromTwos = function (b) { return this.testn(b - 1) ? this.notn(b).iaddn(1).ineg() : this.clone() }, n.prototype.isNeg = function () { return this.negative !== 0 }, n.prototype.neg = function () { return this.clone().ineg() }, n.prototype.ineg = function () { return this.isZero() || (this.negative ^= 1), this }, n.prototype.iuor = function (b) { for (; this.length < b.length;)this.words[this.length++] = 0; for (var _ = 0; _ < b.length; _++)this.words[_] = this.words[_] | b.words[_]; return this.strip() }, n.prototype.ior = function (b) { return r((this.negative | b.negative) == 0), this.iuor(b) }, n.prototype.or = function (b) { return this.length > b.length ? this.clone().ior(b) : b.clone().ior(this) }, n.prototype.uor = function (b) { return this.length > b.length ? this.clone().iuor(b) : b.clone().iuor(this) }, n.prototype.iuand = function (b) { var _; this.length > b.length ? _ = b : _ = this; for (var l = 0; l < _.length; l++)this.words[l] = this.words[l] & b.words[l]; return this.length = _.length, this.strip() }, n.prototype.iand = function (b) { return r((this.negative | b.negative) == 0), this.iuand(b) }, n.prototype.and = function (b) { return this.length > b.length ? this.clone().iand(b) : b.clone().iand(this) }, n.prototype.uand = function (b) { return this.length > b.length ? this.clone().iuand(b) : b.clone().iuand(this) }, n.prototype.iuxor = function (b) { var _, l; this.length > b.length ? (_ = this, l = b) : (_ = b, l = this); for (var a = 0; a < l.length; a++)this.words[a] = _.words[a] ^ l.words[a]; if (this !== _) for (; a < _.length; a++)this.words[a] = _.words[a]; return this.length = _.length, this.strip() }, n.prototype.ixor = function (b) { return r((this.negative | b.negative) == 0), this.iuxor(b) }, n.prototype.xor = function (b) { return this.length > b.length ? this.clone().ixor(b) : b.clone().ixor(this) }, n.prototype.uxor = function (b) { return this.length > b.length ? this.clone().iuxor(b) : b.clone().iuxor(this) }, n.prototype.inotn = function (b) { r(typeof b == "number" && b >= 0); var _ = Math.ceil(b / 26) | 0, l = b % 26; this._expand(_), l > 0 && _--; for (var a = 0; a < _; a++)this.words[a] = ~this.words[a] & 67108863; return l > 0 && (this.words[a] = ~this.words[a] & 67108863 >> 26 - l), this.strip() }, n.prototype.notn = function (b) { return this.clone().inotn(b) }, n.prototype.setn = function (b, _) { r(typeof b == "number" && b >= 0); var l = b / 26 | 0, a = b % 26; return this._expand(l + 1), _ ? this.words[l] = this.words[l] | 1 << a : this.words[l] = this.words[l] & ~(1 << a), this.strip() }, n.prototype.iadd = function (b) { var _; if (this.negative !== 0 && b.negative === 0) return this.negative = 0, _ = this.isub(b), this.negative ^= 1, this._normSign(); if (this.negative === 0 && b.negative !== 0) return b.negative = 0, _ = this.isub(b), b.negative = 1, _._normSign(); var l, a; this.length > b.length ? (l = this, a = b) : (l = b, a = this); for (var s = 0, d = 0; d < a.length; d++)_ = (l.words[d] | 0) + (a.words[d] | 0) + s, this.words[d] = _ & 67108863, s = _ >>> 26; for (; s !== 0 && d < l.length; d++)_ = (l.words[d] | 0) + s, this.words[d] = _ & 67108863, s = _ >>> 26; if (this.length = l.length, s !== 0) this.words[this.length] = s, this.length++; else if (l !== this) for (; d < l.length; d++)this.words[d] = l.words[d]; return this }, n.prototype.add = function (b) { var _; return b.negative !== 0 && this.negative === 0 ? (b.negative = 0, _ = this.sub(b), b.negative ^= 1, _) : b.negative === 0 && this.negative !== 0 ? (this.negative = 0, _ = b.sub(this), this.negative = 1, _) : this.length > b.length ? this.clone().iadd(b) : b.clone().iadd(this) }, n.prototype.isub = function (b) { if (b.negative !== 0) { b.negative = 0; var _ = this.iadd(b); return b.negative = 1, _._normSign() } else if (this.negative !== 0) return this.negative = 0, this.iadd(b), this.negative = 1, this._normSign(); var l = this.cmp(b); if (l === 0) return this.negative = 0, this.length = 1, this.words[0] = 0, this; var a, s; l > 0 ? (a = this, s = b) : (a = b, s = this); for (var d = 0, v = 0; v < s.length; v++)_ = (a.words[v] | 0) - (s.words[v] | 0) + d, d = _ >> 26, this.words[v] = _ & 67108863; for (; d !== 0 && v < a.length; v++)_ = (a.words[v] | 0) + d, d = _ >> 26, this.words[v] = _ & 67108863; if (d === 0 && v < a.length && a !== this) for (; v < a.length; v++)this.words[v] = a.words[v]; return this.length = Math.max(this.length, v), a !== this && (this.negative = 1), this.strip() }, n.prototype.sub = function (b) { return this.clone().isub(b) }; function B(S, b, _) { _.negative = b.negative ^ S.negative; var l = S.length + b.length | 0; _.length = l, l = l - 1 | 0; var a = S.words[0] | 0, s = b.words[0] | 0, d = a * s, v = d & 67108863, p = d / 67108864 | 0; _.words[0] = v; for (var u = 1; u < l; u++) { for (var m = p >>> 26, g = p & 67108863, o = Math.min(u, b.length - 1), w = Math.max(0, u - S.length + 1); w <= o; w++) { var R = u - w | 0; a = S.words[R] | 0, s = b.words[w] | 0, d = a * s + g, m += d / 67108864 | 0, g = d & 67108863 } _.words[u] = g | 0, p = m | 0 } return p !== 0 ? _.words[u] = p | 0 : _.length--, _.strip() } var T = function (b, _, l) { var a = b.words, s = _.words, d = l.words, v = 0, p, u, m, g = a[0] | 0, o = g & 8191, w = g >>> 13, R = a[1] | 0, k = R & 8191, q = R >>> 13, O = a[2] | 0, D = O & 8191, U = O >>> 13, Qe = a[3] | 0, N = Qe & 8191, L = Qe >>> 13, vi = a[4] | 0, j = vi & 8191, z = vi >>> 13, bi = a[5] | 0, W = bi & 8191, K = bi >>> 13, yi = a[6] | 0, V = yi & 8191, G = yi >>> 13, mi = a[7] | 0, $ = mi & 8191, X = mi >>> 13, gi = a[8] | 0, Y = gi & 8191, Z = gi >>> 13, wi = a[9] | 0, J = wi & 8191, Q = wi >>> 13, _i = s[0] | 0, ee = _i & 8191, te = _i >>> 13, xi = s[1] | 0, re = xi & 8191, ie = xi >>> 13, Mi = s[2] | 0, ne = Mi & 8191, ae = Mi >>> 13, Si = s[3] | 0, fe = Si & 8191, se = Si >>> 13, Ei = s[4] | 0, oe = Ei & 8191, he = Ei >>> 13, Ai = s[5] | 0, ue = Ai & 8191, ce = Ai >>> 13, Bi = s[6] | 0, de = Bi & 8191, le = Bi >>> 13, Ii = s[7] | 0, pe = Ii & 8191, ve = Ii >>> 13, Ri = s[8] | 0, be = Ri & 8191, ye = Ri >>> 13, Ti = s[9] | 0, me = Ti & 8191, ge = Ti >>> 13; l.negative = b.negative ^ _.negative, l.length = 19, p = Math.imul(o, ee), u = Math.imul(o, te), u = u + Math.imul(w, ee) | 0, m = Math.imul(w, te); var Vr = (v + p | 0) + ((u & 8191) << 13) | 0; v = (m + (u >>> 13) | 0) + (Vr >>> 26) | 0, Vr &= 67108863, p = Math.imul(k, ee), u = Math.imul(k, te), u = u + Math.imul(q, ee) | 0, m = Math.imul(q, te), p = p + Math.imul(o, re) | 0, u = u + Math.imul(o, ie) | 0, u = u + Math.imul(w, re) | 0, m = m + Math.imul(w, ie) | 0; var Se = (v + p | 0) + ((u & 8191) << 13) | 0; v = (m + (u >>> 13) | 0) + (Se >>> 26) | 0, Se &= 67108863, p = Math.imul(D, ee), u = Math.imul(D, te), u = u + Math.imul(U, ee) | 0, m = Math.imul(U, te), p = p + Math.imul(k, re) | 0, u = u + Math.imul(k, ie) | 0, u = u + Math.imul(q, re) | 0, m = m + Math.imul(q, ie) | 0, p = p + Math.imul(o, ne) | 0, u = u + Math.imul(o, ae) | 0, u = u + Math.imul(w, ne) | 0, m = m + Math.imul(w, ae) | 0; var Ee = (v + p | 0) + ((u & 8191) << 13) | 0; v = (m + (u >>> 13) | 0) + (Ee >>> 26) | 0, Ee &= 67108863, p = Math.imul(N, ee), u = Math.imul(N, te), u = u + Math.imul(L, ee) | 0, m = Math.imul(L, te), p = p + Math.imul(D, re) | 0, u = u + Math.imul(D, ie) | 0, u = u + Math.imul(U, re) | 0, m = m + Math.imul(U, ie) | 0, p = p + Math.imul(k, ne) | 0, u = u + Math.imul(k, ae) | 0, u = u + Math.imul(q, ne) | 0, m = m + Math.imul(q, ae) | 0, p = p + Math.imul(o, fe) | 0, u = u + Math.imul(o, se) | 0, u = u + Math.imul(w, fe) | 0, m = m + Math.imul(w, se) | 0; var Qt = (v + p | 0) + ((u & 8191) << 13) | 0; v = (m + (u >>> 13) | 0) + (Qt >>> 26) | 0, Qt &= 67108863, p = Math.imul(j, ee), u = Math.imul(j, te), u = u + Math.imul(z, ee) | 0, m = Math.imul(z, te), p = p + Math.imul(N, re) | 0, u = u + Math.imul(N, ie) | 0, u = u + Math.imul(L, re) | 0, m = m + Math.imul(L, ie) | 0, p = p + Math.imul(D, ne) | 0, u = u + Math.imul(D, ae) | 0, u = u + Math.imul(U, ne) | 0, m = m + Math.imul(U, ae) | 0, p = p + Math.imul(k, fe) | 0, u = u + Math.imul(k, se) | 0, u = u + Math.imul(q, fe) | 0, m = m + Math.imul(q, se) | 0, p = p + Math.imul(o, oe) | 0, u = u + Math.imul(o, he) | 0, u = u + Math.imul(w, oe) | 0, m = m + Math.imul(w, he) | 0; var er = (v + p | 0) + ((u & 8191) << 13) | 0; v = (m + (u >>> 13) | 0) + (er >>> 26) | 0, er &= 67108863, p = Math.imul(W, ee), u = Math.imul(W, te), u = u + Math.imul(K, ee) | 0, m = Math.imul(K, te), p = p + Math.imul(j, re) | 0, u = u + Math.imul(j, ie) | 0, u = u + Math.imul(z, re) | 0, m = m + Math.imul(z, ie) | 0, p = p + Math.imul(N, ne) | 0, u = u + Math.imul(N, ae) | 0, u = u + Math.imul(L, ne) | 0, m = m + Math.imul(L, ae) | 0, p = p + Math.imul(D, fe) | 0, u = u + Math.imul(D, se) | 0, u = u + Math.imul(U, fe) | 0, m = m + Math.imul(U, se) | 0, p = p + Math.imul(k, oe) | 0, u = u + Math.imul(k, he) | 0, u = u + Math.imul(q, oe) | 0, m = m + Math.imul(q, he) | 0, p = p + Math.imul(o, ue) | 0, u = u + Math.imul(o, ce) | 0, u = u + Math.imul(w, ue) | 0, m = m + Math.imul(w, ce) | 0; var tr = (v + p | 0) + ((u & 8191) << 13) | 0; v = (m + (u >>> 13) | 0) + (tr >>> 26) | 0, tr &= 67108863, p = Math.imul(V, ee), u = Math.imul(V, te), u = u + Math.imul(G, ee) | 0, m = Math.imul(G, te), p = p + Math.imul(W, re) | 0, u = u + Math.imul(W, ie) | 0, u = u + Math.imul(K, re) | 0, m = m + Math.imul(K, ie) | 0, p = p + Math.imul(j, ne) | 0, u = u + Math.imul(j, ae) | 0, u = u + Math.imul(z, ne) | 0, m = m + Math.imul(z, ae) | 0, p = p + Math.imul(N, fe) | 0, u = u + Math.imul(N, se) | 0, u = u + Math.imul(L, fe) | 0, m = m + Math.imul(L, se) | 0, p = p + Math.imul(D, oe) | 0, u = u + Math.imul(D, he) | 0, u = u + Math.imul(U, oe) | 0, m = m + Math.imul(U, he) | 0, p = p + Math.imul(k, ue) | 0, u = u + Math.imul(k, ce) | 0, u = u + Math.imul(q, ue) | 0, m = m + Math.imul(q, ce) | 0, p = p + Math.imul(o, de) | 0, u = u + Math.imul(o, le) | 0, u = u + Math.imul(w, de) | 0, m = m + Math.imul(w, le) | 0; var rr = (v + p | 0) + ((u & 8191) << 13) | 0; v = (m + (u >>> 13) | 0) + (rr >>> 26) | 0, rr &= 67108863, p = Math.imul($, ee), u = Math.imul($, te), u = u + Math.imul(X, ee) | 0, m = Math.imul(X, te), p = p + Math.imul(V, re) | 0, u = u + Math.imul(V, ie) | 0, u = u + Math.imul(G, re) | 0, m = m + Math.imul(G, ie) | 0, p = p + Math.imul(W, ne) | 0, u = u + Math.imul(W, ae) | 0, u = u + Math.imul(K, ne) | 0, m = m + Math.imul(K, ae) | 0, p = p + Math.imul(j, fe) | 0, u = u + Math.imul(j, se) | 0, u = u + Math.imul(z, fe) | 0, m = m + Math.imul(z, se) | 0, p = p + Math.imul(N, oe) | 0, u = u + Math.imul(N, he) | 0, u = u + Math.imul(L, oe) | 0, m = m + Math.imul(L, he) | 0, p = p + Math.imul(D, ue) | 0, u = u + Math.imul(D, ce) | 0, u = u + Math.imul(U, ue) | 0, m = m + Math.imul(U, ce) | 0, p = p + Math.imul(k, de) | 0, u = u + Math.imul(k, le) | 0, u = u + Math.imul(q, de) | 0, m = m + Math.imul(q, le) | 0, p = p + Math.imul(o, pe) | 0, u = u + Math.imul(o, ve) | 0, u = u + Math.imul(w, pe) | 0, m = m + Math.imul(w, ve) | 0; var ir = (v + p | 0) + ((u & 8191) << 13) | 0; v = (m + (u >>> 13) | 0) + (ir >>> 26) | 0, ir &= 67108863, p = Math.imul(Y, ee), u = Math.imul(Y, te), u = u + Math.imul(Z, ee) | 0, m = Math.imul(Z, te), p = p + Math.imul($, re) | 0, u = u + Math.imul($, ie) | 0, u = u + Math.imul(X, re) | 0, m = m + Math.imul(X, ie) | 0, p = p + Math.imul(V, ne) | 0, u = u + Math.imul(V, ae) | 0, u = u + Math.imul(G, ne) | 0, m = m + Math.imul(G, ae) | 0, p = p + Math.imul(W, fe) | 0, u = u + Math.imul(W, se) | 0, u = u + Math.imul(K, fe) | 0, m = m + Math.imul(K, se) | 0, p = p + Math.imul(j, oe) | 0, u = u + Math.imul(j, he) | 0, u = u + Math.imul(z, oe) | 0, m = m + Math.imul(z, he) | 0, p = p + Math.imul(N, ue) | 0, u = u + Math.imul(N, ce) | 0, u = u + Math.imul(L, ue) | 0, m = m + Math.imul(L, ce) | 0, p = p + Math.imul(D, de) | 0, u = u + Math.imul(D, le) | 0, u = u + Math.imul(U, de) | 0, m = m + Math.imul(U, le) | 0, p = p + Math.imul(k, pe) | 0, u = u + Math.imul(k, ve) | 0, u = u + Math.imul(q, pe) | 0, m = m + Math.imul(q, ve) | 0, p = p + Math.imul(o, be) | 0, u = u + Math.imul(o, ye) | 0, u = u + Math.imul(w, be) | 0, m = m + Math.imul(w, ye) | 0; var nr = (v + p | 0) + ((u & 8191) << 13) | 0; v = (m + (u >>> 13) | 0) + (nr >>> 26) | 0, nr &= 67108863, p = Math.imul(J, ee), u = Math.imul(J, te), u = u + Math.imul(Q, ee) | 0, m = Math.imul(Q, te), p = p + Math.imul(Y, re) | 0, u = u + Math.imul(Y, ie) | 0, u = u + Math.imul(Z, re) | 0, m = m + Math.imul(Z, ie) | 0, p = p + Math.imul($, ne) | 0, u = u + Math.imul($, ae) | 0, u = u + Math.imul(X, ne) | 0, m = m + Math.imul(X, ae) | 0, p = p + Math.imul(V, fe) | 0, u = u + Math.imul(V, se) | 0, u = u + Math.imul(G, fe) | 0, m = m + Math.imul(G, se) | 0, p = p + Math.imul(W, oe) | 0, u = u + Math.imul(W, he) | 0, u = u + Math.imul(K, oe) | 0, m = m + Math.imul(K, he) | 0, p = p + Math.imul(j, ue) | 0, u = u + Math.imul(j, ce) | 0, u = u + Math.imul(z, ue) | 0, m = m + Math.imul(z, ce) | 0, p = p + Math.imul(N, de) | 0, u = u + Math.imul(N, le) | 0, u = u + Math.imul(L, de) | 0, m = m + Math.imul(L, le) | 0, p = p + Math.imul(D, pe) | 0, u = u + Math.imul(D, ve) | 0, u = u + Math.imul(U, pe) | 0, m = m + Math.imul(U, ve) | 0, p = p + Math.imul(k, be) | 0, u = u + Math.imul(k, ye) | 0, u = u + Math.imul(q, be) | 0, m = m + Math.imul(q, ye) | 0, p = p + Math.imul(o, me) | 0, u = u + Math.imul(o, ge) | 0, u = u + Math.imul(w, me) | 0, m = m + Math.imul(w, ge) | 0; var ar = (v + p | 0) + ((u & 8191) << 13) | 0; v = (m + (u >>> 13) | 0) + (ar >>> 26) | 0, ar &= 67108863, p = Math.imul(J, re), u = Math.imul(J, ie), u = u + Math.imul(Q, re) | 0, m = Math.imul(Q, ie), p = p + Math.imul(Y, ne) | 0, u = u + Math.imul(Y, ae) | 0, u = u + Math.imul(Z, ne) | 0, m = m + Math.imul(Z, ae) | 0, p = p + Math.imul($, fe) | 0, u = u + Math.imul($, se) | 0, u = u + Math.imul(X, fe) | 0, m = m + Math.imul(X, se) | 0, p = p + Math.imul(V, oe) | 0, u = u + Math.imul(V, he) | 0, u = u + Math.imul(G, oe) | 0, m = m + Math.imul(G, he) | 0, p = p + Math.imul(W, ue) | 0, u = u + Math.imul(W, ce) | 0, u = u + Math.imul(K, ue) | 0, m = m + Math.imul(K, ce) | 0, p = p + Math.imul(j, de) | 0, u = u + Math.imul(j, le) | 0, u = u + Math.imul(z, de) | 0, m = m + Math.imul(z, le) | 0, p = p + Math.imul(N, pe) | 0, u = u + Math.imul(N, ve) | 0, u = u + Math.imul(L, pe) | 0, m = m + Math.imul(L, ve) | 0, p = p + Math.imul(D, be) | 0, u = u + Math.imul(D, ye) | 0, u = u + Math.imul(U, be) | 0, m = m + Math.imul(U, ye) | 0, p = p + Math.imul(k, me) | 0, u = u + Math.imul(k, ge) | 0, u = u + Math.imul(q, me) | 0, m = m + Math.imul(q, ge) | 0; var fr = (v + p | 0) + ((u & 8191) << 13) | 0; v = (m + (u >>> 13) | 0) + (fr >>> 26) | 0, fr &= 67108863, p = Math.imul(J, ne), u = Math.imul(J, ae), u = u + Math.imul(Q, ne) | 0, m = Math.imul(Q, ae), p = p + Math.imul(Y, fe) | 0, u = u + Math.imul(Y, se) | 0, u = u + Math.imul(Z, fe) | 0, m = m + Math.imul(Z, se) | 0, p = p + Math.imul($, oe) | 0, u = u + Math.imul($, he) | 0, u = u + Math.imul(X, oe) | 0, m = m + Math.imul(X, he) | 0, p = p + Math.imul(V, ue) | 0, u = u + Math.imul(V, ce) | 0, u = u + Math.imul(G, ue) | 0, m = m + Math.imul(G, ce) | 0, p = p + Math.imul(W, de) | 0, u = u + Math.imul(W, le) | 0, u = u + Math.imul(K, de) | 0, m = m + Math.imul(K, le) | 0, p = p + Math.imul(j, pe) | 0, u = u + Math.imul(j, ve) | 0, u = u + Math.imul(z, pe) | 0, m = m + Math.imul(z, ve) | 0, p = p + Math.imul(N, be) | 0, u = u + Math.imul(N, ye) | 0, u = u + Math.imul(L, be) | 0, m = m + Math.imul(L, ye) | 0, p = p + Math.imul(D, me) | 0, u = u + Math.imul(D, ge) | 0, u = u + Math.imul(U, me) | 0, m = m + Math.imul(U, ge) | 0; var sr = (v + p | 0) + ((u & 8191) << 13) | 0; v = (m + (u >>> 13) | 0) + (sr >>> 26) | 0, sr &= 67108863, p = Math.imul(J, fe), u = Math.imul(J, se), u = u + Math.imul(Q, fe) | 0, m = Math.imul(Q, se), p = p + Math.imul(Y, oe) | 0, u = u + Math.imul(Y, he) | 0, u = u + Math.imul(Z, oe) | 0, m = m + Math.imul(Z, he) | 0, p = p + Math.imul($, ue) | 0, u = u + Math.imul($, ce) | 0, u = u + Math.imul(X, ue) | 0, m = m + Math.imul(X, ce) | 0, p = p + Math.imul(V, de) | 0, u = u + Math.imul(V, le) | 0, u = u + Math.imul(G, de) | 0, m = m + Math.imul(G, le) | 0, p = p + Math.imul(W, pe) | 0, u = u + Math.imul(W, ve) | 0, u = u + Math.imul(K, pe) | 0, m = m + Math.imul(K, ve) | 0, p = p + Math.imul(j, be) | 0, u = u + Math.imul(j, ye) | 0, u = u + Math.imul(z, be) | 0, m = m + Math.imul(z, ye) | 0, p = p + Math.imul(N, me) | 0, u = u + Math.imul(N, ge) | 0, u = u + Math.imul(L, me) | 0, m = m + Math.imul(L, ge) | 0; var or = (v + p | 0) + ((u & 8191) << 13) | 0; v = (m + (u >>> 13) | 0) + (or >>> 26) | 0, or &= 67108863, p = Math.imul(J, oe), u = Math.imul(J, he), u = u + Math.imul(Q, oe) | 0, m = Math.imul(Q, he), p = p + Math.imul(Y, ue) | 0, u = u + Math.imul(Y, ce) | 0, u = u + Math.imul(Z, ue) | 0, m = m + Math.imul(Z, ce) | 0, p = p + Math.imul($, de) | 0, u = u + Math.imul($, le) | 0, u = u + Math.imul(X, de) | 0, m = m + Math.imul(X, le) | 0, p = p + Math.imul(V, pe) | 0, u = u + Math.imul(V, ve) | 0, u = u + Math.imul(G, pe) | 0, m = m + Math.imul(G, ve) | 0, p = p + Math.imul(W, be) | 0, u = u + Math.imul(W, ye) | 0, u = u + Math.imul(K, be) | 0, m = m + Math.imul(K, ye) | 0, p = p + Math.imul(j, me) | 0, u = u + Math.imul(j, ge) | 0, u = u + Math.imul(z, me) | 0, m = m + Math.imul(z, ge) | 0; var hr = (v + p | 0) + ((u & 8191) << 13) | 0; v = (m + (u >>> 13) | 0) + (hr >>> 26) | 0, hr &= 67108863, p = Math.imul(J, ue), u = Math.imul(J, ce), u = u + Math.imul(Q, ue) | 0, m = Math.imul(Q, ce), p = p + Math.imul(Y, de) | 0, u = u + Math.imul(Y, le) | 0, u = u + Math.imul(Z, de) | 0, m = m + Math.imul(Z, le) | 0, p = p + Math.imul($, pe) | 0, u = u + Math.imul($, ve) | 0, u = u + Math.imul(X, pe) | 0, m = m + Math.imul(X, ve) | 0, p = p + Math.imul(V, be) | 0, u = u + Math.imul(V, ye) | 0, u = u + Math.imul(G, be) | 0, m = m + Math.imul(G, ye) | 0, p = p + Math.imul(W, me) | 0, u = u + Math.imul(W, ge) | 0, u = u + Math.imul(K, me) | 0, m = m + Math.imul(K, ge) | 0; var ur = (v + p | 0) + ((u & 8191) << 13) | 0; v = (m + (u >>> 13) | 0) + (ur >>> 26) | 0, ur &= 67108863, p = Math.imul(J, de), u = Math.imul(J, le), u = u + Math.imul(Q, de) | 0, m = Math.imul(Q, le), p = p + Math.imul(Y, pe) | 0, u = u + Math.imul(Y, ve) | 0, u = u + Math.imul(Z, pe) | 0, m = m + Math.imul(Z, ve) | 0, p = p + Math.imul($, be) | 0, u = u + Math.imul($, ye) | 0, u = u + Math.imul(X, be) | 0, m = m + Math.imul(X, ye) | 0, p = p + Math.imul(V, me) | 0, u = u + Math.imul(V, ge) | 0, u = u + Math.imul(G, me) | 0, m = m + Math.imul(G, ge) | 0; var cr = (v + p | 0) + ((u & 8191) << 13) | 0; v = (m + (u >>> 13) | 0) + (cr >>> 26) | 0, cr &= 67108863, p = Math.imul(J, pe), u = Math.imul(J, ve), u = u + Math.imul(Q, pe) | 0, m = Math.imul(Q, ve), p = p + Math.imul(Y, be) | 0, u = u + Math.imul(Y, ye) | 0, u = u + Math.imul(Z, be) | 0, m = m + Math.imul(Z, ye) | 0, p = p + Math.imul($, me) | 0, u = u + Math.imul($, ge) | 0, u = u + Math.imul(X, me) | 0, m = m + Math.imul(X, ge) | 0; var dr = (v + p | 0) + ((u & 8191) << 13) | 0; v = (m + (u >>> 13) | 0) + (dr >>> 26) | 0, dr &= 67108863, p = Math.imul(J, be), u = Math.imul(J, ye), u = u + Math.imul(Q, be) | 0, m = Math.imul(Q, ye), p = p + Math.imul(Y, me) | 0, u = u + Math.imul(Y, ge) | 0, u = u + Math.imul(Z, me) | 0, m = m + Math.imul(Z, ge) | 0; var lr = (v + p | 0) + ((u & 8191) << 13) | 0; v = (m + (u >>> 13) | 0) + (lr >>> 26) | 0, lr &= 67108863, p = Math.imul(J, me), u = Math.imul(J, ge), u = u + Math.imul(Q, me) | 0, m = Math.imul(Q, ge); var pr = (v + p | 0) + ((u & 8191) << 13) | 0; return v = (m + (u >>> 13) | 0) + (pr >>> 26) | 0, pr &= 67108863, d[0] = Vr, d[1] = Se, d[2] = Ee, d[3] = Qt, d[4] = er, d[5] = tr, d[6] = rr, d[7] = ir, d[8] = nr, d[9] = ar, d[10] = fr, d[11] = sr, d[12] = or, d[13] = hr, d[14] = ur, d[15] = cr, d[16] = dr, d[17] = lr, d[18] = pr, v !== 0 && (d[19] = v, l.length++), l }; Math.imul || (T = B); function C(S, b, _) { _.negative = b.negative ^ S.negative, _.length = S.length + b.length; for (var l = 0, a = 0, s = 0; s < _.length - 1; s++) { var d = a; a = 0; for (var v = l & 67108863, p = Math.min(s, b.length - 1), u = Math.max(0, s - S.length + 1); u <= p; u++) { var m = s - u, g = S.words[m] | 0, o = b.words[u] | 0, w = g * o, R = w & 67108863; d = d + (w / 67108864 | 0) | 0, R = R + v | 0, v = R & 67108863, d = d + (R >>> 26) | 0, a += d >>> 26, d &= 67108863 } _.words[s] = v, l = d, d = a } return l !== 0 ? _.words[s] = l : _.length--, _.strip() } function H(S, b, _) { var l = new F; return l.mulp(S, b, _) } n.prototype.mulTo = function (b, _) { var l, a = this.length + b.length; return this.length === 10 && b.length === 10 ? l = T(this, b, _) : a < 63 ? l = B(this, b, _) : a < 1024 ? l = C(this, b, _) : l = H(this, b, _), l }; function F(S, b) { this.x = S, this.y = b } F.prototype.makeRBT = function (b) { for (var _ = new Array(b), l = n.prototype._countBits(b) - 1, a = 0; a < b; a++)_[a] = this.revBin(a, l, b); return _ }, F.prototype.revBin = function (b, _, l) { if (b === 0 || b === l - 1) return b; for (var a = 0, s = 0; s < _; s++)a |= (b & 1) << _ - s - 1, b >>= 1; return a }, F.prototype.permute = function (b, _, l, a, s, d) { for (var v = 0; v < d; v++)a[v] = _[b[v]], s[v] = l[b[v]] }, F.prototype.transform = function (b, _, l, a, s, d) { this.permute(d, b, _, l, a, s); for (var v = 1; v < s; v <<= 1)for (var p = v << 1, u = Math.cos(2 * Math.PI / p), m = Math.sin(2 * Math.PI / p), g = 0; g < s; g += p)for (var o = u, w = m, R = 0; R < v; R++) { var k = l[g + R], q = a[g + R], O = l[g + R + v], D = a[g + R + v], U = o * O - w * D; D = o * D + w * O, O = U, l[g + R] = k + O, a[g + R] = q + D, l[g + R + v] = k - O, a[g + R + v] = q - D, R !== p && (U = u * o - m * w, w = u * w + m * o, o = U) } }, F.prototype.guessLen13b = function (b, _) { var l = Math.max(_, b) | 1, a = l & 1, s = 0; for (l = l / 2 | 0; l; l = l >>> 1)s++; return 1 << s + 1 + a }, F.prototype.conjugate = function (b, _, l) { if (!(l <= 1)) for (var a = 0; a < l / 2; a++) { var s = b[a]; b[a] = b[l - a - 1], b[l - a - 1] = s, s = _[a], _[a] = -_[l - a - 1], _[l - a - 1] = -s } }, F.prototype.normalize13b = function (b, _) { for (var l = 0, a = 0; a < _ / 2; a++) { var s = Math.round(b[2 * a + 1] / _) * 8192 + Math.round(b[2 * a] / _) + l; b[a] = s & 67108863, s < 67108864 ? l = 0 : l = s / 67108864 | 0 } return b }, F.prototype.convert13b = function (b, _, l, a) { for (var s = 0, d = 0; d < _; d++)s = s + (b[d] | 0), l[2 * d] = s & 8191, s = s >>> 13, l[2 * d + 1] = s & 8191, s = s >>> 13; for (d = 2 * _; d < a; ++d)l[d] = 0; r(s === 0), r((s & ~8191) == 0) }, F.prototype.stub = function (b) { for (var _ = new Array(b), l = 0; l < b; l++)_[l] = 0; return _ }, F.prototype.mulp = function (b, _, l) { var a = 2 * this.guessLen13b(b.length, _.length), s = this.makeRBT(a), d = this.stub(a), v = new Array(a), p = new Array(a), u = new Array(a), m = new Array(a), g = new Array(a), o = new Array(a), w = l.words; w.length = a, this.convert13b(b.words, b.length, v, a), this.convert13b(_.words, _.length, m, a), this.transform(v, d, p, u, a, s), this.transform(m, d, g, o, a, s); for (var R = 0; R < a; R++) { var k = p[R] * g[R] - u[R] * o[R]; u[R] = p[R] * o[R] + u[R] * g[R], p[R] = k } return this.conjugate(p, u, a), this.transform(p, u, w, d, a, s), this.conjugate(w, d, a), this.normalize13b(w, a), l.negative = b.negative ^ _.negative, l.length = b.length + _.length, l.strip() }, n.prototype.mul = function (b) { var _ = new n(null); return _.words = new Array(this.length + b.length), this.mulTo(b, _) }, n.prototype.mulf = function (b) { var _ = new n(null); return _.words = new Array(this.length + b.length), H(this, b, _) }, n.prototype.imul = function (b) { return this.clone().mulTo(b, this) }, n.prototype.imuln = function (b) { r(typeof b == "number"), r(b < 67108864); for (var _ = 0, l = 0; l < this.length; l++) { var a = (this.words[l] | 0) * b, s = (a & 67108863) + (_ & 67108863); _ >>= 26, _ += a / 67108864 | 0, _ += s >>> 26, this.words[l] = s & 67108863 } return _ !== 0 && (this.words[l] = _, this.length++), this }, n.prototype.muln = function (b) { return this.clone().imuln(b) }, n.prototype.sqr = function () { return this.mul(this) }, n.prototype.isqr = function () { return this.imul(this.clone()) }, n.prototype.pow = function (b) { var _ = A(b); if (_.length === 0) return new n(1); for (var l = this, a = 0; a < _.length && _[a] === 0; a++, l = l.sqr()); if (++a < _.length) for (var s = l.sqr(); a < _.length; a++, s = s.sqr())_[a] !== 0 && (l = l.mul(s)); return l }, n.prototype.iushln = function (b) { r(typeof b == "number" && b >= 0); var _ = b % 26, l = (b - _) / 26, a = 67108863 >>> 26 - _ << 26 - _, s; if (_ !== 0) { var d = 0; for (s = 0; s < this.length; s++) { var v = this.words[s] & a, p = (this.words[s] | 0) - v << _; this.words[s] = p | d, d = v >>> 26 - _ } d && (this.words[s] = d, this.length++) } if (l !== 0) { for (s = this.length - 1; s >= 0; s--)this.words[s + l] = this.words[s]; for (s = 0; s < l; s++)this.words[s] = 0; this.length += l } return this.strip() }, n.prototype.ishln = function (b) { return r(this.negative === 0), this.iushln(b) }, n.prototype.iushrn = function (b, _, l) { r(typeof b == "number" && b >= 0); var a; _ ? a = (_ - _ % 26) / 26 : a = 0; var s = b % 26, d = Math.min((b - s) / 26, this.length), v = 67108863 ^ 67108863 >>> s << s, p = l; if (a -= d, a = Math.max(0, a), p) { for (var u = 0; u < d; u++)p.words[u] = this.words[u]; p.length = d } if (d !== 0) if (this.length > d) for (this.length -= d, u = 0; u < this.length; u++)this.words[u] = this.words[u + d]; else this.words[0] = 0, this.length = 1; var m = 0; for (u = this.length - 1; u >= 0 && (m !== 0 || u >= a); u--) { var g = this.words[u] | 0; this.words[u] = m << 26 - s | g >>> s, m = g & v } return p && m !== 0 && (p.words[p.length++] = m), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip() }, n.prototype.ishrn = function (b, _, l) { return r(this.negative === 0), this.iushrn(b, _, l) }, n.prototype.shln = function (b) { return this.clone().ishln(b) }, n.prototype.ushln = function (b) { return this.clone().iushln(b) }, n.prototype.shrn = function (b) { return this.clone().ishrn(b) }, n.prototype.ushrn = function (b) { return this.clone().iushrn(b) }, n.prototype.testn = function (b) { r(typeof b == "number" && b >= 0); var _ = b % 26, l = (b - _) / 26, a = 1 << _; if (this.length <= l) return !1; var s = this.words[l]; return !!(s & a) }, n.prototype.imaskn = function (b) { r(typeof b == "number" && b >= 0); var _ = b % 26, l = (b - _) / 26; if (r(this.negative === 0, "imaskn works only with positive numbers"), this.length <= l) return this; if (_ !== 0 && l++, this.length = Math.min(l, this.length), _ !== 0) { var a = 67108863 ^ 67108863 >>> _ << _; this.words[this.length - 1] &= a } return this.strip() }, n.prototype.maskn = function (b) { return this.clone().imaskn(b) }, n.prototype.iaddn = function (b) { return r(typeof b == "number"), r(b < 67108864), b < 0 ? this.isubn(-b) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < b ? (this.words[0] = b - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(b), this.negative = 1, this) : this._iaddn(b) }, n.prototype._iaddn = function (b) { this.words[0] += b; for (var _ = 0; _ < this.length && this.words[_] >= 67108864; _++)this.words[_] -= 67108864, _ === this.length - 1 ? this.words[_ + 1] = 1 : this.words[_ + 1]++; return this.length = Math.max(this.length, _ + 1), this }, n.prototype.isubn = function (b) { if (r(typeof b == "number"), r(b < 67108864), b < 0) return this.iaddn(-b); if (this.negative !== 0) return this.negative = 0, this.iaddn(b), this.negative = 1, this; if (this.words[0] -= b, this.length === 1 && this.words[0] < 0) this.words[0] = -this.words[0], this.negative = 1; else for (var _ = 0; _ < this.length && this.words[_] < 0; _++)this.words[_] += 67108864, this.words[_ + 1] -= 1; return this.strip() }, n.prototype.addn = function (b) { return this.clone().iaddn(b) }, n.prototype.subn = function (b) { return this.clone().isubn(b) }, n.prototype.iabs = function () { return this.negative = 0, this }, n.prototype.abs = function () { return this.clone().iabs() }, n.prototype._ishlnsubmul = function (b, _, l) { var a = b.length + l, s; this._expand(a); var d, v = 0; for (s = 0; s < b.length; s++) { d = (this.words[s + l] | 0) + v; var p = (b.words[s] | 0) * _; d -= p & 67108863, v = (d >> 26) - (p / 67108864 | 0), this.words[s + l] = d & 67108863 } for (; s < this.length - l; s++)d = (this.words[s + l] | 0) + v, v = d >> 26, this.words[s + l] = d & 67108863; if (v === 0) return this.strip(); for (r(v === -1), v = 0, s = 0; s < this.length; s++)d = -(this.words[s] | 0) + v, v = d >> 26, this.words[s] = d & 67108863; return this.negative = 1, this.strip() }, n.prototype._wordDiv = function (b, _) { var l = this.length - b.length, a = this.clone(), s = b, d = s.words[s.length - 1] | 0, v = this._countBits(d); l = 26 - v, l !== 0 && (s = s.ushln(l), a.iushln(l), d = s.words[s.length - 1] | 0); var p = a.length - s.length, u; if (_ !== "mod") { u = new n(null), u.length = p + 1, u.words = new Array(u.length); for (var m = 0; m < u.length; m++)u.words[m] = 0 } var g = a.clone()._ishlnsubmul(s, 1, p); g.negative === 0 && (a = g, u && (u.words[p] = 1)); for (var o = p - 1; o >= 0; o--) { var w = (a.words[s.length + o] | 0) * 67108864 + (a.words[s.length + o - 1] | 0); for (w = Math.min(w / d | 0, 67108863), a._ishlnsubmul(s, w, o); a.negative !== 0;)w--, a.negative = 0, a._ishlnsubmul(s, 1, o), a.isZero() || (a.negative ^= 1); u && (u.words[o] = w) } return u && u.strip(), a.strip(), _ !== "div" && l !== 0 && a.iushrn(l), { div: u || null, mod: a } }, n.prototype.divmod = function (b, _, l) { if (r(!b.isZero()), this.isZero()) return { div: new n(0), mod: new n(0) }; var a, s, d; return this.negative !== 0 && b.negative === 0 ? (d = this.neg().divmod(b, _), _ !== "mod" && (a = d.div.neg()), _ !== "div" && (s = d.mod.neg(), l && s.negative !== 0 && s.iadd(b)), { div: a, mod: s }) : this.negative === 0 && b.negative !== 0 ? (d = this.divmod(b.neg(), _), _ !== "mod" && (a = d.div.neg()), { div: a, mod: d.mod }) : (this.negative & b.negative) != 0 ? (d = this.neg().divmod(b.neg(), _), _ !== "div" && (s = d.mod.neg(), l && s.negative !== 0 && s.isub(b)), { div: d.div, mod: s }) : b.length > this.length || this.cmp(b) < 0 ? { div: new n(0), mod: this } : b.length === 1 ? _ === "div" ? { div: this.divn(b.words[0]), mod: null } : _ === "mod" ? { div: null, mod: new n(this.modn(b.words[0])) } : { div: this.divn(b.words[0]), mod: new n(this.modn(b.words[0])) } : this._wordDiv(b, _) }, n.prototype.div = function (b) { return this.divmod(b, "div", !1).div }, n.prototype.mod = function (b) { return this.divmod(b, "mod", !1).mod }, n.prototype.umod = function (b) { return this.divmod(b, "mod", !0).mod }, n.prototype.divRound = function (b) { var _ = this.divmod(b); if (_.mod.isZero()) return _.div; var l = _.div.negative !== 0 ? _.mod.isub(b) : _.mod, a = b.ushrn(1), s = b.andln(1), d = l.cmp(a); return d < 0 || s === 1 && d === 0 ? _.div : _.div.negative !== 0 ? _.div.isubn(1) : _.div.iaddn(1) }, n.prototype.modn = function (b) { r(b <= 67108863); for (var _ = (1 << 26) % b, l = 0, a = this.length - 1; a >= 0; a--)l = (_ * l + (this.words[a] | 0)) % b; return l }, n.prototype.idivn = function (b) { r(b <= 67108863); for (var _ = 0, l = this.length - 1; l >= 0; l--) { var a = (this.words[l] | 0) + _ * 67108864; this.words[l] = a / b | 0, _ = a % b } return this.strip() }, n.prototype.divn = function (b) { return this.clone().idivn(b) }, n.prototype.egcd = function (b) { r(b.negative === 0), r(!b.isZero()); var _ = this, l = b.clone(); _.negative !== 0 ? _ = _.umod(b) : _ = _.clone(); for (var a = new n(1), s = new n(0), d = new n(0), v = new n(1), p = 0; _.isEven() && l.isEven();)_.iushrn(1), l.iushrn(1), ++p; for (var u = l.clone(), m = _.clone(); !_.isZero();) { for (var g = 0, o = 1; (_.words[0] & o) == 0 && g < 26; ++g, o <<= 1); if (g > 0) for (_.iushrn(g); g-- > 0;)(a.isOdd() || s.isOdd()) && (a.iadd(u), s.isub(m)), a.iushrn(1), s.iushrn(1); for (var w = 0, R = 1; (l.words[0] & R) == 0 && w < 26; ++w, R <<= 1); if (w > 0) for (l.iushrn(w); w-- > 0;)(d.isOdd() || v.isOdd()) && (d.iadd(u), v.isub(m)), d.iushrn(1), v.iushrn(1); _.cmp(l) >= 0 ? (_.isub(l), a.isub(d), s.isub(v)) : (l.isub(_), d.isub(a), v.isub(s)) } return { a: d, b: v, gcd: l.iushln(p) } }, n.prototype._invmp = function (b) { r(b.negative === 0), r(!b.isZero()); var _ = this, l = b.clone(); _.negative !== 0 ? _ = _.umod(b) : _ = _.clone(); for (var a = new n(1), s = new n(0), d = l.clone(); _.cmpn(1) > 0 && l.cmpn(1) > 0;) { for (var v = 0, p = 1; (_.words[0] & p) == 0 && v < 26; ++v, p <<= 1); if (v > 0) for (_.iushrn(v); v-- > 0;)a.isOdd() && a.iadd(d), a.iushrn(1); for (var u = 0, m = 1; (l.words[0] & m) == 0 && u < 26; ++u, m <<= 1); if (u > 0) for (l.iushrn(u); u-- > 0;)s.isOdd() && s.iadd(d), s.iushrn(1); _.cmp(l) >= 0 ? (_.isub(l), a.isub(s)) : (l.isub(_), s.isub(a)) } var g; return _.cmpn(1) === 0 ? g = a : g = s, g.cmpn(0) < 0 && g.iadd(b), g }, n.prototype.gcd = function (b) { if (this.isZero()) return b.abs(); if (b.isZero()) return this.abs(); var _ = this.clone(), l = b.clone(); _.negative = 0, l.negative = 0; for (var a = 0; _.isEven() && l.isEven(); a++)_.iushrn(1), l.iushrn(1); do { for (; _.isEven();)_.iushrn(1); for (; l.isEven();)l.iushrn(1); var s = _.cmp(l); if (s < 0) { var d = _; _ = l, l = d } else if (s === 0 || l.cmpn(1) === 0) break; _.isub(l) } while (!0); return l.iushln(a) }, n.prototype.invm = function (b) { return this.egcd(b).a.umod(b) }, n.prototype.isEven = function () { return (this.words[0] & 1) == 0 }, n.prototype.isOdd = function () { return (this.words[0] & 1) == 1 }, n.prototype.andln = function (b) { return this.words[0] & b }, n.prototype.bincn = function (b) { r(typeof b == "number"); var _ = b % 26, l = (b - _) / 26, a = 1 << _; if (this.length <= l) return this._expand(l + 1), this.words[l] |= a, this; for (var s = a, d = l; s !== 0 && d < this.length; d++) { var v = this.words[d] | 0; v += s, s = v >>> 26, v &= 67108863, this.words[d] = v } return s !== 0 && (this.words[d] = s, this.length++), this }, n.prototype.isZero = function () { return this.length === 1 && this.words[0] === 0 }, n.prototype.cmpn = function (b) { var _ = b < 0; if (this.negative !== 0 && !_) return -1; if (this.negative === 0 && _) return 1; this.strip(); var l; if (this.length > 1) l = 1; else { _ && (b = -b), r(b <= 67108863, "Number is too big"); var a = this.words[0] | 0; l = a === b ? 0 : a < b ? -1 : 1 } return this.negative !== 0 ? -l | 0 : l }, n.prototype.cmp = function (b) { if (this.negative !== 0 && b.negative === 0) return -1; if (this.negative === 0 && b.negative !== 0) return 1; var _ = this.ucmp(b); return this.negative !== 0 ? -_ | 0 : _ }, n.prototype.ucmp = function (b) { if (this.length > b.length) return 1; if (this.length < b.length) return -1; for (var _ = 0, l = this.length - 1; l >= 0; l--) { var a = this.words[l] | 0, s = b.words[l] | 0; if (a !== s) { a < s ? _ = -1 : a > s && (_ = 1); break } } return _ }, n.prototype.gtn = function (b) { return this.cmpn(b) === 1 }, n.prototype.gt = function (b) { return this.cmp(b) === 1 }, n.prototype.gten = function (b) { return this.cmpn(b) >= 0 }, n.prototype.gte = function (b) { return this.cmp(b) >= 0 }, n.prototype.ltn = function (b) { return this.cmpn(b) === -1 }, n.prototype.lt = function (b) { return this.cmp(b) === -1 }, n.prototype.lten = function (b) { return this.cmpn(b) <= 0 }, n.prototype.lte = function (b) { return this.cmp(b) <= 0 }, n.prototype.eqn = function (b) { return this.cmpn(b) === 0 }, n.prototype.eq = function (b) { return this.cmp(b) === 0 }, n.red = function (b) { return new Ie(b) }, n.prototype.toRed = function (b) { return r(!this.red, "Already a number in reduction context"), r(this.negative === 0, "red works only with positives"), b.convertTo(this)._forceRed(b) }, n.prototype.fromRed = function () { return r(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this) }, n.prototype._forceRed = function (b) { return this.red = b, this }, n.prototype.forceRed = function (b) { return r(!this.red, "Already a number in reduction context"), this._forceRed(b) }, n.prototype.redAdd = function (b) { return r(this.red, "redAdd works only with red numbers"), this.red.add(this, b) }, n.prototype.redIAdd = function (b) { return r(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, b) }, n.prototype.redSub = function (b) { return r(this.red, "redSub works only with red numbers"), this.red.sub(this, b) }, n.prototype.redISub = function (b) { return r(this.red, "redISub works only with red numbers"), this.red.isub(this, b) }, n.prototype.redShl = function (b) { return r(this.red, "redShl works only with red numbers"), this.red.shl(this, b) }, n.prototype.redMul = function (b) { return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, b), this.red.mul(this, b) }, n.prototype.redIMul = function (b) { return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, b), this.red.imul(this, b) }, n.prototype.redSqr = function () { return r(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this) }, n.prototype.redISqr = function () { return r(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this) }, n.prototype.redSqrt = function () { return r(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this) }, n.prototype.redInvm = function () { return r(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this) }, n.prototype.redNeg = function () { return r(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this) }, n.prototype.redPow = function (b) { return r(this.red && !b.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, b) }; var we = { k256: null, p224: null, p192: null, p25519: null }; function Be(S, b) { this.name = S, this.p = new n(b, 16), this.n = this.p.bitLength(), this.k = new n(1).iushln(this.n).isub(this.p), this.tmp = this._tmp() } Be.prototype._tmp = function () { var b = new n(null); return b.words = new Array(Math.ceil(this.n / 13)), b }, Be.prototype.ireduce = function (b) { var _ = b, l; do this.split(_, this.tmp), _ = this.imulK(_), _ = _.iadd(this.tmp), l = _.bitLength(); while (l > this.n); var a = l < this.n ? -1 : _.ucmp(this.p); return a === 0 ? (_.words[0] = 0, _.length = 1) : a > 0 ? _.isub(this.p) : _.strip !== void 0 ? _.strip() : _._strip(), _ }, Be.prototype.split = function (b, _) { b.iushrn(this.n, 0, _) }, Be.prototype.imulK = function (b) { return b.imul(this.k) }; function xe() { Be.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f") } i(xe, Be), xe.prototype.split = function (b, _) { for (var l = 4194303, a = Math.min(b.length, 9), s = 0; s < a; s++)_.words[s] = b.words[s]; if (_.length = a, b.length <= 9) { b.words[0] = 0, b.length = 1; return } var d = b.words[9]; for (_.words[_.length++] = d & l, s = 10; s < b.length; s++) { var v = b.words[s] | 0; b.words[s - 10] = (v & l) << 4 | d >>> 22, d = v } d >>>= 22, b.words[s - 10] = d, d === 0 && b.length > 10 ? b.length -= 10 : b.length -= 9 }, xe.prototype.imulK = function (b) { b.words[b.length] = 0, b.words[b.length + 1] = 0, b.length += 2; for (var _ = 0, l = 0; l < b.length; l++) { var a = b.words[l] | 0; _ += a * 977, b.words[l] = _ & 67108863, _ = a * 64 + (_ / 67108864 | 0) } return b.words[b.length - 1] === 0 && (b.length--, b.words[b.length - 1] === 0 && b.length--), b }; function Le() { Be.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001") } i(Le, Be); function Me() { Be.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff") } i(Me, Be); function De() { Be.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed") } i(De, Be), De.prototype.imulK = function (b) { for (var _ = 0, l = 0; l < b.length; l++) { var a = (b.words[l] | 0) * 19 + _, s = a & 67108863; a >>>= 26, b.words[l] = s, _ = a } return _ !== 0 && (b.words[b.length++] = _), b }, n._prime = function (b) { if (we[b]) return we[b]; var _; if (b === "k256") _ = new xe; else if (b === "p224") _ = new Le; else if (b === "p192") _ = new Me; else if (b === "p25519") _ = new De; else throw new Error("Unknown prime " + b); return we[b] = _, _ }; function Ie(S) { if (typeof S == "string") { var b = n._prime(S); this.m = b.p, this.prime = b } else r(S.gtn(1), "modulus must be greater than 1"), this.m = S, this.prime = null } Ie.prototype._verify1 = function (b) { r(b.negative === 0, "red works only with positives"), r(b.red, "red works only with red numbers") }, Ie.prototype._verify2 = function (b, _) { r((b.negative | _.negative) == 0, "red works only with positives"), r(b.red && b.red === _.red, "red works only with red numbers") }, Ie.prototype.imod = function (b) { return this.prime ? this.prime.ireduce(b)._forceRed(this) : b.umod(this.m)._forceRed(this) }, Ie.prototype.neg = function (b) { return b.isZero() ? b.clone() : this.m.sub(b)._forceRed(this) }, Ie.prototype.add = function (b, _) { this._verify2(b, _); var l = b.add(_); return l.cmp(this.m) >= 0 && l.isub(this.m), l._forceRed(this) }, Ie.prototype.iadd = function (b, _) { this._verify2(b, _); var l = b.iadd(_); return l.cmp(this.m) >= 0 && l.isub(this.m), l }, Ie.prototype.sub = function (b, _) { this._verify2(b, _); var l = b.sub(_); return l.cmpn(0) < 0 && l.iadd(this.m), l._forceRed(this) }, Ie.prototype.isub = function (b, _) { this._verify2(b, _); var l = b.isub(_); return l.cmpn(0) < 0 && l.iadd(this.m), l }, Ie.prototype.shl = function (b, _) { return this._verify1(b), this.imod(b.ushln(_)) }, Ie.prototype.imul = function (b, _) { return this._verify2(b, _), this.imod(b.imul(_)) }, Ie.prototype.mul = function (b, _) { return this._verify2(b, _), this.imod(b.mul(_)) }, Ie.prototype.isqr = function (b) { return this.imul(b, b.clone()) }, Ie.prototype.sqr = function (b) { return this.mul(b, b) }, Ie.prototype.sqrt = function (b) { if (b.isZero()) return b.clone(); var _ = this.m.andln(3); if (r(_ % 2 == 1), _ === 3) { var l = this.m.add(new n(1)).iushrn(2); return this.pow(b, l) } for (var a = this.m.subn(1), s = 0; !a.isZero() && a.andln(1) === 0;)s++, a.iushrn(1); r(!a.isZero()); var d = new n(1).toRed(this), v = d.redNeg(), p = this.m.subn(1).iushrn(1), u = this.m.bitLength(); for (u = new n(2 * u * u).toRed(this); this.pow(u, p).cmp(v) !== 0;)u.redIAdd(v); for (var m = this.pow(u, a), g = this.pow(b, a.addn(1).iushrn(1)), o = this.pow(b, a), w = s; o.cmp(d) !== 0;) { for (var R = o, k = 0; R.cmp(d) !== 0; k++)R = R.redSqr(); r(k < w); var q = this.pow(m, new n(1).iushln(w - k - 1)); g = g.redMul(q), m = q.redSqr(), o = o.redMul(m), w = k } return g }, Ie.prototype.invm = function (b) { var _ = b._invmp(this.m); return _.negative !== 0 ? (_.negative = 0, this.imod(_).redNeg()) : this.imod(_) }, Ie.prototype.pow = function (b, _) { if (_.isZero()) return new n(1).toRed(this); if (_.cmpn(1) === 0) return b.clone(); var l = 4, a = new Array(1 << l); a[0] = new n(1).toRed(this), a[1] = b; for (var s = 2; s < a.length; s++)a[s] = this.mul(a[s - 1], b); var d = a[0], v = 0, p = 0, u = _.bitLength() % 26; for (u === 0 && (u = 26), s = _.length - 1; s >= 0; s--) { for (var m = _.words[s], g = u - 1; g >= 0; g--) { var o = m >> g & 1; if (d !== a[0] && (d = this.sqr(d)), o === 0 && v === 0) { p = 0; continue } v <<= 1, v |= o, p++, !(p !== l && (s !== 0 || g !== 0)) && (d = this.mul(d, a[v]), p = 0, v = 0) } u = 26 } return d }, Ie.prototype.convertTo = function (b) { var _ = b.umod(this.m); return _ === b ? _.clone() : _ }, Ie.prototype.convertFrom = function (b) { var _ = b.clone(); return _.red = null, _ }, n.mont = function (b) { return new je(b) }; function je(S) { Ie.call(this, S), this.shift = this.m.bitLength(), this.shift % 26 != 0 && (this.shift += 26 - this.shift % 26), this.r = new n(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv) } i(je, Ie), je.prototype.convertTo = function (b) { return this.imod(b.ushln(this.shift)) }, je.prototype.convertFrom = function (b) { var _ = this.imod(b.mul(this.rinv)); return _.red = null, _ }, je.prototype.imul = function (b, _) { if (b.isZero() || _.isZero()) return b.words[0] = 0, b.length = 1, b; var l = b.imul(_), a = l.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), s = l.isub(a).iushrn(this.shift), d = s; return s.cmp(this.m) >= 0 ? d = s.isub(this.m) : s.cmpn(0) < 0 && (d = s.iadd(this.m)), d._forceRed(this) }, je.prototype.mul = function (b, _) { if (b.isZero() || _.isZero()) return new n(0)._forceRed(this); var l = b.mul(_), a = l.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), s = l.isub(a).iushrn(this.shift), d = s; return s.cmp(this.m) >= 0 ? d = s.isub(this.m) : s.cmpn(0) < 0 && (d = s.iadd(this.m)), d._forceRed(this) }, je.prototype.invm = function (b) { var _ = this.imod(b._invmp(this.m).mul(this.r2)); return _._forceRed(this) } })(typeof Mh == "undefined" || Mh, ld) }); var Tt = I((sE, vd) => { vd.exports = pd; function pd(t, e) { if (!t) throw new Error(e || "Assertion failed") } pd.equal = function (e, r, i) { if (e != r) throw new Error(i || "Assertion failed: " + e + " != " + r) } }); var Sh = I(md => { "use strict"; var Jf = md; function E3(t, e) { if (Array.isArray(t)) return t.slice(); if (!t) return []; var r = []; if (typeof t != "string") { for (var i = 0; i < t.length; i++)r[i] = t[i] | 0; return r } if (e === "hex") { t = t.replace(/[^a-z0-9]+/ig, ""), t.length % 2 != 0 && (t = "0" + t); for (var i = 0; i < t.length; i += 2)r.push(parseInt(t[i] + t[i + 1], 16)) } else for (var i = 0; i < t.length; i++) { var n = t.charCodeAt(i), f = n >> 8, h = n & 255; f ? r.push(f, h) : r.push(h) } return r } Jf.toArray = E3; function bd(t) { return t.length === 1 ? "0" + t : t } Jf.zero2 = bd; function yd(t) { for (var e = "", r = 0; r < t.length; r++)e += bd(t[r].toString(16)); return e } Jf.toHex = yd; Jf.encode = function (e, r) { return r === "hex" ? yd(e) : e } }); var qt = I(gd => { "use strict"; var br = gd, A3 = rt(), B3 = Tt(), Qf = Sh(); br.assert = B3; br.toArray = Qf.toArray; br.zero2 = Qf.zero2; br.toHex = Qf.toHex; br.encode = Qf.encode; function I3(t, e, r) { var i = new Array(Math.max(t.bitLength(), r) + 1); i.fill(0); for (var n = 1 << e + 1, f = t.clone(), h = 0; h < i.length; h++) { var c, y = f.andln(n - 1); f.isOdd() ? (y > (n >> 1) - 1 ? c = (n >> 1) - y : c = y, f.isubn(c)) : c = 0, i[h] = c, f.iushrn(1) } return i } br.getNAF = I3; function R3(t, e) { var r = [[], []]; t = t.clone(), e = e.clone(); for (var i = 0, n = 0, f; t.cmpn(-i) > 0 || e.cmpn(-n) > 0;) { var h = t.andln(3) + i & 3, c = e.andln(3) + n & 3; h === 3 && (h = -1), c === 3 && (c = -1); var y; (h & 1) == 0 ? y = 0 : (f = t.andln(7) + i & 7, (f === 3 || f === 5) && c === 2 ? y = -h : y = h), r[0].push(y); var x; (c & 1) == 0 ? x = 0 : (f = e.andln(7) + n & 7, (f === 3 || f === 5) && h === 2 ? x = -c : x = c), r[1].push(x), 2 * i === y + 1 && (i = 1 - i), 2 * n === x + 1 && (n = 1 - n), t.iushrn(1), e.iushrn(1) } return r } br.getJSF = R3; function T3(t, e, r) { var i = "_" + e; t.prototype[e] = function () { return this[i] !== void 0 ? this[i] : this[i] = r.call(this) } } br.cachedProperty = T3; function q3(t) { return typeof t == "string" ? br.toArray(t, "hex") : t } br.parseBytes = q3; function k3(t) { return new A3(t, "hex", "le") } br.intFromLE = k3 }); var Te = I((Eh, _d) => { var es = ct(), qr = es.Buffer; function wd(t, e) { for (var r in t) e[r] = t[r] } qr.from && qr.alloc && qr.allocUnsafe && qr.allocUnsafeSlow ? _d.exports = es : (wd(es, Eh), Eh.Buffer = nn); function nn(t, e, r) { return qr(t, e, r) } nn.prototype = Object.create(qr.prototype); wd(qr, nn); nn.from = function (t, e, r) { if (typeof t == "number") throw new TypeError("Argument must not be a number"); return qr(t, e, r) }; nn.alloc = function (t, e, r) { if (typeof t != "number") throw new TypeError("Argument must be a number"); var i = qr(t); return e !== void 0 ? typeof r == "string" ? i.fill(e, r) : i.fill(e) : i.fill(0), i }; nn.allocUnsafe = function (t) { if (typeof t != "number") throw new TypeError("Argument must be a number"); return qr(t) }; nn.allocUnsafeSlow = function (t) { if (typeof t != "number") throw new TypeError("Argument must be a number"); return es.SlowBuffer(t) } }); var an = I((uE, Bh) => {
          "use strict"; var Ah = 65536, P3 = 4294967295; function C3() {
            throw new Error(`Secure random number generation is not supported by this browser.
Use Chrome, Firefox or Internet Explorer 11`)
          } var O3 = Te().Buffer, ts = window.crypto || window.msCrypto; ts && ts.getRandomValues ? Bh.exports = D3 : Bh.exports = C3; function D3(t, e) { if (t > P3) throw new RangeError("requested too many random bytes"); var r = O3.allocUnsafe(t); if (t > 0) if (t > Ah) for (var i = 0; i < t; i += Ah)ts.getRandomValues(r.slice(i, i + Ah)); else ts.getRandomValues(r); return typeof e == "function" ? process.nextTick(function () { e(null, r) }) : r }
        }); var Re = I((cE, Ih) => { typeof Object.create == "function" ? Ih.exports = function (e, r) { r && (e.super_ = r, e.prototype = Object.create(r.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } })) } : Ih.exports = function (e, r) { if (r) { e.super_ = r; var i = function () { }; i.prototype = r.prototype, e.prototype = new i, e.prototype.constructor = e } } }); var ns = I((dE, Rh) => { "use strict"; var Xn = typeof Reflect == "object" ? Reflect : null, xd = Xn && typeof Xn.apply == "function" ? Xn.apply : function (e, r, i) { return Function.prototype.apply.call(e, r, i) }, rs; Xn && typeof Xn.ownKeys == "function" ? rs = Xn.ownKeys : Object.getOwnPropertySymbols ? rs = function (e) { return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e)) } : rs = function (e) { return Object.getOwnPropertyNames(e) }; function F3(t) { console && console.warn && console.warn(t) } var Md = Number.isNaN || function (e) { return e !== e }; function ze() { ze.init.call(this) } Rh.exports = ze; Rh.exports.once = H3; ze.EventEmitter = ze; ze.prototype._events = void 0; ze.prototype._eventsCount = 0; ze.prototype._maxListeners = void 0; var Sd = 10; function is(t) { if (typeof t != "function") throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof t) } Object.defineProperty(ze, "defaultMaxListeners", { enumerable: !0, get: function () { return Sd }, set: function (t) { if (typeof t != "number" || t < 0 || Md(t)) throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + t + "."); Sd = t } }); ze.init = function () { (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0 }; ze.prototype.setMaxListeners = function (e) { if (typeof e != "number" || e < 0 || Md(e)) throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e + "."); return this._maxListeners = e, this }; function Ed(t) { return t._maxListeners === void 0 ? ze.defaultMaxListeners : t._maxListeners } ze.prototype.getMaxListeners = function () { return Ed(this) }; ze.prototype.emit = function (e) { for (var r = [], i = 1; i < arguments.length; i++)r.push(arguments[i]); var n = e === "error", f = this._events; if (f !== void 0) n = n && f.error === void 0; else if (!n) return !1; if (n) { var h; if (r.length > 0 && (h = r[0]), h instanceof Error) throw h; var c = new Error("Unhandled error." + (h ? " (" + h.message + ")" : "")); throw c.context = h, c } var y = f[e]; if (y === void 0) return !1; if (typeof y == "function") xd(y, this, r); else for (var x = y.length, M = Td(y, x), i = 0; i < x; ++i)xd(M[i], this, r); return !0 }; function Ad(t, e, r, i) { var n, f, h; if (is(r), f = t._events, f === void 0 ? (f = t._events = Object.create(null), t._eventsCount = 0) : (f.newListener !== void 0 && (t.emit("newListener", e, r.listener ? r.listener : r), f = t._events), h = f[e]), h === void 0) h = f[e] = r, ++t._eventsCount; else if (typeof h == "function" ? h = f[e] = i ? [r, h] : [h, r] : i ? h.unshift(r) : h.push(r), n = Ed(t), n > 0 && h.length > n && !h.warned) { h.warned = !0; var c = new Error("Possible EventEmitter memory leak detected. " + h.length + " " + String(e) + " listeners added. Use emitter.setMaxListeners() to increase limit"); c.name = "MaxListenersExceededWarning", c.emitter = t, c.type = e, c.count = h.length, F3(c) } return t } ze.prototype.addListener = function (e, r) { return Ad(this, e, r, !1) }; ze.prototype.on = ze.prototype.addListener; ze.prototype.prependListener = function (e, r) { return Ad(this, e, r, !0) }; function U3() { if (!this.fired) return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments) } function Bd(t, e, r) { var i = { fired: !1, wrapFn: void 0, target: t, type: e, listener: r }, n = U3.bind(i); return n.listener = r, i.wrapFn = n, n } ze.prototype.once = function (e, r) { return is(r), this.on(e, Bd(this, e, r)), this }; ze.prototype.prependOnceListener = function (e, r) { return is(r), this.prependListener(e, Bd(this, e, r)), this }; ze.prototype.removeListener = function (e, r) { var i, n, f, h, c; if (is(r), n = this._events, n === void 0) return this; if (i = n[e], i === void 0) return this; if (i === r || i.listener === r) --this._eventsCount == 0 ? this._events = Object.create(null) : (delete n[e], n.removeListener && this.emit("removeListener", e, i.listener || r)); else if (typeof i != "function") { for (f = -1, h = i.length - 1; h >= 0; h--)if (i[h] === r || i[h].listener === r) { c = i[h].listener, f = h; break } if (f < 0) return this; f === 0 ? i.shift() : N3(i, f), i.length === 1 && (n[e] = i[0]), n.removeListener !== void 0 && this.emit("removeListener", e, c || r) } return this }; ze.prototype.off = ze.prototype.removeListener; ze.prototype.removeAllListeners = function (e) { var r, i, n; if (i = this._events, i === void 0) return this; if (i.removeListener === void 0) return arguments.length === 0 ? (this._events = Object.create(null), this._eventsCount = 0) : i[e] !== void 0 && (--this._eventsCount == 0 ? this._events = Object.create(null) : delete i[e]), this; if (arguments.length === 0) { var f = Object.keys(i), h; for (n = 0; n < f.length; ++n)h = f[n], h !== "removeListener" && this.removeAllListeners(h); return this.removeAllListeners("removeListener"), this._events = Object.create(null), this._eventsCount = 0, this } if (r = i[e], typeof r == "function") this.removeListener(e, r); else if (r !== void 0) for (n = r.length - 1; n >= 0; n--)this.removeListener(e, r[n]); return this }; function Id(t, e, r) { var i = t._events; if (i === void 0) return []; var n = i[e]; return n === void 0 ? [] : typeof n == "function" ? r ? [n.listener || n] : [n] : r ? L3(n) : Td(n, n.length) } ze.prototype.listeners = function (e) { return Id(this, e, !0) }; ze.prototype.rawListeners = function (e) { return Id(this, e, !1) }; ze.listenerCount = function (t, e) { return typeof t.listenerCount == "function" ? t.listenerCount(e) : Rd.call(t, e) }; ze.prototype.listenerCount = Rd; function Rd(t) { var e = this._events; if (e !== void 0) { var r = e[t]; if (typeof r == "function") return 1; if (r !== void 0) return r.length } return 0 } ze.prototype.eventNames = function () { return this._eventsCount > 0 ? rs(this._events) : [] }; function Td(t, e) { for (var r = new Array(e), i = 0; i < e; ++i)r[i] = t[i]; return r } function N3(t, e) { for (; e + 1 < t.length; e++)t[e] = t[e + 1]; t.pop() } function L3(t) { for (var e = new Array(t.length), r = 0; r < e.length; ++r)e[r] = t[r].listener || t[r]; return e } function H3(t, e) { return new Promise(function (r, i) { function n(h) { t.removeListener(e, f), i(h) } function f() { typeof t.removeListener == "function" && t.removeListener("error", n), r([].slice.call(arguments)) } qd(t, e, f, { once: !0 }), e !== "error" && j3(t, n, { once: !0 }) }) } function j3(t, e, r) { typeof t.on == "function" && qd(t, "error", e, r) } function qd(t, e, r, i) { if (typeof t.on == "function") i.once ? t.once(e, r) : t.on(e, r); else if (typeof t.addEventListener == "function") t.addEventListener(e, function n(f) { i.once && t.removeEventListener(e, n), r(f) }); else throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof t) } }); var Th = I((lE, kd) => { kd.exports = ns().EventEmitter }); var qh = I((pE, Pd) => { "use strict"; Pd.exports = function () { if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function") return !1; if (typeof Symbol.iterator == "symbol") return !0; var e = {}, r = Symbol("test"), i = Object(r); if (typeof r == "string" || Object.prototype.toString.call(r) !== "[object Symbol]" || Object.prototype.toString.call(i) !== "[object Symbol]") return !1; var n = 42; e[r] = n; for (r in e) return !1; if (typeof Object.keys == "function" && Object.keys(e).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(e).length !== 0) return !1; var f = Object.getOwnPropertySymbols(e); if (f.length !== 1 || f[0] !== r || !Object.prototype.propertyIsEnumerable.call(e, r)) return !1; if (typeof Object.getOwnPropertyDescriptor == "function") { var h = Object.getOwnPropertyDescriptor(e, r); if (h.value !== n || h.enumerable !== !0) return !1 } return !0 } }); var za = I((vE, Cd) => { "use strict"; var z3 = qh(); Cd.exports = function () { return z3() && !!Symbol.toStringTag } }); var Fd = I((bE, Dd) => { "use strict"; var Od = typeof Symbol != "undefined" && Symbol, W3 = qh(); Dd.exports = function () { return typeof Od != "function" || typeof Symbol != "function" || typeof Od("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? !1 : W3() } }); var Nd = I((yE, Ud) => { "use strict"; var K3 = "Function.prototype.bind called on incompatible ", kh = Array.prototype.slice, V3 = Object.prototype.toString, G3 = "[object Function]"; Ud.exports = function (e) { var r = this; if (typeof r != "function" || V3.call(r) !== G3) throw new TypeError(K3 + r); for (var i = kh.call(arguments, 1), n, f = function () { if (this instanceof n) { var M = r.apply(this, i.concat(kh.call(arguments))); return Object(M) === M ? M : this } else return r.apply(e, i.concat(kh.call(arguments))) }, h = Math.max(0, r.length - i.length), c = [], y = 0; y < h; y++)c.push("$" + y); if (n = Function("binder", "return function (" + c.join(",") + "){ return binder.apply(this,arguments); }")(f), r.prototype) { var x = function () { }; x.prototype = r.prototype, n.prototype = new x, x.prototype = null } return n } }); var as = I((mE, Ld) => { "use strict"; var $3 = Nd(); Ld.exports = Function.prototype.bind || $3 }); var jd = I((gE, Hd) => { "use strict"; var X3 = as(); Hd.exports = X3.call(Function.call, Object.prototype.hasOwnProperty) }); var hs = I((wE, Vd) => { "use strict"; var Ue, Wa = SyntaxError, zd = Function, Yn = TypeError, Ph = function (t) { try { return zd('"use strict"; return (' + t + ").constructor;")() } catch (e) { } }, fn = Object.getOwnPropertyDescriptor; if (fn) try { fn({}, "") } catch (t) { fn = null } var Ch = function () { throw new Yn }, Y3 = fn ? function () { try { return arguments.callee, Ch } catch (t) { try { return fn(arguments, "callee").get } catch (e) { return Ch } } }() : Ch, Zn = Fd()(), Ci = Object.getPrototypeOf || function (t) { return t.__proto__ }, Jn = {}, Z3 = typeof Uint8Array == "undefined" ? Ue : Ci(Uint8Array), Qn = { "%AggregateError%": typeof AggregateError == "undefined" ? Ue : AggregateError, "%Array%": Array, "%ArrayBuffer%": typeof ArrayBuffer == "undefined" ? Ue : ArrayBuffer, "%ArrayIteratorPrototype%": Zn ? Ci([][Symbol.iterator]()) : Ue, "%AsyncFromSyncIteratorPrototype%": Ue, "%AsyncFunction%": Jn, "%AsyncGenerator%": Jn, "%AsyncGeneratorFunction%": Jn, "%AsyncIteratorPrototype%": Jn, "%Atomics%": typeof Atomics == "undefined" ? Ue : Atomics, "%BigInt%": typeof BigInt == "undefined" ? Ue : BigInt, "%Boolean%": Boolean, "%DataView%": typeof DataView == "undefined" ? Ue : DataView, "%Date%": Date, "%decodeURI%": decodeURI, "%decodeURIComponent%": decodeURIComponent, "%encodeURI%": encodeURI, "%encodeURIComponent%": encodeURIComponent, "%Error%": Error, "%eval%": eval, "%EvalError%": EvalError, "%Float32Array%": typeof Float32Array == "undefined" ? Ue : Float32Array, "%Float64Array%": typeof Float64Array == "undefined" ? Ue : Float64Array, "%FinalizationRegistry%": typeof FinalizationRegistry == "undefined" ? Ue : FinalizationRegistry, "%Function%": zd, "%GeneratorFunction%": Jn, "%Int8Array%": typeof Int8Array == "undefined" ? Ue : Int8Array, "%Int16Array%": typeof Int16Array == "undefined" ? Ue : Int16Array, "%Int32Array%": typeof Int32Array == "undefined" ? Ue : Int32Array, "%isFinite%": isFinite, "%isNaN%": isNaN, "%IteratorPrototype%": Zn ? Ci(Ci([][Symbol.iterator]())) : Ue, "%JSON%": typeof JSON == "object" ? JSON : Ue, "%Map%": typeof Map == "undefined" ? Ue : Map, "%MapIteratorPrototype%": typeof Map == "undefined" || !Zn ? Ue : Ci(new Map()[Symbol.iterator]()), "%Math%": Math, "%Number%": Number, "%Object%": Object, "%parseFloat%": parseFloat, "%parseInt%": parseInt, "%Promise%": typeof Promise == "undefined" ? Ue : Promise, "%Proxy%": typeof Proxy == "undefined" ? Ue : Proxy, "%RangeError%": RangeError, "%ReferenceError%": ReferenceError, "%Reflect%": typeof Reflect == "undefined" ? Ue : Reflect, "%RegExp%": RegExp, "%Set%": typeof Set == "undefined" ? Ue : Set, "%SetIteratorPrototype%": typeof Set == "undefined" || !Zn ? Ue : Ci(new Set()[Symbol.iterator]()), "%SharedArrayBuffer%": typeof SharedArrayBuffer == "undefined" ? Ue : SharedArrayBuffer, "%String%": String, "%StringIteratorPrototype%": Zn ? Ci(""[Symbol.iterator]()) : Ue, "%Symbol%": Zn ? Symbol : Ue, "%SyntaxError%": Wa, "%ThrowTypeError%": Y3, "%TypedArray%": Z3, "%TypeError%": Yn, "%Uint8Array%": typeof Uint8Array == "undefined" ? Ue : Uint8Array, "%Uint8ClampedArray%": typeof Uint8ClampedArray == "undefined" ? Ue : Uint8ClampedArray, "%Uint16Array%": typeof Uint16Array == "undefined" ? Ue : Uint16Array, "%Uint32Array%": typeof Uint32Array == "undefined" ? Ue : Uint32Array, "%URIError%": URIError, "%WeakMap%": typeof WeakMap == "undefined" ? Ue : WeakMap, "%WeakRef%": typeof WeakRef == "undefined" ? Ue : WeakRef, "%WeakSet%": typeof WeakSet == "undefined" ? Ue : WeakSet }, J3 = function t(e) { var r; if (e === "%AsyncFunction%") r = Ph("async function () {}"); else if (e === "%GeneratorFunction%") r = Ph("function* () {}"); else if (e === "%AsyncGeneratorFunction%") r = Ph("async function* () {}"); else if (e === "%AsyncGenerator%") { var i = t("%AsyncGeneratorFunction%"); i && (r = i.prototype) } else if (e === "%AsyncIteratorPrototype%") { var n = t("%AsyncGenerator%"); n && (r = Ci(n.prototype)) } return Qn[e] = r, r }, Wd = { "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"], "%ArrayPrototype%": ["Array", "prototype"], "%ArrayProto_entries%": ["Array", "prototype", "entries"], "%ArrayProto_forEach%": ["Array", "prototype", "forEach"], "%ArrayProto_keys%": ["Array", "prototype", "keys"], "%ArrayProto_values%": ["Array", "prototype", "values"], "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"], "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"], "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"], "%BooleanPrototype%": ["Boolean", "prototype"], "%DataViewPrototype%": ["DataView", "prototype"], "%DatePrototype%": ["Date", "prototype"], "%ErrorPrototype%": ["Error", "prototype"], "%EvalErrorPrototype%": ["EvalError", "prototype"], "%Float32ArrayPrototype%": ["Float32Array", "prototype"], "%Float64ArrayPrototype%": ["Float64Array", "prototype"], "%FunctionPrototype%": ["Function", "prototype"], "%Generator%": ["GeneratorFunction", "prototype"], "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"], "%Int8ArrayPrototype%": ["Int8Array", "prototype"], "%Int16ArrayPrototype%": ["Int16Array", "prototype"], "%Int32ArrayPrototype%": ["Int32Array", "prototype"], "%JSONParse%": ["JSON", "parse"], "%JSONStringify%": ["JSON", "stringify"], "%MapPrototype%": ["Map", "prototype"], "%NumberPrototype%": ["Number", "prototype"], "%ObjectPrototype%": ["Object", "prototype"], "%ObjProto_toString%": ["Object", "prototype", "toString"], "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"], "%PromisePrototype%": ["Promise", "prototype"], "%PromiseProto_then%": ["Promise", "prototype", "then"], "%Promise_all%": ["Promise", "all"], "%Promise_reject%": ["Promise", "reject"], "%Promise_resolve%": ["Promise", "resolve"], "%RangeErrorPrototype%": ["RangeError", "prototype"], "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"], "%RegExpPrototype%": ["RegExp", "prototype"], "%SetPrototype%": ["Set", "prototype"], "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"], "%StringPrototype%": ["String", "prototype"], "%SymbolPrototype%": ["Symbol", "prototype"], "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"], "%TypedArrayPrototype%": ["TypedArray", "prototype"], "%TypeErrorPrototype%": ["TypeError", "prototype"], "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"], "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"], "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"], "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"], "%URIErrorPrototype%": ["URIError", "prototype"], "%WeakMapPrototype%": ["WeakMap", "prototype"], "%WeakSetPrototype%": ["WeakSet", "prototype"] }, fs = as(), ss = jd(), Q3 = fs.call(Function.call, Array.prototype.concat), eg = fs.call(Function.apply, Array.prototype.splice), Kd = fs.call(Function.call, String.prototype.replace), os = fs.call(Function.call, String.prototype.slice), tg = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, rg = /\\(\\)?/g, ig = function (e) { var r = os(e, 0, 1), i = os(e, -1); if (r === "%" && i !== "%") throw new Wa("invalid intrinsic syntax, expected closing `%`"); if (i === "%" && r !== "%") throw new Wa("invalid intrinsic syntax, expected opening `%`"); var n = []; return Kd(e, tg, function (f, h, c, y) { n[n.length] = c ? Kd(y, rg, "$1") : h || f }), n }, ng = function (e, r) { var i = e, n; if (ss(Wd, i) && (n = Wd[i], i = "%" + n[0] + "%"), ss(Qn, i)) { var f = Qn[i]; if (f === Jn && (f = J3(i)), typeof f == "undefined" && !r) throw new Yn("intrinsic " + e + " exists, but is not available. Please file an issue!"); return { alias: n, name: i, value: f } } throw new Wa("intrinsic " + e + " does not exist!") }; Vd.exports = function (e, r) { if (typeof e != "string" || e.length === 0) throw new Yn("intrinsic name must be a non-empty string"); if (arguments.length > 1 && typeof r != "boolean") throw new Yn('"allowMissing" argument must be a boolean'); var i = ig(e), n = i.length > 0 ? i[0] : "", f = ng("%" + n + "%", r), h = f.name, c = f.value, y = !1, x = f.alias; x && (n = x[0], eg(i, Q3([0, 1], x))); for (var M = 1, E = !0; M < i.length; M += 1) { var A = i[M], B = os(A, 0, 1), T = os(A, -1); if ((B === '"' || B === "'" || B === "`" || T === '"' || T === "'" || T === "`") && B !== T) throw new Wa("property names with quotes must have matching quotes"); if ((A === "constructor" || !E) && (y = !0), n += "." + A, h = "%" + n + "%", ss(Qn, h)) c = Qn[h]; else if (c != null) { if (!(A in c)) { if (!r) throw new Yn("base intrinsic for " + e + " exists, but the property is not available."); return } if (fn && M + 1 >= i.length) { var C = fn(c, A); E = !!C, E && "get" in C && !("originalValue" in C.get) ? c = C.get : c = c[A] } else E = ss(c, A), c = c[A]; E && !y && (Qn[h] = c) } } return c } }); var Jd = I((_E, us) => { "use strict"; var Oh = as(), ea = hs(), Gd = ea("%Function.prototype.apply%"), $d = ea("%Function.prototype.call%"), Xd = ea("%Reflect.apply%", !0) || Oh.call($d, Gd), Yd = ea("%Object.getOwnPropertyDescriptor%", !0), sn = ea("%Object.defineProperty%", !0), ag = ea("%Math.max%"); if (sn) try { sn({}, "a", { value: 1 }) } catch (t) { sn = null } us.exports = function (e) { var r = Xd(Oh, $d, arguments); if (Yd && sn) { var i = Yd(r, "length"); i.configurable && sn(r, "length", { value: 1 + ag(0, e.length - (arguments.length - 1)) }) } return r }; var Zd = function () { return Xd(Oh, Gd, arguments) }; sn ? sn(us.exports, "apply", { value: Zd }) : us.exports.apply = Zd }); var cs = I((xE, tl) => { "use strict"; var Qd = hs(), el = Jd(), fg = el(Qd("String.prototype.indexOf")); tl.exports = function (e, r) { var i = Qd(e, !!r); return typeof i == "function" && fg(e, ".prototype.") > -1 ? el(i) : i } }); var nl = I((ME, il) => { "use strict"; var sg = za()(), og = cs(), Dh = og("Object.prototype.toString"), ds = function (e) { return sg && e && typeof e == "object" && Symbol.toStringTag in e ? !1 : Dh(e) === "[object Arguments]" }, rl = function (e) { return ds(e) ? !0 : e !== null && typeof e == "object" && typeof e.length == "number" && e.length >= 0 && Dh(e) !== "[object Array]" && Dh(e.callee) === "[object Function]" }, hg = function () { return ds(arguments) }(); ds.isLegacyArguments = rl; il.exports = hg ? ds : rl }); var sl = I((SE, fl) => { "use strict"; var ug = Object.prototype.toString, cg = Function.prototype.toString, dg = /^\s*(?:function)?\*/, al = za()(), Fh = Object.getPrototypeOf, lg = function () { if (!al) return !1; try { return Function("return function*() {}")() } catch (t) { } }, Uh; fl.exports = function (e) { if (typeof e != "function") return !1; if (dg.test(cg.call(e))) return !0; if (!al) { var r = ug.call(e); return r === "[object GeneratorFunction]" } if (!Fh) return !1; if (typeof Uh == "undefined") { var i = lg(); Uh = i ? Fh(i) : !1 } return Fh(e) === Uh } }); var Nh = I((EE, ol) => { var pg = Object.prototype.hasOwnProperty, vg = Object.prototype.toString; ol.exports = function (e, r, i) { if (vg.call(r) !== "[object Function]") throw new TypeError("iterator must be a function"); var n = e.length; if (n === +n) for (var f = 0; f < n; f++)r.call(i, e[f], f, e); else for (var h in e) pg.call(e, h) && r.call(i, e[h], h, e) } }); var Hh = I((AE, hl) => { "use strict"; var Lh = ["BigInt64Array", "BigUint64Array", "Float32Array", "Float64Array", "Int16Array", "Int32Array", "Int8Array", "Uint16Array", "Uint32Array", "Uint8Array", "Uint8ClampedArray"], bg = typeof globalThis == "undefined" ? window : globalThis; hl.exports = function () { for (var e = [], r = 0; r < Lh.length; r++)typeof bg[Lh[r]] == "function" && (e[e.length] = Lh[r]); return e } }); var jh = I((BE, ul) => { "use strict"; var yg = hs(), ls = yg("%Object.getOwnPropertyDescriptor%", !0); if (ls) try { ls([], "length") } catch (t) { ls = null } ul.exports = ls }); var Kh = I((IE, vl) => { "use strict"; var cl = Nh(), mg = Hh(), zh = cs(), gg = zh("Object.prototype.toString"), dl = za()(), wg = typeof globalThis == "undefined" ? window : globalThis, ll = mg(), _g = zh("Array.prototype.indexOf", !0) || function (e, r) { for (var i = 0; i < e.length; i += 1)if (e[i] === r) return i; return -1 }, xg = zh("String.prototype.slice"), pl = {}, ps = jh(), Wh = Object.getPrototypeOf; dl && ps && Wh && cl(ll, function (t) { var e = new wg[t]; if (Symbol.toStringTag in e) { var r = Wh(e), i = ps(r, Symbol.toStringTag); if (!i) { var n = Wh(r); i = ps(n, Symbol.toStringTag) } pl[t] = i.get } }); var Mg = function (e) { var r = !1; return cl(pl, function (i, n) { if (!r) try { r = i.call(e) === n } catch (f) { } }), r }; vl.exports = function (e) { if (!e || typeof e != "object") return !1; if (!dl || !(Symbol.toStringTag in e)) { var r = xg(gg(e), 8, -1); return _g(ll, r) > -1 } return ps ? Mg(e) : !1 } }); var xl = I((RE, _l) => { "use strict"; var bl = Nh(), Sg = Hh(), yl = cs(), Eg = yl("Object.prototype.toString"), ml = za()(), gl = typeof globalThis == "undefined" ? window : globalThis, Ag = Sg(), Bg = yl("String.prototype.slice"), wl = {}, Vh = jh(), Gh = Object.getPrototypeOf; ml && Vh && Gh && bl(Ag, function (t) { if (typeof gl[t] == "function") { var e = new gl[t]; if (Symbol.toStringTag in e) { var r = Gh(e), i = Vh(r, Symbol.toStringTag); if (!i) { var n = Gh(r); i = Vh(n, Symbol.toStringTag) } wl[t] = i.get } } }); var Ig = function (e) { var r = !1; return bl(wl, function (i, n) { if (!r) try { var f = i.call(e); f === n && (r = f) } catch (h) { } }), r }, Rg = Kh(); _l.exports = function (e) { return Rg(e) ? !ml || !(Symbol.toStringTag in e) ? Bg(Eg(e), 8, -1) : Ig(e) : !1 } }); var Dl = I(Pe => { "use strict"; var Tg = nl(), qg = sl(), yr = xl(), Ml = Kh(); function ta(t) { return t.call.bind(t) } var Sl = typeof BigInt != "undefined", El = typeof Symbol != "undefined", Ft = ta(Object.prototype.toString), kg = ta(Number.prototype.valueOf), Pg = ta(String.prototype.valueOf), Cg = ta(Boolean.prototype.valueOf); Sl && (Al = ta(BigInt.prototype.valueOf)); var Al; El && (Bl = ta(Symbol.prototype.valueOf)); var Bl; function Ka(t, e) { if (typeof t != "object") return !1; try { return e(t), !0 } catch (r) { return !1 } } Pe.isArgumentsObject = Tg; Pe.isGeneratorFunction = qg; Pe.isTypedArray = Ml; function Og(t) { return typeof Promise != "undefined" && t instanceof Promise || t !== null && typeof t == "object" && typeof t.then == "function" && typeof t.catch == "function" } Pe.isPromise = Og; function Dg(t) { return typeof ArrayBuffer != "undefined" && ArrayBuffer.isView ? ArrayBuffer.isView(t) : Ml(t) || Rl(t) } Pe.isArrayBufferView = Dg; function Fg(t) { return yr(t) === "Uint8Array" } Pe.isUint8Array = Fg; function Ug(t) { return yr(t) === "Uint8ClampedArray" } Pe.isUint8ClampedArray = Ug; function Ng(t) { return yr(t) === "Uint16Array" } Pe.isUint16Array = Ng; function Lg(t) { return yr(t) === "Uint32Array" } Pe.isUint32Array = Lg; function Hg(t) { return yr(t) === "Int8Array" } Pe.isInt8Array = Hg; function jg(t) { return yr(t) === "Int16Array" } Pe.isInt16Array = jg; function zg(t) { return yr(t) === "Int32Array" } Pe.isInt32Array = zg; function Wg(t) { return yr(t) === "Float32Array" } Pe.isFloat32Array = Wg; function Kg(t) { return yr(t) === "Float64Array" } Pe.isFloat64Array = Kg; function Vg(t) { return yr(t) === "BigInt64Array" } Pe.isBigInt64Array = Vg; function Gg(t) { return yr(t) === "BigUint64Array" } Pe.isBigUint64Array = Gg; function vs(t) { return Ft(t) === "[object Map]" } vs.working = typeof Map != "undefined" && vs(new Map); function $g(t) { return typeof Map == "undefined" ? !1 : vs.working ? vs(t) : t instanceof Map } Pe.isMap = $g; function bs(t) { return Ft(t) === "[object Set]" } bs.working = typeof Set != "undefined" && bs(new Set); function Xg(t) { return typeof Set == "undefined" ? !1 : bs.working ? bs(t) : t instanceof Set } Pe.isSet = Xg; function ys(t) { return Ft(t) === "[object WeakMap]" } ys.working = typeof WeakMap != "undefined" && ys(new WeakMap); function Yg(t) { return typeof WeakMap == "undefined" ? !1 : ys.working ? ys(t) : t instanceof WeakMap } Pe.isWeakMap = Yg; function $h(t) { return Ft(t) === "[object WeakSet]" } $h.working = typeof WeakSet != "undefined" && $h(new WeakSet); function Zg(t) { return $h(t) } Pe.isWeakSet = Zg; function ms(t) { return Ft(t) === "[object ArrayBuffer]" } ms.working = typeof ArrayBuffer != "undefined" && ms(new ArrayBuffer); function Il(t) { return typeof ArrayBuffer == "undefined" ? !1 : ms.working ? ms(t) : t instanceof ArrayBuffer } Pe.isArrayBuffer = Il; function gs(t) { return Ft(t) === "[object DataView]" } gs.working = typeof ArrayBuffer != "undefined" && typeof DataView != "undefined" && gs(new DataView(new ArrayBuffer(1), 0, 1)); function Rl(t) { return typeof DataView == "undefined" ? !1 : gs.working ? gs(t) : t instanceof DataView } Pe.isDataView = Rl; var Xh = typeof SharedArrayBuffer != "undefined" ? SharedArrayBuffer : void 0; function Va(t) { return Ft(t) === "[object SharedArrayBuffer]" } function Tl(t) { return typeof Xh == "undefined" ? !1 : (typeof Va.working == "undefined" && (Va.working = Va(new Xh)), Va.working ? Va(t) : t instanceof Xh) } Pe.isSharedArrayBuffer = Tl; function Jg(t) { return Ft(t) === "[object AsyncFunction]" } Pe.isAsyncFunction = Jg; function Qg(t) { return Ft(t) === "[object Map Iterator]" } Pe.isMapIterator = Qg; function e4(t) { return Ft(t) === "[object Set Iterator]" } Pe.isSetIterator = e4; function t4(t) { return Ft(t) === "[object Generator]" } Pe.isGeneratorObject = t4; function r4(t) { return Ft(t) === "[object WebAssembly.Module]" } Pe.isWebAssemblyCompiledModule = r4; function ql(t) { return Ka(t, kg) } Pe.isNumberObject = ql; function kl(t) { return Ka(t, Pg) } Pe.isStringObject = kl; function Pl(t) { return Ka(t, Cg) } Pe.isBooleanObject = Pl; function Cl(t) { return Sl && Ka(t, Al) } Pe.isBigIntObject = Cl; function Ol(t) { return El && Ka(t, Bl) } Pe.isSymbolObject = Ol; function i4(t) { return ql(t) || kl(t) || Pl(t) || Cl(t) || Ol(t) } Pe.isBoxedPrimitive = i4; function n4(t) { return typeof Uint8Array != "undefined" && (Il(t) || Tl(t)) } Pe.isAnyArrayBuffer = n4;["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function (t) { Object.defineProperty(Pe, t, { enumerable: !1, value: function () { throw new Error(t + " is not supported in userland") } }) }) }); var Ul = I((qE, Fl) => { Fl.exports = function (e) { return e && typeof e == "object" && typeof e.copy == "function" && typeof e.fill == "function" && typeof e.readUInt8 == "function" } }); var As = I(Ce => {
          var Nl = Object.getOwnPropertyDescriptors || function (e) { for (var r = Object.keys(e), i = {}, n = 0; n < r.length; n++)i[r[n]] = Object.getOwnPropertyDescriptor(e, r[n]); return i }, a4 = /%[sdj%]/g; Ce.format = function (t) { if (!Ms(t)) { for (var e = [], r = 0; r < arguments.length; r++)e.push(Oi(arguments[r])); return e.join(" ") } for (var r = 1, i = arguments, n = i.length, f = String(t).replace(a4, function (c) { if (c === "%%") return "%"; if (r >= n) return c; switch (c) { case "%s": return String(i[r++]); case "%d": return Number(i[r++]); case "%j": try { return JSON.stringify(i[r++]) } catch (y) { return "[Circular]" } default: return c } }), h = i[r]; r < n; h = i[++r])xs(h) || !ra(h) ? f += " " + h : f += " " + Oi(h); return f }; Ce.deprecate = function (t, e) { if (typeof process != "undefined" && process.noDeprecation === !0) return t; if (typeof process == "undefined") return function () { return Ce.deprecate(t, e).apply(this, arguments) }; var r = !1; function i() { if (!r) { if (process.throwDeprecation) throw new Error(e); process.traceDeprecation ? console.trace(e) : console.error(e), r = !0 } return t.apply(this, arguments) } return i }; var ws = {}, f4 = /^$/; Ce.debuglog = function (t) { if (t = t.toUpperCase(), !ws[t]) if (f4.test(t)) { var e = process.pid; ws[t] = function () { var r = Ce.format.apply(Ce, arguments); console.error("%s %d: %s", t, e, r) } } else ws[t] = function () { }; return ws[t] }; function Oi(t, e) { var r = { seen: [], stylize: o4 }; return arguments.length >= 3 && (r.depth = arguments[2]), arguments.length >= 4 && (r.colors = arguments[3]), Jh(e) ? r.showHidden = e : e && Ce._extend(r, e), on(r.showHidden) && (r.showHidden = !1), on(r.depth) && (r.depth = 2), on(r.colors) && (r.colors = !1), on(r.customInspect) && (r.customInspect = !0), r.colors && (r.stylize = s4), _s(r, t, r.depth) } Ce.inspect = Oi; Oi.colors = { bold: [1, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], white: [37, 39], grey: [90, 39], black: [30, 39], blue: [34, 39], cyan: [36, 39], green: [32, 39], magenta: [35, 39], red: [31, 39], yellow: [33, 39] }; Oi.styles = { special: "cyan", number: "yellow", boolean: "yellow", undefined: "grey", null: "bold", string: "green", date: "magenta", regexp: "red" }; function s4(t, e) { var r = Oi.styles[e]; return r ? "[" + Oi.colors[r][0] + "m" + t + "[" + Oi.colors[r][1] + "m" : t } function o4(t, e) { return t } function h4(t) { var e = {}; return t.forEach(function (r, i) { e[r] = !0 }), e } function _s(t, e, r) { if (t.customInspect && e && Es(e.inspect) && e.inspect !== Ce.inspect && !(e.constructor && e.constructor.prototype === e)) { var i = e.inspect(r, t); return Ms(i) || (i = _s(t, i, r)), i } var n = u4(t, e); if (n) return n; var f = Object.keys(e), h = h4(f); if (t.showHidden && (f = Object.getOwnPropertyNames(e)), $a(e) && (f.indexOf("message") >= 0 || f.indexOf("description") >= 0)) return Yh(e); if (f.length === 0) { if (Es(e)) { var c = e.name ? ": " + e.name : ""; return t.stylize("[Function" + c + "]", "special") } if (Ga(e)) return t.stylize(RegExp.prototype.toString.call(e), "regexp"); if (Ss(e)) return t.stylize(Date.prototype.toString.call(e), "date"); if ($a(e)) return Yh(e) } var y = "", x = !1, M = ["{", "}"]; if (Ll(e) && (x = !0, M = ["[", "]"]), Es(e)) { var E = e.name ? ": " + e.name : ""; y = " [Function" + E + "]" } if (Ga(e) && (y = " " + RegExp.prototype.toString.call(e)), Ss(e) && (y = " " + Date.prototype.toUTCString.call(e)), $a(e) && (y = " " + Yh(e)), f.length === 0 && (!x || e.length == 0)) return M[0] + y + M[1]; if (r < 0) return Ga(e) ? t.stylize(RegExp.prototype.toString.call(e), "regexp") : t.stylize("[Object]", "special"); t.seen.push(e); var A; return x ? A = c4(t, e, r, h, f) : A = f.map(function (B) { return Zh(t, e, r, h, B, x) }), t.seen.pop(), d4(A, y, M) } function u4(t, e) { if (on(e)) return t.stylize("undefined", "undefined"); if (Ms(e)) { var r = "'" + JSON.stringify(e).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'"; return t.stylize(r, "string") } if (Hl(e)) return t.stylize("" + e, "number"); if (Jh(e)) return t.stylize("" + e, "boolean"); if (xs(e)) return t.stylize("null", "null") } function Yh(t) { return "[" + Error.prototype.toString.call(t) + "]" } function c4(t, e, r, i, n) { for (var f = [], h = 0, c = e.length; h < c; ++h)jl(e, String(h)) ? f.push(Zh(t, e, r, i, String(h), !0)) : f.push(""); return n.forEach(function (y) { y.match(/^\d+$/) || f.push(Zh(t, e, r, i, y, !0)) }), f } function Zh(t, e, r, i, n, f) {
            var h, c, y; if (y = Object.getOwnPropertyDescriptor(e, n) || { value: e[n] }, y.get ? y.set ? c = t.stylize("[Getter/Setter]", "special") : c = t.stylize("[Getter]", "special") : y.set && (c = t.stylize("[Setter]", "special")), jl(i, n) || (h = "[" + n + "]"), c || (t.seen.indexOf(y.value) < 0 ? (xs(r) ? c = _s(t, y.value, null) : c = _s(t, y.value, r - 1), c.indexOf(`
`) > -1 && (f ? c = c.split(`
`).map(function (x) { return "  " + x }).join(`
`).substr(2) : c = `
`+ c.split(`
`).map(function (x) { return "   " + x }).join(`
`))) : c = t.stylize("[Circular]", "special")), on(h)) { if (f && n.match(/^\d+$/)) return c; h = JSON.stringify("" + n), h.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (h = h.substr(1, h.length - 2), h = t.stylize(h, "name")) : (h = h.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), h = t.stylize(h, "string")) } return h + ": " + c
          } function d4(t, e, r) {
            var i = 0, n = t.reduce(function (f, h) {
              return i++, h.indexOf(`
`) >= 0 && i++, f + h.replace(/\u001b\[\d\d?m/g, "").length + 1
            }, 0); return n > 60 ? r[0] + (e === "" ? "" : e + `
 `) + " " + t.join(`,
  `) + " " + r[1] : r[0] + e + " " + t.join(", ") + " " + r[1]
          } Ce.types = Dl(); function Ll(t) { return Array.isArray(t) } Ce.isArray = Ll; function Jh(t) { return typeof t == "boolean" } Ce.isBoolean = Jh; function xs(t) { return t === null } Ce.isNull = xs; function l4(t) { return t == null } Ce.isNullOrUndefined = l4; function Hl(t) { return typeof t == "number" } Ce.isNumber = Hl; function Ms(t) { return typeof t == "string" } Ce.isString = Ms; function p4(t) { return typeof t == "symbol" } Ce.isSymbol = p4; function on(t) { return t === void 0 } Ce.isUndefined = on; function Ga(t) { return ra(t) && Qh(t) === "[object RegExp]" } Ce.isRegExp = Ga; Ce.types.isRegExp = Ga; function ra(t) { return typeof t == "object" && t !== null } Ce.isObject = ra; function Ss(t) { return ra(t) && Qh(t) === "[object Date]" } Ce.isDate = Ss; Ce.types.isDate = Ss; function $a(t) { return ra(t) && (Qh(t) === "[object Error]" || t instanceof Error) } Ce.isError = $a; Ce.types.isNativeError = $a; function Es(t) { return typeof t == "function" } Ce.isFunction = Es; function v4(t) { return t === null || typeof t == "boolean" || typeof t == "number" || typeof t == "string" || typeof t == "symbol" || typeof t == "undefined" } Ce.isPrimitive = v4; Ce.isBuffer = Ul(); function Qh(t) { return Object.prototype.toString.call(t) } function e0(t) { return t < 10 ? "0" + t.toString(10) : t.toString(10) } var b4 = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]; function y4() { var t = new Date, e = [e0(t.getHours()), e0(t.getMinutes()), e0(t.getSeconds())].join(":"); return [t.getDate(), b4[t.getMonth()], e].join(" ") } Ce.log = function () { console.log("%s - %s", y4(), Ce.format.apply(Ce, arguments)) }; Ce.inherits = Re(); Ce._extend = function (t, e) { if (!e || !ra(e)) return t; for (var r = Object.keys(e), i = r.length; i--;)t[r[i]] = e[r[i]]; return t }; function jl(t, e) { return Object.prototype.hasOwnProperty.call(t, e) } var hn = typeof Symbol != "undefined" ? Symbol("util.promisify.custom") : void 0; Ce.promisify = function (e) { if (typeof e != "function") throw new TypeError('The "original" argument must be of type Function'); if (hn && e[hn]) { var r = e[hn]; if (typeof r != "function") throw new TypeError('The "util.promisify.custom" argument must be of type Function'); return Object.defineProperty(r, hn, { value: r, enumerable: !1, writable: !1, configurable: !0 }), r } function r() { for (var i, n, f = new Promise(function (y, x) { i = y, n = x }), h = [], c = 0; c < arguments.length; c++)h.push(arguments[c]); h.push(function (y, x) { y ? n(y) : i(x) }); try { e.apply(this, h) } catch (y) { n(y) } return f } return Object.setPrototypeOf(r, Object.getPrototypeOf(e)), hn && Object.defineProperty(r, hn, { value: r, enumerable: !1, writable: !1, configurable: !0 }), Object.defineProperties(r, Nl(e)) }; Ce.promisify.custom = hn; function m4(t, e) { if (!t) { var r = new Error("Promise was rejected with a falsy value"); r.reason = t, t = r } return e(t) } function g4(t) { if (typeof t != "function") throw new TypeError('The "original" argument must be of type Function'); function e() { for (var r = [], i = 0; i < arguments.length; i++)r.push(arguments[i]); var n = r.pop(); if (typeof n != "function") throw new TypeError("The last argument must be of type Function"); var f = this, h = function () { return n.apply(f, arguments) }; t.apply(this, r).then(function (c) { process.nextTick(h.bind(null, null, c)) }, function (c) { process.nextTick(m4.bind(null, c, h)) }) } return Object.setPrototypeOf(e, Object.getPrototypeOf(t)), Object.defineProperties(e, Nl(t)), e } Ce.callbackify = g4
        }); var Vl = I((PE, Kl) => { "use strict"; function zl(t, e) { var r = Object.keys(t); if (Object.getOwnPropertySymbols) { var i = Object.getOwnPropertySymbols(t); e && (i = i.filter(function (n) { return Object.getOwnPropertyDescriptor(t, n).enumerable })), r.push.apply(r, i) } return r } function w4(t) { for (var e = 1; e < arguments.length; e++) { var r = arguments[e] != null ? arguments[e] : {}; e % 2 ? zl(Object(r), !0).forEach(function (i) { _4(t, i, r[i]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(r)) : zl(Object(r)).forEach(function (i) { Object.defineProperty(t, i, Object.getOwnPropertyDescriptor(r, i)) }) } return t } function _4(t, e, r) { return e in t ? Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = r, t } function x4(t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") } function Wl(t, e) { for (var r = 0; r < e.length; r++) { var i = e[r]; i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i) } } function M4(t, e, r) { return e && Wl(t.prototype, e), r && Wl(t, r), t } var S4 = ct(), Bs = S4.Buffer, E4 = As(), t0 = E4.inspect, A4 = t0 && t0.custom || "inspect"; function B4(t, e, r) { Bs.prototype.copy.call(t, e, r) } Kl.exports = function () { function t() { x4(this, t), this.head = null, this.tail = null, this.length = 0 } return M4(t, [{ key: "push", value: function (r) { var i = { data: r, next: null }; this.length > 0 ? this.tail.next = i : this.head = i, this.tail = i, ++this.length } }, { key: "unshift", value: function (r) { var i = { data: r, next: this.head }; this.length === 0 && (this.tail = i), this.head = i, ++this.length } }, { key: "shift", value: function () { if (this.length !== 0) { var r = this.head.data; return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, r } } }, { key: "clear", value: function () { this.head = this.tail = null, this.length = 0 } }, { key: "join", value: function (r) { if (this.length === 0) return ""; for (var i = this.head, n = "" + i.data; i = i.next;)n += r + i.data; return n } }, { key: "concat", value: function (r) { if (this.length === 0) return Bs.alloc(0); for (var i = Bs.allocUnsafe(r >>> 0), n = this.head, f = 0; n;)B4(n.data, i, f), f += n.data.length, n = n.next; return i } }, { key: "consume", value: function (r, i) { var n; return r < this.head.data.length ? (n = this.head.data.slice(0, r), this.head.data = this.head.data.slice(r)) : r === this.head.data.length ? n = this.shift() : n = i ? this._getString(r) : this._getBuffer(r), n } }, { key: "first", value: function () { return this.head.data } }, { key: "_getString", value: function (r) { var i = this.head, n = 1, f = i.data; for (r -= f.length; i = i.next;) { var h = i.data, c = r > h.length ? h.length : r; if (c === h.length ? f += h : f += h.slice(0, r), r -= c, r === 0) { c === h.length ? (++n, i.next ? this.head = i.next : this.head = this.tail = null) : (this.head = i, i.data = h.slice(c)); break } ++n } return this.length -= n, f } }, { key: "_getBuffer", value: function (r) { var i = Bs.allocUnsafe(r), n = this.head, f = 1; for (n.data.copy(i), r -= n.data.length; n = n.next;) { var h = n.data, c = r > h.length ? h.length : r; if (h.copy(i, i.length - r, 0, c), r -= c, r === 0) { c === h.length ? (++f, n.next ? this.head = n.next : this.head = this.tail = null) : (this.head = n, n.data = h.slice(c)); break } ++f } return this.length -= f, i } }, { key: A4, value: function (r, i) { return t0(this, w4({}, i, { depth: 0, customInspect: !1 })) } }]), t }() }); var i0 = I((CE, $l) => { "use strict"; function I4(t, e) { var r = this, i = this._readableState && this._readableState.destroyed, n = this._writableState && this._writableState.destroyed; return i || n ? (e ? e(t) : t && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, process.nextTick(r0, this, t)) : process.nextTick(r0, this, t)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(t || null, function (f) { !e && f ? r._writableState ? r._writableState.errorEmitted ? process.nextTick(Is, r) : (r._writableState.errorEmitted = !0, process.nextTick(Gl, r, f)) : process.nextTick(Gl, r, f) : e ? (process.nextTick(Is, r), e(f)) : process.nextTick(Is, r) }), this) } function Gl(t, e) { r0(t, e), Is(t) } function Is(t) { t._writableState && !t._writableState.emitClose || t._readableState && !t._readableState.emitClose || t.emit("close") } function R4() { this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1) } function r0(t, e) { t.emit("error", e) } function T4(t, e) { var r = t._readableState, i = t._writableState; r && r.autoDestroy || i && i.autoDestroy ? t.destroy(e) : t.emit("error", e) } $l.exports = { destroy: I4, undestroy: R4, errorOrDestroy: T4 } }); var un = I((OE, Zl) => { "use strict"; function q4(t, e) { t.prototype = Object.create(e.prototype), t.prototype.constructor = t, t.__proto__ = e } var Xl = {}; function Ut(t, e, r) { r || (r = Error); function i(f, h, c) { return typeof e == "string" ? e : e(f, h, c) } var n = function (f) { q4(h, f); function h(c, y, x) { return f.call(this, i(c, y, x)) || this } return h }(r); n.prototype.name = r.name, n.prototype.code = t, Xl[t] = n } function Yl(t, e) { if (Array.isArray(t)) { var r = t.length; return t = t.map(function (i) { return String(i) }), r > 2 ? "one of ".concat(e, " ").concat(t.slice(0, r - 1).join(", "), ", or ") + t[r - 1] : r === 2 ? "one of ".concat(e, " ").concat(t[0], " or ").concat(t[1]) : "of ".concat(e, " ").concat(t[0]) } else return "of ".concat(e, " ").concat(String(t)) } function k4(t, e, r) { return t.substr(!r || r < 0 ? 0 : +r, e.length) === e } function P4(t, e, r) { return (r === void 0 || r > t.length) && (r = t.length), t.substring(r - e.length, r) === e } function C4(t, e, r) { return typeof r != "number" && (r = 0), r + e.length > t.length ? !1 : t.indexOf(e, r) !== -1 } Ut("ERR_INVALID_OPT_VALUE", function (t, e) { return 'The value "' + e + '" is invalid for option "' + t + '"' }, TypeError); Ut("ERR_INVALID_ARG_TYPE", function (t, e, r) { var i; typeof e == "string" && k4(e, "not ") ? (i = "must not be", e = e.replace(/^not /, "")) : i = "must be"; var n; if (P4(t, " argument")) n = "The ".concat(t, " ").concat(i, " ").concat(Yl(e, "type")); else { var f = C4(t, ".") ? "property" : "argument"; n = 'The "'.concat(t, '" ').concat(f, " ").concat(i, " ").concat(Yl(e, "type")) } return n += ". Received type ".concat(typeof r), n }, TypeError); Ut("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF"); Ut("ERR_METHOD_NOT_IMPLEMENTED", function (t) { return "The " + t + " method is not implemented" }); Ut("ERR_STREAM_PREMATURE_CLOSE", "Premature close"); Ut("ERR_STREAM_DESTROYED", function (t) { return "Cannot call " + t + " after a stream was destroyed" }); Ut("ERR_MULTIPLE_CALLBACK", "Callback called multiple times"); Ut("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable"); Ut("ERR_STREAM_WRITE_AFTER_END", "write after end"); Ut("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError); Ut("ERR_UNKNOWN_ENCODING", function (t) { return "Unknown encoding: " + t }, TypeError); Ut("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event"); Zl.exports.codes = Xl }); var n0 = I((DE, Jl) => { "use strict"; var O4 = un().codes.ERR_INVALID_OPT_VALUE; function D4(t, e, r) { return t.highWaterMark != null ? t.highWaterMark : e ? t[r] : null } function F4(t, e, r, i) { var n = D4(e, i, r); if (n != null) { if (!(isFinite(n) && Math.floor(n) === n) || n < 0) { var f = i ? r : "highWaterMark"; throw new O4(f, n) } return Math.floor(n) } return t.objectMode ? 16 : 16 * 1024 } Jl.exports = { getHighWaterMark: F4 } }); var ep = I((FE, Ql) => { Ql.exports = U4; function U4(t, e) { if (a0("noDeprecation")) return t; var r = !1; function i() { if (!r) { if (a0("throwDeprecation")) throw new Error(e); a0("traceDeprecation") ? console.trace(e) : console.warn(e), r = !0 } return t.apply(this, arguments) } return i } function a0(t) { try { if (!window.localStorage) return !1 } catch (r) { return !1 } var e = window.localStorage[t]; return e == null ? !1 : String(e).toLowerCase() === "true" } }); var qs = I((UE, fp) => { "use strict"; fp.exports = Ye; function tp(t) { var e = this; this.next = null, this.entry = null, this.finish = function () { c8(e, t) } } var ia; Ye.WritableState = Xa; var N4 = { deprecate: ep() }, rp = Th(), Rs = ct().Buffer, L4 = window.Uint8Array || function () { }; function H4(t) { return Rs.from(t) } function j4(t) { return Rs.isBuffer(t) || t instanceof L4 } var f0 = i0(), z4 = n0(), W4 = z4.getHighWaterMark, Di = un().codes, K4 = Di.ERR_INVALID_ARG_TYPE, V4 = Di.ERR_METHOD_NOT_IMPLEMENTED, G4 = Di.ERR_MULTIPLE_CALLBACK, $4 = Di.ERR_STREAM_CANNOT_PIPE, X4 = Di.ERR_STREAM_DESTROYED, Y4 = Di.ERR_STREAM_NULL_VALUES, Z4 = Di.ERR_STREAM_WRITE_AFTER_END, J4 = Di.ERR_UNKNOWN_ENCODING, na = f0.errorOrDestroy; Re()(Ye, rp); function Q4() { } function Xa(t, e, r) { ia = ia || Fi(), t = t || {}, typeof r != "boolean" && (r = e instanceof ia), this.objectMode = !!t.objectMode, r && (this.objectMode = this.objectMode || !!t.writableObjectMode), this.highWaterMark = W4(this, t, "writableHighWaterMark", r), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1; var i = t.decodeStrings === !1; this.decodeStrings = !i, this.defaultEncoding = t.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function (n) { f8(e, n) }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = t.emitClose !== !1, this.autoDestroy = !!t.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new tp(this) } Xa.prototype.getBuffer = function () { for (var e = this.bufferedRequest, r = []; e;)r.push(e), e = e.next; return r }; (function () { try { Object.defineProperty(Xa.prototype, "buffer", { get: N4.deprecate(function () { return this.getBuffer() }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003") }) } catch (t) { } })(); var Ts; typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (Ts = Function.prototype[Symbol.hasInstance], Object.defineProperty(Ye, Symbol.hasInstance, { value: function (e) { return Ts.call(this, e) ? !0 : this !== Ye ? !1 : e && e._writableState instanceof Xa } })) : Ts = function (e) { return e instanceof this }; function Ye(t) { ia = ia || Fi(); var e = this instanceof ia; if (!e && !Ts.call(Ye, this)) return new Ye(t); this._writableState = new Xa(t, this, e), this.writable = !0, t && (typeof t.write == "function" && (this._write = t.write), typeof t.writev == "function" && (this._writev = t.writev), typeof t.destroy == "function" && (this._destroy = t.destroy), typeof t.final == "function" && (this._final = t.final)), rp.call(this) } Ye.prototype.pipe = function () { na(this, new $4) }; function e8(t, e) { var r = new Z4; na(t, r), process.nextTick(e, r) } function t8(t, e, r, i) { var n; return r === null ? n = new Y4 : typeof r != "string" && !e.objectMode && (n = new K4("chunk", ["string", "Buffer"], r)), n ? (na(t, n), process.nextTick(i, n), !1) : !0 } Ye.prototype.write = function (t, e, r) { var i = this._writableState, n = !1, f = !i.objectMode && j4(t); return f && !Rs.isBuffer(t) && (t = H4(t)), typeof e == "function" && (r = e, e = null), f ? e = "buffer" : e || (e = i.defaultEncoding), typeof r != "function" && (r = Q4), i.ending ? e8(this, r) : (f || t8(this, i, t, r)) && (i.pendingcb++, n = i8(this, i, f, t, e, r)), n }; Ye.prototype.cork = function () { this._writableState.corked++ }; Ye.prototype.uncork = function () { var t = this._writableState; t.corked && (t.corked--, !t.writing && !t.corked && !t.bufferProcessing && t.bufferedRequest && np(this, t)) }; Ye.prototype.setDefaultEncoding = function (e) { if (typeof e == "string" && (e = e.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((e + "").toLowerCase()) > -1)) throw new J4(e); return this._writableState.defaultEncoding = e, this }; Object.defineProperty(Ye.prototype, "writableBuffer", { enumerable: !1, get: function () { return this._writableState && this._writableState.getBuffer() } }); function r8(t, e, r) { return !t.objectMode && t.decodeStrings !== !1 && typeof e == "string" && (e = Rs.from(e, r)), e } Object.defineProperty(Ye.prototype, "writableHighWaterMark", { enumerable: !1, get: function () { return this._writableState.highWaterMark } }); function i8(t, e, r, i, n, f) { if (!r) { var h = r8(e, i, n); i !== h && (r = !0, n = "buffer", i = h) } var c = e.objectMode ? 1 : i.length; e.length += c; var y = e.length < e.highWaterMark; if (y || (e.needDrain = !0), e.writing || e.corked) { var x = e.lastBufferedRequest; e.lastBufferedRequest = { chunk: i, encoding: n, isBuf: r, callback: f, next: null }, x ? x.next = e.lastBufferedRequest : e.bufferedRequest = e.lastBufferedRequest, e.bufferedRequestCount += 1 } else s0(t, e, !1, c, i, n, f); return y } function s0(t, e, r, i, n, f, h) { e.writelen = i, e.writecb = h, e.writing = !0, e.sync = !0, e.destroyed ? e.onwrite(new X4("write")) : r ? t._writev(n, e.onwrite) : t._write(n, f, e.onwrite), e.sync = !1 } function n8(t, e, r, i, n) { --e.pendingcb, r ? (process.nextTick(n, i), process.nextTick(Ya, t, e), t._writableState.errorEmitted = !0, na(t, i)) : (n(i), t._writableState.errorEmitted = !0, na(t, i), Ya(t, e)) } function a8(t) { t.writing = !1, t.writecb = null, t.length -= t.writelen, t.writelen = 0 } function f8(t, e) { var r = t._writableState, i = r.sync, n = r.writecb; if (typeof n != "function") throw new G4; if (a8(r), e) n8(t, r, i, e, n); else { var f = ap(r) || t.destroyed; !f && !r.corked && !r.bufferProcessing && r.bufferedRequest && np(t, r), i ? process.nextTick(ip, t, r, f, n) : ip(t, r, f, n) } } function ip(t, e, r, i) { r || s8(t, e), e.pendingcb--, i(), Ya(t, e) } function s8(t, e) { e.length === 0 && e.needDrain && (e.needDrain = !1, t.emit("drain")) } function np(t, e) { e.bufferProcessing = !0; var r = e.bufferedRequest; if (t._writev && r && r.next) { var i = e.bufferedRequestCount, n = new Array(i), f = e.corkedRequestsFree; f.entry = r; for (var h = 0, c = !0; r;)n[h] = r, r.isBuf || (c = !1), r = r.next, h += 1; n.allBuffers = c, s0(t, e, !0, e.length, n, "", f.finish), e.pendingcb++, e.lastBufferedRequest = null, f.next ? (e.corkedRequestsFree = f.next, f.next = null) : e.corkedRequestsFree = new tp(e), e.bufferedRequestCount = 0 } else { for (; r;) { var y = r.chunk, x = r.encoding, M = r.callback, E = e.objectMode ? 1 : y.length; if (s0(t, e, !1, E, y, x, M), r = r.next, e.bufferedRequestCount--, e.writing) break } r === null && (e.lastBufferedRequest = null) } e.bufferedRequest = r, e.bufferProcessing = !1 } Ye.prototype._write = function (t, e, r) { r(new V4("_write()")) }; Ye.prototype._writev = null; Ye.prototype.end = function (t, e, r) { var i = this._writableState; return typeof t == "function" ? (r = t, t = null, e = null) : typeof e == "function" && (r = e, e = null), t != null && this.write(t, e), i.corked && (i.corked = 1, this.uncork()), i.ending || u8(this, i, r), this }; Object.defineProperty(Ye.prototype, "writableLength", { enumerable: !1, get: function () { return this._writableState.length } }); function ap(t) { return t.ending && t.length === 0 && t.bufferedRequest === null && !t.finished && !t.writing } function o8(t, e) { t._final(function (r) { e.pendingcb--, r && na(t, r), e.prefinished = !0, t.emit("prefinish"), Ya(t, e) }) } function h8(t, e) { !e.prefinished && !e.finalCalled && (typeof t._final == "function" && !e.destroyed ? (e.pendingcb++, e.finalCalled = !0, process.nextTick(o8, t, e)) : (e.prefinished = !0, t.emit("prefinish"))) } function Ya(t, e) { var r = ap(e); if (r && (h8(t, e), e.pendingcb === 0 && (e.finished = !0, t.emit("finish"), e.autoDestroy))) { var i = t._readableState; (!i || i.autoDestroy && i.endEmitted) && t.destroy() } return r } function u8(t, e, r) { e.ending = !0, Ya(t, e), r && (e.finished ? process.nextTick(r) : t.once("finish", r)), e.ended = !0, t.writable = !1 } function c8(t, e, r) { var i = t.entry; for (t.entry = null; i;) { var n = i.callback; e.pendingcb--, n(r), i = i.next } e.corkedRequestsFree.next = t } Object.defineProperty(Ye.prototype, "destroyed", { enumerable: !1, get: function () { return this._writableState === void 0 ? !1 : this._writableState.destroyed }, set: function (e) { !this._writableState || (this._writableState.destroyed = e) } }); Ye.prototype.destroy = f0.destroy; Ye.prototype._undestroy = f0.undestroy; Ye.prototype._destroy = function (t, e) { e(t) } }); var Fi = I((NE, op) => { "use strict"; var d8 = Object.keys || function (t) { var e = []; for (var r in t) e.push(r); return e }; op.exports = kr; var sp = Cs(), o0 = qs(); Re()(kr, sp); for (h0 = d8(o0.prototype), ks = 0; ks < h0.length; ks++)Ps = h0[ks], kr.prototype[Ps] || (kr.prototype[Ps] = o0.prototype[Ps]); var h0, Ps, ks; function kr(t) { if (!(this instanceof kr)) return new kr(t); sp.call(this, t), o0.call(this, t), this.allowHalfOpen = !0, t && (t.readable === !1 && (this.readable = !1), t.writable === !1 && (this.writable = !1), t.allowHalfOpen === !1 && (this.allowHalfOpen = !1, this.once("end", l8))) } Object.defineProperty(kr.prototype, "writableHighWaterMark", { enumerable: !1, get: function () { return this._writableState.highWaterMark } }); Object.defineProperty(kr.prototype, "writableBuffer", { enumerable: !1, get: function () { return this._writableState && this._writableState.getBuffer() } }); Object.defineProperty(kr.prototype, "writableLength", { enumerable: !1, get: function () { return this._writableState.length } }); function l8() { this._writableState.ended || process.nextTick(p8, this) } function p8(t) { t.end() } Object.defineProperty(kr.prototype, "destroyed", { enumerable: !1, get: function () { return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed }, set: function (e) { this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = e, this._writableState.destroyed = e) } }) }); var Os = I(up => { "use strict"; var u0 = Te().Buffer, hp = u0.isEncoding || function (t) { switch (t = "" + t, t && t.toLowerCase()) { case "hex": case "utf8": case "utf-8": case "ascii": case "binary": case "base64": case "ucs2": case "ucs-2": case "utf16le": case "utf-16le": case "raw": return !0; default: return !1 } }; function v8(t) { if (!t) return "utf8"; for (var e; ;)switch (t) { case "utf8": case "utf-8": return "utf8"; case "ucs2": case "ucs-2": case "utf16le": case "utf-16le": return "utf16le"; case "latin1": case "binary": return "latin1"; case "base64": case "ascii": case "hex": return t; default: if (e) return; t = ("" + t).toLowerCase(), e = !0 } } function b8(t) { var e = v8(t); if (typeof e != "string" && (u0.isEncoding === hp || !hp(t))) throw new Error("Unknown encoding: " + t); return e || t } up.StringDecoder = Za; function Za(t) { this.encoding = b8(t); var e; switch (this.encoding) { case "utf16le": this.text = x8, this.end = M8, e = 4; break; case "utf8": this.fillLast = g8, e = 4; break; case "base64": this.text = S8, this.end = E8, e = 3; break; default: this.write = A8, this.end = B8; return }this.lastNeed = 0, this.lastTotal = 0, this.lastChar = u0.allocUnsafe(e) } Za.prototype.write = function (t) { if (t.length === 0) return ""; var e, r; if (this.lastNeed) { if (e = this.fillLast(t), e === void 0) return ""; r = this.lastNeed, this.lastNeed = 0 } else r = 0; return r < t.length ? e ? e + this.text(t, r) : this.text(t, r) : e || "" }; Za.prototype.end = _8; Za.prototype.text = w8; Za.prototype.fillLast = function (t) { if (this.lastNeed <= t.length) return t.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal); t.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, t.length), this.lastNeed -= t.length }; function c0(t) { return t <= 127 ? 0 : t >> 5 == 6 ? 2 : t >> 4 == 14 ? 3 : t >> 3 == 30 ? 4 : t >> 6 == 2 ? -1 : -2 } function y8(t, e, r) { var i = e.length - 1; if (i < r) return 0; var n = c0(e[i]); return n >= 0 ? (n > 0 && (t.lastNeed = n - 1), n) : --i < r || n === -2 ? 0 : (n = c0(e[i]), n >= 0 ? (n > 0 && (t.lastNeed = n - 2), n) : --i < r || n === -2 ? 0 : (n = c0(e[i]), n >= 0 ? (n > 0 && (n === 2 ? n = 0 : t.lastNeed = n - 3), n) : 0)) } function m8(t, e, r) { if ((e[0] & 192) != 128) return t.lastNeed = 0, "\uFFFD"; if (t.lastNeed > 1 && e.length > 1) { if ((e[1] & 192) != 128) return t.lastNeed = 1, "\uFFFD"; if (t.lastNeed > 2 && e.length > 2 && (e[2] & 192) != 128) return t.lastNeed = 2, "\uFFFD" } } function g8(t) { var e = this.lastTotal - this.lastNeed, r = m8(this, t, e); if (r !== void 0) return r; if (this.lastNeed <= t.length) return t.copy(this.lastChar, e, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal); t.copy(this.lastChar, e, 0, t.length), this.lastNeed -= t.length } function w8(t, e) { var r = y8(this, t, e); if (!this.lastNeed) return t.toString("utf8", e); this.lastTotal = r; var i = t.length - (r - this.lastNeed); return t.copy(this.lastChar, 0, i), t.toString("utf8", e, i) } function _8(t) { var e = t && t.length ? this.write(t) : ""; return this.lastNeed ? e + "\uFFFD" : e } function x8(t, e) { if ((t.length - e) % 2 == 0) { var r = t.toString("utf16le", e); if (r) { var i = r.charCodeAt(r.length - 1); if (i >= 55296 && i <= 56319) return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = t[t.length - 2], this.lastChar[1] = t[t.length - 1], r.slice(0, -1) } return r } return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = t[t.length - 1], t.toString("utf16le", e, t.length - 1) } function M8(t) { var e = t && t.length ? this.write(t) : ""; if (this.lastNeed) { var r = this.lastTotal - this.lastNeed; return e + this.lastChar.toString("utf16le", 0, r) } return e } function S8(t, e) { var r = (t.length - e) % 3; return r === 0 ? t.toString("base64", e) : (this.lastNeed = 3 - r, this.lastTotal = 3, r === 1 ? this.lastChar[0] = t[t.length - 1] : (this.lastChar[0] = t[t.length - 2], this.lastChar[1] = t[t.length - 1]), t.toString("base64", e, t.length - r)) } function E8(t) { var e = t && t.length ? this.write(t) : ""; return this.lastNeed ? e + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : e } function A8(t) { return t.toString(this.encoding) } function B8(t) { return t && t.length ? this.write(t) : "" } }); var Ja = I((HE, lp) => { "use strict"; var cp = un().codes.ERR_STREAM_PREMATURE_CLOSE; function I8(t) { var e = !1; return function () { if (!e) { e = !0; for (var r = arguments.length, i = new Array(r), n = 0; n < r; n++)i[n] = arguments[n]; t.apply(this, i) } } } function R8() { } function T8(t) { return t.setHeader && typeof t.abort == "function" } function dp(t, e, r) { if (typeof e == "function") return dp(t, null, e); e || (e = {}), r = I8(r || R8); var i = e.readable || e.readable !== !1 && t.readable, n = e.writable || e.writable !== !1 && t.writable, f = function () { t.writable || c() }, h = t._writableState && t._writableState.finished, c = function () { n = !1, h = !0, i || r.call(t) }, y = t._readableState && t._readableState.endEmitted, x = function () { i = !1, y = !0, n || r.call(t) }, M = function (T) { r.call(t, T) }, E = function () { var T; if (i && !y) return (!t._readableState || !t._readableState.ended) && (T = new cp), r.call(t, T); if (n && !h) return (!t._writableState || !t._writableState.ended) && (T = new cp), r.call(t, T) }, A = function () { t.req.on("finish", c) }; return T8(t) ? (t.on("complete", c), t.on("abort", E), t.req ? A() : t.on("request", A)) : n && !t._writableState && (t.on("end", f), t.on("close", f)), t.on("end", x), t.on("finish", c), e.error !== !1 && t.on("error", M), t.on("close", E), function () { t.removeListener("complete", c), t.removeListener("abort", E), t.removeListener("request", A), t.req && t.req.removeListener("finish", c), t.removeListener("end", f), t.removeListener("close", f), t.removeListener("finish", c), t.removeListener("end", x), t.removeListener("error", M), t.removeListener("close", E) } } lp.exports = dp }); var vp = I((jE, pp) => { "use strict"; var Ds; function Ui(t, e, r) { return e in t ? Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = r, t } var q8 = Ja(), Ni = Symbol("lastResolve"), cn = Symbol("lastReject"), Qa = Symbol("error"), Fs = Symbol("ended"), dn = Symbol("lastPromise"), d0 = Symbol("handlePromise"), ln = Symbol("stream"); function Li(t, e) { return { value: t, done: e } } function k8(t) { var e = t[Ni]; if (e !== null) { var r = t[ln].read(); r !== null && (t[dn] = null, t[Ni] = null, t[cn] = null, e(Li(r, !1))) } } function P8(t) { process.nextTick(k8, t) } function C8(t, e) { return function (r, i) { t.then(function () { if (e[Fs]) { r(Li(void 0, !0)); return } e[d0](r, i) }, i) } } var O8 = Object.getPrototypeOf(function () { }), D8 = Object.setPrototypeOf((Ds = { get stream() { return this[ln] }, next: function () { var e = this, r = this[Qa]; if (r !== null) return Promise.reject(r); if (this[Fs]) return Promise.resolve(Li(void 0, !0)); if (this[ln].destroyed) return new Promise(function (h, c) { process.nextTick(function () { e[Qa] ? c(e[Qa]) : h(Li(void 0, !0)) }) }); var i = this[dn], n; if (i) n = new Promise(C8(i, this)); else { var f = this[ln].read(); if (f !== null) return Promise.resolve(Li(f, !1)); n = new Promise(this[d0]) } return this[dn] = n, n } }, Ui(Ds, Symbol.asyncIterator, function () { return this }), Ui(Ds, "return", function () { var e = this; return new Promise(function (r, i) { e[ln].destroy(null, function (n) { if (n) { i(n); return } r(Li(void 0, !0)) }) }) }), Ds), O8), F8 = function (e) { var r, i = Object.create(D8, (r = {}, Ui(r, ln, { value: e, writable: !0 }), Ui(r, Ni, { value: null, writable: !0 }), Ui(r, cn, { value: null, writable: !0 }), Ui(r, Qa, { value: null, writable: !0 }), Ui(r, Fs, { value: e._readableState.endEmitted, writable: !0 }), Ui(r, d0, { value: function (f, h) { var c = i[ln].read(); c ? (i[dn] = null, i[Ni] = null, i[cn] = null, f(Li(c, !1))) : (i[Ni] = f, i[cn] = h) }, writable: !0 }), r)); return i[dn] = null, q8(e, function (n) { if (n && n.code !== "ERR_STREAM_PREMATURE_CLOSE") { var f = i[cn]; f !== null && (i[dn] = null, i[Ni] = null, i[cn] = null, f(n)), i[Qa] = n; return } var h = i[Ni]; h !== null && (i[dn] = null, i[Ni] = null, i[cn] = null, h(Li(void 0, !0))), i[Fs] = !0 }), e.on("readable", P8.bind(null, i)), i }; pp.exports = F8 }); var yp = I((zE, bp) => { bp.exports = function () { throw new Error("Readable.from is not available in the browser") } }); var Cs = I((KE, Bp) => { "use strict"; Bp.exports = Ne; var aa; Ne.ReadableState = gp; var WE = ns().EventEmitter, mp = function (e, r) { return e.listeners(r).length }, ef = Th(), Us = ct().Buffer, U8 = window.Uint8Array || function () { }; function N8(t) { return Us.from(t) } function L8(t) { return Us.isBuffer(t) || t instanceof U8 } var l0 = As(), ke; l0 && l0.debuglog ? ke = l0.debuglog("stream") : ke = function () { }; var H8 = Vl(), p0 = i0(), j8 = n0(), z8 = j8.getHighWaterMark, Ns = un().codes, W8 = Ns.ERR_INVALID_ARG_TYPE, K8 = Ns.ERR_STREAM_PUSH_AFTER_EOF, V8 = Ns.ERR_METHOD_NOT_IMPLEMENTED, G8 = Ns.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, fa, v0, b0; Re()(Ne, ef); var tf = p0.errorOrDestroy, y0 = ["error", "close", "destroy", "pause", "resume"]; function $8(t, e, r) { if (typeof t.prependListener == "function") return t.prependListener(e, r); !t._events || !t._events[e] ? t.on(e, r) : Array.isArray(t._events[e]) ? t._events[e].unshift(r) : t._events[e] = [r, t._events[e]] } function gp(t, e, r) { aa = aa || Fi(), t = t || {}, typeof r != "boolean" && (r = e instanceof aa), this.objectMode = !!t.objectMode, r && (this.objectMode = this.objectMode || !!t.readableObjectMode), this.highWaterMark = z8(this, t, "readableHighWaterMark", r), this.buffer = new H8, this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose = t.emitClose !== !1, this.autoDestroy = !!t.autoDestroy, this.destroyed = !1, this.defaultEncoding = t.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, t.encoding && (fa || (fa = Os().StringDecoder), this.decoder = new fa(t.encoding), this.encoding = t.encoding) } function Ne(t) { if (aa = aa || Fi(), !(this instanceof Ne)) return new Ne(t); var e = this instanceof aa; this._readableState = new gp(t, this, e), this.readable = !0, t && (typeof t.read == "function" && (this._read = t.read), typeof t.destroy == "function" && (this._destroy = t.destroy)), ef.call(this) } Object.defineProperty(Ne.prototype, "destroyed", { enumerable: !1, get: function () { return this._readableState === void 0 ? !1 : this._readableState.destroyed }, set: function (e) { !this._readableState || (this._readableState.destroyed = e) } }); Ne.prototype.destroy = p0.destroy; Ne.prototype._undestroy = p0.undestroy; Ne.prototype._destroy = function (t, e) { e(t) }; Ne.prototype.push = function (t, e) { var r = this._readableState, i; return r.objectMode ? i = !0 : typeof t == "string" && (e = e || r.defaultEncoding, e !== r.encoding && (t = Us.from(t, e), e = ""), i = !0), wp(this, t, e, !1, i) }; Ne.prototype.unshift = function (t) { return wp(this, t, null, !0, !1) }; function wp(t, e, r, i, n) { ke("readableAddChunk", e); var f = t._readableState; if (e === null) f.reading = !1, Z8(t, f); else { var h; if (n || (h = X8(f, e)), h) tf(t, h); else if (f.objectMode || e && e.length > 0) if (typeof e != "string" && !f.objectMode && Object.getPrototypeOf(e) !== Us.prototype && (e = N8(e)), i) f.endEmitted ? tf(t, new G8) : m0(t, f, e, !0); else if (f.ended) tf(t, new K8); else { if (f.destroyed) return !1; f.reading = !1, f.decoder && !r ? (e = f.decoder.write(e), f.objectMode || e.length !== 0 ? m0(t, f, e, !1) : g0(t, f)) : m0(t, f, e, !1) } else i || (f.reading = !1, g0(t, f)) } return !f.ended && (f.length < f.highWaterMark || f.length === 0) } function m0(t, e, r, i) { e.flowing && e.length === 0 && !e.sync ? (e.awaitDrain = 0, t.emit("data", r)) : (e.length += e.objectMode ? 1 : r.length, i ? e.buffer.unshift(r) : e.buffer.push(r), e.needReadable && Ls(t)), g0(t, e) } function X8(t, e) { var r; return !L8(e) && typeof e != "string" && e !== void 0 && !t.objectMode && (r = new W8("chunk", ["string", "Buffer", "Uint8Array"], e)), r } Ne.prototype.isPaused = function () { return this._readableState.flowing === !1 }; Ne.prototype.setEncoding = function (t) { fa || (fa = Os().StringDecoder); var e = new fa(t); this._readableState.decoder = e, this._readableState.encoding = this._readableState.decoder.encoding; for (var r = this._readableState.buffer.head, i = ""; r !== null;)i += e.write(r.data), r = r.next; return this._readableState.buffer.clear(), i !== "" && this._readableState.buffer.push(i), this._readableState.length = i.length, this }; var _p = 1073741824; function Y8(t) { return t >= _p ? t = _p : (t--, t |= t >>> 1, t |= t >>> 2, t |= t >>> 4, t |= t >>> 8, t |= t >>> 16, t++), t } function xp(t, e) { return t <= 0 || e.length === 0 && e.ended ? 0 : e.objectMode ? 1 : t !== t ? e.flowing && e.length ? e.buffer.head.data.length : e.length : (t > e.highWaterMark && (e.highWaterMark = Y8(t)), t <= e.length ? t : e.ended ? e.length : (e.needReadable = !0, 0)) } Ne.prototype.read = function (t) { ke("read", t), t = parseInt(t, 10); var e = this._readableState, r = t; if (t !== 0 && (e.emittedReadable = !1), t === 0 && e.needReadable && ((e.highWaterMark !== 0 ? e.length >= e.highWaterMark : e.length > 0) || e.ended)) return ke("read: emitReadable", e.length, e.ended), e.length === 0 && e.ended ? _0(this) : Ls(this), null; if (t = xp(t, e), t === 0 && e.ended) return e.length === 0 && _0(this), null; var i = e.needReadable; ke("need readable", i), (e.length === 0 || e.length - t < e.highWaterMark) && (i = !0, ke("length less than watermark", i)), e.ended || e.reading ? (i = !1, ke("reading or ended", i)) : i && (ke("do read"), e.reading = !0, e.sync = !0, e.length === 0 && (e.needReadable = !0), this._read(e.highWaterMark), e.sync = !1, e.reading || (t = xp(r, e))); var n; return t > 0 ? n = Ep(t, e) : n = null, n === null ? (e.needReadable = e.length <= e.highWaterMark, t = 0) : (e.length -= t, e.awaitDrain = 0), e.length === 0 && (e.ended || (e.needReadable = !0), r !== t && e.ended && _0(this)), n !== null && this.emit("data", n), n }; function Z8(t, e) { if (ke("onEofChunk"), !e.ended) { if (e.decoder) { var r = e.decoder.end(); r && r.length && (e.buffer.push(r), e.length += e.objectMode ? 1 : r.length) } e.ended = !0, e.sync ? Ls(t) : (e.needReadable = !1, e.emittedReadable || (e.emittedReadable = !0, Mp(t))) } } function Ls(t) { var e = t._readableState; ke("emitReadable", e.needReadable, e.emittedReadable), e.needReadable = !1, e.emittedReadable || (ke("emitReadable", e.flowing), e.emittedReadable = !0, process.nextTick(Mp, t)) } function Mp(t) { var e = t._readableState; ke("emitReadable_", e.destroyed, e.length, e.ended), !e.destroyed && (e.length || e.ended) && (t.emit("readable"), e.emittedReadable = !1), e.needReadable = !e.flowing && !e.ended && e.length <= e.highWaterMark, w0(t) } function g0(t, e) { e.readingMore || (e.readingMore = !0, process.nextTick(J8, t, e)) } function J8(t, e) { for (; !e.reading && !e.ended && (e.length < e.highWaterMark || e.flowing && e.length === 0);) { var r = e.length; if (ke("maybeReadMore read 0"), t.read(0), r === e.length) break } e.readingMore = !1 } Ne.prototype._read = function (t) { tf(this, new V8("_read()")) }; Ne.prototype.pipe = function (t, e) { var r = this, i = this._readableState; switch (i.pipesCount) { case 0: i.pipes = t; break; case 1: i.pipes = [i.pipes, t]; break; default: i.pipes.push(t); break }i.pipesCount += 1, ke("pipe count=%d opts=%j", i.pipesCount, e); var n = (!e || e.end !== !1) && t !== process.stdout && t !== process.stderr, f = n ? c : C; i.endEmitted ? process.nextTick(f) : r.once("end", f), t.on("unpipe", h); function h(H, F) { ke("onunpipe"), H === r && F && F.hasUnpiped === !1 && (F.hasUnpiped = !0, M()) } function c() { ke("onend"), t.end() } var y = Q8(r); t.on("drain", y); var x = !1; function M() { ke("cleanup"), t.removeListener("close", B), t.removeListener("finish", T), t.removeListener("drain", y), t.removeListener("error", A), t.removeListener("unpipe", h), r.removeListener("end", c), r.removeListener("end", C), r.removeListener("data", E), x = !0, i.awaitDrain && (!t._writableState || t._writableState.needDrain) && y() } r.on("data", E); function E(H) { ke("ondata"); var F = t.write(H); ke("dest.write", F), F === !1 && ((i.pipesCount === 1 && i.pipes === t || i.pipesCount > 1 && Ap(i.pipes, t) !== -1) && !x && (ke("false write response, pause", i.awaitDrain), i.awaitDrain++), r.pause()) } function A(H) { ke("onerror", H), C(), t.removeListener("error", A), mp(t, "error") === 0 && tf(t, H) } $8(t, "error", A); function B() { t.removeListener("finish", T), C() } t.once("close", B); function T() { ke("onfinish"), t.removeListener("close", B), C() } t.once("finish", T); function C() { ke("unpipe"), r.unpipe(t) } return t.emit("pipe", r), i.flowing || (ke("pipe resume"), r.resume()), t }; function Q8(t) { return function () { var r = t._readableState; ke("pipeOnDrain", r.awaitDrain), r.awaitDrain && r.awaitDrain--, r.awaitDrain === 0 && mp(t, "data") && (r.flowing = !0, w0(t)) } } Ne.prototype.unpipe = function (t) { var e = this._readableState, r = { hasUnpiped: !1 }; if (e.pipesCount === 0) return this; if (e.pipesCount === 1) return t && t !== e.pipes ? this : (t || (t = e.pipes), e.pipes = null, e.pipesCount = 0, e.flowing = !1, t && t.emit("unpipe", this, r), this); if (!t) { var i = e.pipes, n = e.pipesCount; e.pipes = null, e.pipesCount = 0, e.flowing = !1; for (var f = 0; f < n; f++)i[f].emit("unpipe", this, { hasUnpiped: !1 }); return this } var h = Ap(e.pipes, t); return h === -1 ? this : (e.pipes.splice(h, 1), e.pipesCount -= 1, e.pipesCount === 1 && (e.pipes = e.pipes[0]), t.emit("unpipe", this, r), this) }; Ne.prototype.on = function (t, e) { var r = ef.prototype.on.call(this, t, e), i = this._readableState; return t === "data" ? (i.readableListening = this.listenerCount("readable") > 0, i.flowing !== !1 && this.resume()) : t === "readable" && !i.endEmitted && !i.readableListening && (i.readableListening = i.needReadable = !0, i.flowing = !1, i.emittedReadable = !1, ke("on readable", i.length, i.reading), i.length ? Ls(this) : i.reading || process.nextTick(e5, this)), r }; Ne.prototype.addListener = Ne.prototype.on; Ne.prototype.removeListener = function (t, e) { var r = ef.prototype.removeListener.call(this, t, e); return t === "readable" && process.nextTick(Sp, this), r }; Ne.prototype.removeAllListeners = function (t) { var e = ef.prototype.removeAllListeners.apply(this, arguments); return (t === "readable" || t === void 0) && process.nextTick(Sp, this), e }; function Sp(t) { var e = t._readableState; e.readableListening = t.listenerCount("readable") > 0, e.resumeScheduled && !e.paused ? e.flowing = !0 : t.listenerCount("data") > 0 && t.resume() } function e5(t) { ke("readable nexttick read 0"), t.read(0) } Ne.prototype.resume = function () { var t = this._readableState; return t.flowing || (ke("resume"), t.flowing = !t.readableListening, t5(this, t)), t.paused = !1, this }; function t5(t, e) { e.resumeScheduled || (e.resumeScheduled = !0, process.nextTick(r5, t, e)) } function r5(t, e) { ke("resume", e.reading), e.reading || t.read(0), e.resumeScheduled = !1, t.emit("resume"), w0(t), e.flowing && !e.reading && t.read(0) } Ne.prototype.pause = function () { return ke("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (ke("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState.paused = !0, this }; function w0(t) { var e = t._readableState; for (ke("flow", e.flowing); e.flowing && t.read() !== null;); } Ne.prototype.wrap = function (t) { var e = this, r = this._readableState, i = !1; t.on("end", function () { if (ke("wrapped end"), r.decoder && !r.ended) { var h = r.decoder.end(); h && h.length && e.push(h) } e.push(null) }), t.on("data", function (h) { if (ke("wrapped data"), r.decoder && (h = r.decoder.write(h)), !(r.objectMode && h == null) && !(!r.objectMode && (!h || !h.length))) { var c = e.push(h); c || (i = !0, t.pause()) } }); for (var n in t) this[n] === void 0 && typeof t[n] == "function" && (this[n] = function (c) { return function () { return t[c].apply(t, arguments) } }(n)); for (var f = 0; f < y0.length; f++)t.on(y0[f], this.emit.bind(this, y0[f])); return this._read = function (h) { ke("wrapped _read", h), i && (i = !1, t.resume()) }, this }; typeof Symbol == "function" && (Ne.prototype[Symbol.asyncIterator] = function () { return v0 === void 0 && (v0 = vp()), v0(this) }); Object.defineProperty(Ne.prototype, "readableHighWaterMark", { enumerable: !1, get: function () { return this._readableState.highWaterMark } }); Object.defineProperty(Ne.prototype, "readableBuffer", { enumerable: !1, get: function () { return this._readableState && this._readableState.buffer } }); Object.defineProperty(Ne.prototype, "readableFlowing", { enumerable: !1, get: function () { return this._readableState.flowing }, set: function (e) { this._readableState && (this._readableState.flowing = e) } }); Ne._fromList = Ep; Object.defineProperty(Ne.prototype, "readableLength", { enumerable: !1, get: function () { return this._readableState.length } }); function Ep(t, e) { if (e.length === 0) return null; var r; return e.objectMode ? r = e.buffer.shift() : !t || t >= e.length ? (e.decoder ? r = e.buffer.join("") : e.buffer.length === 1 ? r = e.buffer.first() : r = e.buffer.concat(e.length), e.buffer.clear()) : r = e.buffer.consume(t, e.decoder), r } function _0(t) { var e = t._readableState; ke("endReadable", e.endEmitted), e.endEmitted || (e.ended = !0, process.nextTick(i5, e, t)) } function i5(t, e) { if (ke("endReadableNT", t.endEmitted, t.length), !t.endEmitted && t.length === 0 && (t.endEmitted = !0, e.readable = !1, e.emit("end"), t.autoDestroy)) { var r = e._writableState; (!r || r.autoDestroy && r.finished) && e.destroy() } } typeof Symbol == "function" && (Ne.from = function (t, e) { return b0 === void 0 && (b0 = yp()), b0(Ne, t, e) }); function Ap(t, e) { for (var r = 0, i = t.length; r < i; r++)if (t[r] === e) return r; return -1 } }); var zs = I((VE, Rp) => { "use strict"; Rp.exports = Xr; var Hs = un().codes, n5 = Hs.ERR_METHOD_NOT_IMPLEMENTED, a5 = Hs.ERR_MULTIPLE_CALLBACK, f5 = Hs.ERR_TRANSFORM_ALREADY_TRANSFORMING, s5 = Hs.ERR_TRANSFORM_WITH_LENGTH_0, js = Fi(); Re()(Xr, js); function o5(t, e) { var r = this._transformState; r.transforming = !1; var i = r.writecb; if (i === null) return this.emit("error", new a5); r.writechunk = null, r.writecb = null, e != null && this.push(e), i(t); var n = this._readableState; n.reading = !1, (n.needReadable || n.length < n.highWaterMark) && this._read(n.highWaterMark) } function Xr(t) { if (!(this instanceof Xr)) return new Xr(t); js.call(this, t), this._transformState = { afterTransform: o5.bind(this), needTransform: !1, transforming: !1, writecb: null, writechunk: null, writeencoding: null }, this._readableState.needReadable = !0, this._readableState.sync = !1, t && (typeof t.transform == "function" && (this._transform = t.transform), typeof t.flush == "function" && (this._flush = t.flush)), this.on("prefinish", h5) } function h5() { var t = this; typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function (e, r) { Ip(t, e, r) }) : Ip(this, null, null) } Xr.prototype.push = function (t, e) { return this._transformState.needTransform = !1, js.prototype.push.call(this, t, e) }; Xr.prototype._transform = function (t, e, r) { r(new n5("_transform()")) }; Xr.prototype._write = function (t, e, r) { var i = this._transformState; if (i.writecb = r, i.writechunk = t, i.writeencoding = e, !i.transforming) { var n = this._readableState; (i.needTransform || n.needReadable || n.length < n.highWaterMark) && this._read(n.highWaterMark) } }; Xr.prototype._read = function (t) { var e = this._transformState; e.writechunk !== null && !e.transforming ? (e.transforming = !0, this._transform(e.writechunk, e.writeencoding, e.afterTransform)) : e.needTransform = !0 }; Xr.prototype._destroy = function (t, e) { js.prototype._destroy.call(this, t, function (r) { e(r) }) }; function Ip(t, e, r) { if (e) return t.emit("error", e); if (r != null && t.push(r), t._writableState.length) throw new s5; if (t._transformState.transforming) throw new f5; return t.push(null) } }); var x0 = I((GE, qp) => { "use strict"; qp.exports = rf; var Tp = zs(); Re()(rf, Tp); function rf(t) { if (!(this instanceof rf)) return new rf(t); Tp.call(this, t) } rf.prototype._transform = function (t, e, r) { r(null, t) } }); var S0 = I(($E, Op) => { "use strict"; var M0; function u5(t) { var e = !1; return function () { e || (e = !0, t.apply(void 0, arguments)) } } var kp = un().codes, c5 = kp.ERR_MISSING_ARGS, d5 = kp.ERR_STREAM_DESTROYED; function Pp(t) { if (t) throw t } function l5(t) { return t.setHeader && typeof t.abort == "function" } function p5(t, e, r, i) { i = u5(i); var n = !1; t.on("close", function () { n = !0 }), M0 === void 0 && (M0 = Ja()), M0(t, { readable: e, writable: r }, function (h) { if (h) return i(h); n = !0, i() }); var f = !1; return function (h) { if (!n && !f) { if (f = !0, l5(t)) return t.abort(); if (typeof t.destroy == "function") return t.destroy(); i(h || new d5("pipe")) } } } function Cp(t) { t() } function v5(t, e) { return t.pipe(e) } function b5(t) { return !t.length || typeof t[t.length - 1] != "function" ? Pp : t.pop() } function y5() { for (var t = arguments.length, e = new Array(t), r = 0; r < t; r++)e[r] = arguments[r]; var i = b5(e); if (Array.isArray(e[0]) && (e = e[0]), e.length < 2) throw new c5("streams"); var n, f = e.map(function (h, c) { var y = c < e.length - 1, x = c > 0; return p5(h, y, x, function (M) { n || (n = M), M && f.forEach(Cp), !y && (f.forEach(Cp), i(n)) }) }); return e.reduce(v5) } Op.exports = y5 }); var E0 = I((Nt, Dp) => { Nt = Dp.exports = Cs(); Nt.Stream = Nt; Nt.Readable = Nt; Nt.Writable = qs(); Nt.Duplex = Fi(); Nt.Transform = zs(); Nt.PassThrough = x0(); Nt.finished = Ja(); Nt.pipeline = S0() }); var A0 = I((XE, Up) => { "use strict"; var Ws = Te().Buffer, Fp = E0().Transform, m5 = Re(); function g5(t, e) { if (!Ws.isBuffer(t) && typeof t != "string") throw new TypeError(e + " must be a string or a buffer") } function Hi(t) { Fp.call(this), this._block = Ws.allocUnsafe(t), this._blockSize = t, this._blockOffset = 0, this._length = [0, 0, 0, 0], this._finalized = !1 } m5(Hi, Fp); Hi.prototype._transform = function (t, e, r) { var i = null; try { this.update(t, e) } catch (n) { i = n } r(i) }; Hi.prototype._flush = function (t) { var e = null; try { this.push(this.digest()) } catch (r) { e = r } t(e) }; Hi.prototype.update = function (t, e) { if (g5(t, "Data"), this._finalized) throw new Error("Digest already called"); Ws.isBuffer(t) || (t = Ws.from(t, e)); for (var r = this._block, i = 0; this._blockOffset + t.length - i >= this._blockSize;) { for (var n = this._blockOffset; n < this._blockSize;)r[n++] = t[i++]; this._update(), this._blockOffset = 0 } for (; i < t.length;)r[this._blockOffset++] = t[i++]; for (var f = 0, h = t.length * 8; h > 0; ++f)this._length[f] += h, h = this._length[f] / 4294967296 | 0, h > 0 && (this._length[f] -= 4294967296 * h); return this }; Hi.prototype._update = function () { throw new Error("_update is not implemented") }; Hi.prototype.digest = function (t) { if (this._finalized) throw new Error("Digest already called"); this._finalized = !0; var e = this._digest(); t !== void 0 && (e = e.toString(t)), this._block.fill(0), this._blockOffset = 0; for (var r = 0; r < 4; ++r)this._length[r] = 0; return e }; Hi.prototype._digest = function () { throw new Error("_digest is not implemented") }; Up.exports = Hi }); var Gs = I((YE, Lp) => { "use strict"; var w5 = Re(), Np = A0(), _5 = Te().Buffer, x5 = new Array(16); function Ks() { Np.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878 } w5(Ks, Np); Ks.prototype._update = function () { for (var t = x5, e = 0; e < 16; ++e)t[e] = this._block.readInt32LE(e * 4); var r = this._a, i = this._b, n = this._c, f = this._d; r = vt(r, i, n, f, t[0], 3614090360, 7), f = vt(f, r, i, n, t[1], 3905402710, 12), n = vt(n, f, r, i, t[2], 606105819, 17), i = vt(i, n, f, r, t[3], 3250441966, 22), r = vt(r, i, n, f, t[4], 4118548399, 7), f = vt(f, r, i, n, t[5], 1200080426, 12), n = vt(n, f, r, i, t[6], 2821735955, 17), i = vt(i, n, f, r, t[7], 4249261313, 22), r = vt(r, i, n, f, t[8], 1770035416, 7), f = vt(f, r, i, n, t[9], 2336552879, 12), n = vt(n, f, r, i, t[10], 4294925233, 17), i = vt(i, n, f, r, t[11], 2304563134, 22), r = vt(r, i, n, f, t[12], 1804603682, 7), f = vt(f, r, i, n, t[13], 4254626195, 12), n = vt(n, f, r, i, t[14], 2792965006, 17), i = vt(i, n, f, r, t[15], 1236535329, 22), r = bt(r, i, n, f, t[1], 4129170786, 5), f = bt(f, r, i, n, t[6], 3225465664, 9), n = bt(n, f, r, i, t[11], 643717713, 14), i = bt(i, n, f, r, t[0], 3921069994, 20), r = bt(r, i, n, f, t[5], 3593408605, 5), f = bt(f, r, i, n, t[10], 38016083, 9), n = bt(n, f, r, i, t[15], 3634488961, 14), i = bt(i, n, f, r, t[4], 3889429448, 20), r = bt(r, i, n, f, t[9], 568446438, 5), f = bt(f, r, i, n, t[14], 3275163606, 9), n = bt(n, f, r, i, t[3], 4107603335, 14), i = bt(i, n, f, r, t[8], 1163531501, 20), r = bt(r, i, n, f, t[13], 2850285829, 5), f = bt(f, r, i, n, t[2], 4243563512, 9), n = bt(n, f, r, i, t[7], 1735328473, 14), i = bt(i, n, f, r, t[12], 2368359562, 20), r = yt(r, i, n, f, t[5], 4294588738, 4), f = yt(f, r, i, n, t[8], 2272392833, 11), n = yt(n, f, r, i, t[11], 1839030562, 16), i = yt(i, n, f, r, t[14], 4259657740, 23), r = yt(r, i, n, f, t[1], 2763975236, 4), f = yt(f, r, i, n, t[4], 1272893353, 11), n = yt(n, f, r, i, t[7], 4139469664, 16), i = yt(i, n, f, r, t[10], 3200236656, 23), r = yt(r, i, n, f, t[13], 681279174, 4), f = yt(f, r, i, n, t[0], 3936430074, 11), n = yt(n, f, r, i, t[3], 3572445317, 16), i = yt(i, n, f, r, t[6], 76029189, 23), r = yt(r, i, n, f, t[9], 3654602809, 4), f = yt(f, r, i, n, t[12], 3873151461, 11), n = yt(n, f, r, i, t[15], 530742520, 16), i = yt(i, n, f, r, t[2], 3299628645, 23), r = mt(r, i, n, f, t[0], 4096336452, 6), f = mt(f, r, i, n, t[7], 1126891415, 10), n = mt(n, f, r, i, t[14], 2878612391, 15), i = mt(i, n, f, r, t[5], 4237533241, 21), r = mt(r, i, n, f, t[12], 1700485571, 6), f = mt(f, r, i, n, t[3], 2399980690, 10), n = mt(n, f, r, i, t[10], 4293915773, 15), i = mt(i, n, f, r, t[1], 2240044497, 21), r = mt(r, i, n, f, t[8], 1873313359, 6), f = mt(f, r, i, n, t[15], 4264355552, 10), n = mt(n, f, r, i, t[6], 2734768916, 15), i = mt(i, n, f, r, t[13], 1309151649, 21), r = mt(r, i, n, f, t[4], 4149444226, 6), f = mt(f, r, i, n, t[11], 3174756917, 10), n = mt(n, f, r, i, t[2], 718787259, 15), i = mt(i, n, f, r, t[9], 3951481745, 21), this._a = this._a + r | 0, this._b = this._b + i | 0, this._c = this._c + n | 0, this._d = this._d + f | 0 }; Ks.prototype._digest = function () { this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update(); var t = _5.allocUnsafe(16); return t.writeInt32LE(this._a, 0), t.writeInt32LE(this._b, 4), t.writeInt32LE(this._c, 8), t.writeInt32LE(this._d, 12), t }; function Vs(t, e) { return t << e | t >>> 32 - e } function vt(t, e, r, i, n, f, h) { return Vs(t + (e & r | ~e & i) + n + f | 0, h) + e | 0 } function bt(t, e, r, i, n, f, h) { return Vs(t + (e & i | r & ~i) + n + f | 0, h) + e | 0 } function yt(t, e, r, i, n, f, h) { return Vs(t + (e ^ r ^ i) + n + f | 0, h) + e | 0 } function mt(t, e, r, i, n, f, h) { return Vs(t + (r ^ (e | ~i)) + n + f | 0, h) + e | 0 } Lp.exports = Ks }); var Xs = I((ZE, Gp) => { "use strict"; var B0 = ct().Buffer, M5 = Re(), Hp = A0(), S5 = new Array(16), nf = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13], af = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11], ff = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6], sf = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11], of = [0, 1518500249, 1859775393, 2400959708, 2840853838], hf = [1352829926, 1548603684, 1836072691, 2053994217, 0]; function $s() { Hp.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520 } M5($s, Hp); $s.prototype._update = function () { for (var t = S5, e = 0; e < 16; ++e)t[e] = this._block.readInt32LE(e * 4); for (var r = this._a | 0, i = this._b | 0, n = this._c | 0, f = this._d | 0, h = this._e | 0, c = this._a | 0, y = this._b | 0, x = this._c | 0, M = this._d | 0, E = this._e | 0, A = 0; A < 80; A += 1) { var B, T; A < 16 ? (B = jp(r, i, n, f, h, t[nf[A]], of[0], ff[A]), T = Vp(c, y, x, M, E, t[af[A]], hf[0], sf[A])) : A < 32 ? (B = zp(r, i, n, f, h, t[nf[A]], of[1], ff[A]), T = Kp(c, y, x, M, E, t[af[A]], hf[1], sf[A])) : A < 48 ? (B = Wp(r, i, n, f, h, t[nf[A]], of[2], ff[A]), T = Wp(c, y, x, M, E, t[af[A]], hf[2], sf[A])) : A < 64 ? (B = Kp(r, i, n, f, h, t[nf[A]], of[3], ff[A]), T = zp(c, y, x, M, E, t[af[A]], hf[3], sf[A])) : (B = Vp(r, i, n, f, h, t[nf[A]], of[4], ff[A]), T = jp(c, y, x, M, E, t[af[A]], hf[4], sf[A])), r = h, h = f, f = pn(n, 10), n = i, i = B, c = E, E = M, M = pn(x, 10), x = y, y = T } var C = this._b + n + M | 0; this._b = this._c + f + E | 0, this._c = this._d + h + c | 0, this._d = this._e + r + y | 0, this._e = this._a + i + x | 0, this._a = C }; $s.prototype._digest = function () { this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update(); var t = B0.alloc ? B0.alloc(20) : new B0(20); return t.writeInt32LE(this._a, 0), t.writeInt32LE(this._b, 4), t.writeInt32LE(this._c, 8), t.writeInt32LE(this._d, 12), t.writeInt32LE(this._e, 16), t }; function pn(t, e) { return t << e | t >>> 32 - e } function jp(t, e, r, i, n, f, h, c) { return pn(t + (e ^ r ^ i) + f + h | 0, c) + n | 0 } function zp(t, e, r, i, n, f, h, c) { return pn(t + (e & r | ~e & i) + f + h | 0, c) + n | 0 } function Wp(t, e, r, i, n, f, h, c) { return pn(t + ((e | ~r) ^ i) + f + h | 0, c) + n | 0 } function Kp(t, e, r, i, n, f, h, c) { return pn(t + (e & i | r & ~i) + f + h | 0, c) + n | 0 } function Vp(t, e, r, i, n, f, h, c) { return pn(t + (e ^ (r | ~i)) + f + h | 0, c) + n | 0 } Gp.exports = $s }); var vn = I((JE, Xp) => { var $p = Te().Buffer; function Ys(t, e) { this._block = $p.alloc(t), this._finalSize = e, this._blockSize = t, this._len = 0 } Ys.prototype.update = function (t, e) { typeof t == "string" && (e = e || "utf8", t = $p.from(t, e)); for (var r = this._block, i = this._blockSize, n = t.length, f = this._len, h = 0; h < n;) { for (var c = f % i, y = Math.min(n - h, i - c), x = 0; x < y; x++)r[c + x] = t[h + x]; f += y, h += y, f % i == 0 && this._update(r) } return this._len += n, this }; Ys.prototype.digest = function (t) { var e = this._len % this._blockSize; this._block[e] = 128, this._block.fill(0, e + 1), e >= this._finalSize && (this._update(this._block), this._block.fill(0)); var r = this._len * 8; if (r <= 4294967295) this._block.writeUInt32BE(r, this._blockSize - 4); else { var i = (r & 4294967295) >>> 0, n = (r - i) / 4294967296; this._block.writeUInt32BE(n, this._blockSize - 8), this._block.writeUInt32BE(i, this._blockSize - 4) } this._update(this._block); var f = this._hash(); return t ? f.toString(t) : f }; Ys.prototype._update = function () { throw new Error("_update must be implemented by subclass") }; Xp.exports = Ys }); var Jp = I((QE, Zp) => { var E5 = Re(), Yp = vn(), A5 = Te().Buffer, B5 = [1518500249, 1859775393, 2400959708 | 0, 3395469782 | 0], I5 = new Array(80); function uf() { this.init(), this._w = I5, Yp.call(this, 64, 56) } E5(uf, Yp); uf.prototype.init = function () { return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this }; function R5(t) { return t << 5 | t >>> 27 } function T5(t) { return t << 30 | t >>> 2 } function q5(t, e, r, i) { return t === 0 ? e & r | ~e & i : t === 2 ? e & r | e & i | r & i : e ^ r ^ i } uf.prototype._update = function (t) { for (var e = this._w, r = this._a | 0, i = this._b | 0, n = this._c | 0, f = this._d | 0, h = this._e | 0, c = 0; c < 16; ++c)e[c] = t.readInt32BE(c * 4); for (; c < 80; ++c)e[c] = e[c - 3] ^ e[c - 8] ^ e[c - 14] ^ e[c - 16]; for (var y = 0; y < 80; ++y) { var x = ~~(y / 20), M = R5(r) + q5(x, i, n, f) + h + e[y] + B5[x] | 0; h = f, f = n, n = T5(i), i = r, r = M } this._a = r + this._a | 0, this._b = i + this._b | 0, this._c = n + this._c | 0, this._d = f + this._d | 0, this._e = h + this._e | 0 }; uf.prototype._hash = function () { var t = A5.allocUnsafe(20); return t.writeInt32BE(this._a | 0, 0), t.writeInt32BE(this._b | 0, 4), t.writeInt32BE(this._c | 0, 8), t.writeInt32BE(this._d | 0, 12), t.writeInt32BE(this._e | 0, 16), t }; Zp.exports = uf }); var t1 = I((eA, e1) => { var k5 = Re(), Qp = vn(), P5 = Te().Buffer, C5 = [1518500249, 1859775393, 2400959708 | 0, 3395469782 | 0], O5 = new Array(80); function cf() { this.init(), this._w = O5, Qp.call(this, 64, 56) } k5(cf, Qp); cf.prototype.init = function () { return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this }; function D5(t) { return t << 1 | t >>> 31 } function F5(t) { return t << 5 | t >>> 27 } function U5(t) { return t << 30 | t >>> 2 } function N5(t, e, r, i) { return t === 0 ? e & r | ~e & i : t === 2 ? e & r | e & i | r & i : e ^ r ^ i } cf.prototype._update = function (t) { for (var e = this._w, r = this._a | 0, i = this._b | 0, n = this._c | 0, f = this._d | 0, h = this._e | 0, c = 0; c < 16; ++c)e[c] = t.readInt32BE(c * 4); for (; c < 80; ++c)e[c] = D5(e[c - 3] ^ e[c - 8] ^ e[c - 14] ^ e[c - 16]); for (var y = 0; y < 80; ++y) { var x = ~~(y / 20), M = F5(r) + N5(x, i, n, f) + h + e[y] + C5[x] | 0; h = f, f = n, n = U5(i), i = r, r = M } this._a = r + this._a | 0, this._b = i + this._b | 0, this._c = n + this._c | 0, this._d = f + this._d | 0, this._e = h + this._e | 0 }; cf.prototype._hash = function () { var t = P5.allocUnsafe(20); return t.writeInt32BE(this._a | 0, 0), t.writeInt32BE(this._b | 0, 4), t.writeInt32BE(this._c | 0, 8), t.writeInt32BE(this._d | 0, 12), t.writeInt32BE(this._e | 0, 16), t }; e1.exports = cf }); var I0 = I((tA, i1) => { var L5 = Re(), r1 = vn(), H5 = Te().Buffer, j5 = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298], z5 = new Array(64); function df() { this.init(), this._w = z5, r1.call(this, 64, 56) } L5(df, r1); df.prototype.init = function () { return this._a = 1779033703, this._b = 3144134277, this._c = 1013904242, this._d = 2773480762, this._e = 1359893119, this._f = 2600822924, this._g = 528734635, this._h = 1541459225, this }; function W5(t, e, r) { return r ^ t & (e ^ r) } function K5(t, e, r) { return t & e | r & (t | e) } function V5(t) { return (t >>> 2 | t << 30) ^ (t >>> 13 | t << 19) ^ (t >>> 22 | t << 10) } function G5(t) { return (t >>> 6 | t << 26) ^ (t >>> 11 | t << 21) ^ (t >>> 25 | t << 7) } function $5(t) { return (t >>> 7 | t << 25) ^ (t >>> 18 | t << 14) ^ t >>> 3 } function X5(t) { return (t >>> 17 | t << 15) ^ (t >>> 19 | t << 13) ^ t >>> 10 } df.prototype._update = function (t) { for (var e = this._w, r = this._a | 0, i = this._b | 0, n = this._c | 0, f = this._d | 0, h = this._e | 0, c = this._f | 0, y = this._g | 0, x = this._h | 0, M = 0; M < 16; ++M)e[M] = t.readInt32BE(M * 4); for (; M < 64; ++M)e[M] = X5(e[M - 2]) + e[M - 7] + $5(e[M - 15]) + e[M - 16] | 0; for (var E = 0; E < 64; ++E) { var A = x + G5(h) + W5(h, c, y) + j5[E] + e[E] | 0, B = V5(r) + K5(r, i, n) | 0; x = y, y = c, c = h, h = f + A | 0, f = n, n = i, i = r, r = A + B | 0 } this._a = r + this._a | 0, this._b = i + this._b | 0, this._c = n + this._c | 0, this._d = f + this._d | 0, this._e = h + this._e | 0, this._f = c + this._f | 0, this._g = y + this._g | 0, this._h = x + this._h | 0 }; df.prototype._hash = function () { var t = H5.allocUnsafe(32); return t.writeInt32BE(this._a, 0), t.writeInt32BE(this._b, 4), t.writeInt32BE(this._c, 8), t.writeInt32BE(this._d, 12), t.writeInt32BE(this._e, 16), t.writeInt32BE(this._f, 20), t.writeInt32BE(this._g, 24), t.writeInt32BE(this._h, 28), t }; i1.exports = df }); var a1 = I((rA, n1) => { var Y5 = Re(), Z5 = I0(), J5 = vn(), Q5 = Te().Buffer, ew = new Array(64); function Zs() { this.init(), this._w = ew, J5.call(this, 64, 56) } Y5(Zs, Z5); Zs.prototype.init = function () { return this._a = 3238371032, this._b = 914150663, this._c = 812702999, this._d = 4144912697, this._e = 4290775857, this._f = 1750603025, this._g = 1694076839, this._h = 3204075428, this }; Zs.prototype._hash = function () { var t = Q5.allocUnsafe(28); return t.writeInt32BE(this._a, 0), t.writeInt32BE(this._b, 4), t.writeInt32BE(this._c, 8), t.writeInt32BE(this._d, 12), t.writeInt32BE(this._e, 16), t.writeInt32BE(this._f, 20), t.writeInt32BE(this._g, 24), t }; n1.exports = Zs }); var R0 = I((iA, d1) => { var tw = Re(), f1 = vn(), rw = Te().Buffer, s1 = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591], iw = new Array(160); function lf() { this.init(), this._w = iw, f1.call(this, 128, 112) } tw(lf, f1); lf.prototype.init = function () { return this._ah = 1779033703, this._bh = 3144134277, this._ch = 1013904242, this._dh = 2773480762, this._eh = 1359893119, this._fh = 2600822924, this._gh = 528734635, this._hh = 1541459225, this._al = 4089235720, this._bl = 2227873595, this._cl = 4271175723, this._dl = 1595750129, this._el = 2917565137, this._fl = 725511199, this._gl = 4215389547, this._hl = 327033209, this }; function o1(t, e, r) { return r ^ t & (e ^ r) } function h1(t, e, r) { return t & e | r & (t | e) } function u1(t, e) { return (t >>> 28 | e << 4) ^ (e >>> 2 | t << 30) ^ (e >>> 7 | t << 25) } function c1(t, e) { return (t >>> 14 | e << 18) ^ (t >>> 18 | e << 14) ^ (e >>> 9 | t << 23) } function nw(t, e) { return (t >>> 1 | e << 31) ^ (t >>> 8 | e << 24) ^ t >>> 7 } function aw(t, e) { return (t >>> 1 | e << 31) ^ (t >>> 8 | e << 24) ^ (t >>> 7 | e << 25) } function fw(t, e) { return (t >>> 19 | e << 13) ^ (e >>> 29 | t << 3) ^ t >>> 6 } function sw(t, e) { return (t >>> 19 | e << 13) ^ (e >>> 29 | t << 3) ^ (t >>> 6 | e << 26) } function ft(t, e) { return t >>> 0 < e >>> 0 ? 1 : 0 } lf.prototype._update = function (t) { for (var e = this._w, r = this._ah | 0, i = this._bh | 0, n = this._ch | 0, f = this._dh | 0, h = this._eh | 0, c = this._fh | 0, y = this._gh | 0, x = this._hh | 0, M = this._al | 0, E = this._bl | 0, A = this._cl | 0, B = this._dl | 0, T = this._el | 0, C = this._fl | 0, H = this._gl | 0, F = this._hl | 0, we = 0; we < 32; we += 2)e[we] = t.readInt32BE(we * 4), e[we + 1] = t.readInt32BE(we * 4 + 4); for (; we < 160; we += 2) { var Be = e[we - 15 * 2], xe = e[we - 15 * 2 + 1], Le = nw(Be, xe), Me = aw(xe, Be); Be = e[we - 2 * 2], xe = e[we - 2 * 2 + 1]; var De = fw(Be, xe), Ie = sw(xe, Be), je = e[we - 7 * 2], S = e[we - 7 * 2 + 1], b = e[we - 16 * 2], _ = e[we - 16 * 2 + 1], l = Me + S | 0, a = Le + je + ft(l, Me) | 0; l = l + Ie | 0, a = a + De + ft(l, Ie) | 0, l = l + _ | 0, a = a + b + ft(l, _) | 0, e[we] = a, e[we + 1] = l } for (var s = 0; s < 160; s += 2) { a = e[s], l = e[s + 1]; var d = h1(r, i, n), v = h1(M, E, A), p = u1(r, M), u = u1(M, r), m = c1(h, T), g = c1(T, h), o = s1[s], w = s1[s + 1], R = o1(h, c, y), k = o1(T, C, H), q = F + g | 0, O = x + m + ft(q, F) | 0; q = q + k | 0, O = O + R + ft(q, k) | 0, q = q + w | 0, O = O + o + ft(q, w) | 0, q = q + l | 0, O = O + a + ft(q, l) | 0; var D = u + v | 0, U = p + d + ft(D, u) | 0; x = y, F = H, y = c, H = C, c = h, C = T, T = B + q | 0, h = f + O + ft(T, B) | 0, f = n, B = A, n = i, A = E, i = r, E = M, M = q + D | 0, r = O + U + ft(M, q) | 0 } this._al = this._al + M | 0, this._bl = this._bl + E | 0, this._cl = this._cl + A | 0, this._dl = this._dl + B | 0, this._el = this._el + T | 0, this._fl = this._fl + C | 0, this._gl = this._gl + H | 0, this._hl = this._hl + F | 0, this._ah = this._ah + r + ft(this._al, M) | 0, this._bh = this._bh + i + ft(this._bl, E) | 0, this._ch = this._ch + n + ft(this._cl, A) | 0, this._dh = this._dh + f + ft(this._dl, B) | 0, this._eh = this._eh + h + ft(this._el, T) | 0, this._fh = this._fh + c + ft(this._fl, C) | 0, this._gh = this._gh + y + ft(this._gl, H) | 0, this._hh = this._hh + x + ft(this._hl, F) | 0 }; lf.prototype._hash = function () { var t = rw.allocUnsafe(64); function e(r, i, n) { t.writeInt32BE(r, n), t.writeInt32BE(i, n + 4) } return e(this._ah, this._al, 0), e(this._bh, this._bl, 8), e(this._ch, this._cl, 16), e(this._dh, this._dl, 24), e(this._eh, this._el, 32), e(this._fh, this._fl, 40), e(this._gh, this._gl, 48), e(this._hh, this._hl, 56), t }; d1.exports = lf }); var p1 = I((nA, l1) => { var ow = Re(), hw = R0(), uw = vn(), cw = Te().Buffer, dw = new Array(160); function Js() { this.init(), this._w = dw, uw.call(this, 128, 112) } ow(Js, hw); Js.prototype.init = function () { return this._ah = 3418070365, this._bh = 1654270250, this._ch = 2438529370, this._dh = 355462360, this._eh = 1731405415, this._fh = 2394180231, this._gh = 3675008525, this._hh = 1203062813, this._al = 3238371032, this._bl = 914150663, this._cl = 812702999, this._dl = 4144912697, this._el = 4290775857, this._fl = 1750603025, this._gl = 1694076839, this._hl = 3204075428, this }; Js.prototype._hash = function () { var t = cw.allocUnsafe(48); function e(r, i, n) { t.writeInt32BE(r, n), t.writeInt32BE(i, n + 4) } return e(this._ah, this._al, 0), e(this._bh, this._bl, 8), e(this._ch, this._cl, 16), e(this._dh, this._dl, 24), e(this._eh, this._el, 32), e(this._fh, this._fl, 40), t }; l1.exports = Js }); var Qs = I((Yr, v1) => { var Yr = v1.exports = function (e) { e = e.toLowerCase(); var r = Yr[e]; if (!r) throw new Error(e + " is not supported (we accept pull requests)"); return new r }; Yr.sha = Jp(); Yr.sha1 = t1(); Yr.sha224 = a1(); Yr.sha256 = I0(); Yr.sha384 = p1(); Yr.sha512 = R0() }); var Zr = I((aA, b1) => { b1.exports = Lt; var T0 = ns().EventEmitter, lw = Re(); lw(Lt, T0); Lt.Readable = Cs(); Lt.Writable = qs(); Lt.Duplex = Fi(); Lt.Transform = zs(); Lt.PassThrough = x0(); Lt.finished = Ja(); Lt.pipeline = S0(); Lt.Stream = Lt; function Lt() { T0.call(this) } Lt.prototype.pipe = function (t, e) { var r = this; function i(M) { t.writable && t.write(M) === !1 && r.pause && r.pause() } r.on("data", i); function n() { r.readable && r.resume && r.resume() } t.on("drain", n), !t._isStdio && (!e || e.end !== !1) && (r.on("end", h), r.on("close", c)); var f = !1; function h() { f || (f = !0, t.end()) } function c() { f || (f = !0, typeof t.destroy == "function" && t.destroy()) } function y(M) { if (x(), T0.listenerCount(this, "error") === 0) throw M } r.on("error", y), t.on("error", y); function x() { r.removeListener("data", i), t.removeListener("drain", n), r.removeListener("end", h), r.removeListener("close", c), r.removeListener("error", y), t.removeListener("error", y), r.removeListener("end", x), r.removeListener("close", x), t.removeListener("close", x) } return r.on("end", x), r.on("close", x), t.on("close", x), t.emit("pipe", r), t } }); var Jr = I((fA, g1) => { var y1 = Te().Buffer, m1 = Zr().Transform, pw = Os().StringDecoder, vw = Re(); function mr(t) { m1.call(this), this.hashMode = typeof t == "string", this.hashMode ? this[t] = this._finalOrDigest : this.final = this._finalOrDigest, this._final && (this.__final = this._final, this._final = null), this._decoder = null, this._encoding = null } vw(mr, m1); mr.prototype.update = function (t, e, r) { typeof t == "string" && (t = y1.from(t, e)); var i = this._update(t); return this.hashMode ? this : (r && (i = this._toString(i, r)), i) }; mr.prototype.setAutoPadding = function () { }; mr.prototype.getAuthTag = function () { throw new Error("trying to get auth tag in unsupported state") }; mr.prototype.setAuthTag = function () { throw new Error("trying to set auth tag in unsupported state") }; mr.prototype.setAAD = function () { throw new Error("trying to set aad in unsupported state") }; mr.prototype._transform = function (t, e, r) { var i; try { this.hashMode ? this._update(t) : this.push(this._update(t)) } catch (n) { i = n } finally { r(i) } }; mr.prototype._flush = function (t) { var e; try { this.push(this.__final()) } catch (r) { e = r } t(e) }; mr.prototype._finalOrDigest = function (t) { var e = this.__final() || y1.alloc(0); return t && (e = this._toString(e, t, !0)), e }; mr.prototype._toString = function (t, e, r) { if (this._decoder || (this._decoder = new pw(e), this._encoding = e), this._encoding !== e) throw new Error("can't switch encodings"); var i = this._decoder.write(t); return r && (i += this._decoder.end()), i }; g1.exports = mr }); var sa = I((sA, _1) => { "use strict"; var bw = Re(), yw = Gs(), mw = Xs(), gw = Qs(), w1 = Jr(); function eo(t) { w1.call(this, "digest"), this._hash = t } bw(eo, w1); eo.prototype._update = function (t) { this._hash.update(t) }; eo.prototype._final = function () { return this._hash.digest() }; _1.exports = function (e) { return e = e.toLowerCase(), e === "md5" ? new yw : e === "rmd160" || e === "ripemd160" ? new mw : new eo(gw(e)) } }); var S1 = I((oA, M1) => { "use strict"; var ww = Re(), bn = Te().Buffer, x1 = Jr(), _w = bn.alloc(128), oa = 64; function to(t, e) { x1.call(this, "digest"), typeof e == "string" && (e = bn.from(e)), this._alg = t, this._key = e, e.length > oa ? e = t(e) : e.length < oa && (e = bn.concat([e, _w], oa)); for (var r = this._ipad = bn.allocUnsafe(oa), i = this._opad = bn.allocUnsafe(oa), n = 0; n < oa; n++)r[n] = e[n] ^ 54, i[n] = e[n] ^ 92; this._hash = [r] } ww(to, x1); to.prototype._update = function (t) { this._hash.push(t) }; to.prototype._final = function () { var t = this._alg(bn.concat(this._hash)); return this._alg(bn.concat([this._opad, t])) }; M1.exports = to }); var q0 = I((hA, E1) => { var xw = Gs(); E1.exports = function (t) { return new xw().update(t).digest() } }); var C0 = I((uA, B1) => { "use strict"; var Mw = Re(), Sw = S1(), A1 = Jr(), pf = Te().Buffer, Ew = q0(), k0 = Xs(), P0 = Qs(), Aw = pf.alloc(128); function vf(t, e) { A1.call(this, "digest"), typeof e == "string" && (e = pf.from(e)); var r = t === "sha512" || t === "sha384" ? 128 : 64; if (this._alg = t, this._key = e, e.length > r) { var i = t === "rmd160" ? new k0 : P0(t); e = i.update(e).digest() } else e.length < r && (e = pf.concat([e, Aw], r)); for (var n = this._ipad = pf.allocUnsafe(r), f = this._opad = pf.allocUnsafe(r), h = 0; h < r; h++)n[h] = e[h] ^ 54, f[h] = e[h] ^ 92; this._hash = t === "rmd160" ? new k0 : P0(t), this._hash.update(n) } Mw(vf, A1); vf.prototype._update = function (t) { this._hash.update(t) }; vf.prototype._final = function () { var t = this._hash.digest(), e = this._alg === "rmd160" ? new k0 : P0(this._alg); return e.update(this._opad).update(t).digest() }; B1.exports = function (e, r) { return e = e.toLowerCase(), e === "rmd160" || e === "ripemd160" ? new vf("rmd160", r) : e === "md5" ? new Sw(Ew, r) : new vf(e, r) } }); var O0 = I((cA, Bw) => { Bw.exports = { sha224WithRSAEncryption: { sign: "rsa", hash: "sha224", id: "302d300d06096086480165030402040500041c" }, "RSA-SHA224": { sign: "ecdsa/rsa", hash: "sha224", id: "302d300d06096086480165030402040500041c" }, sha256WithRSAEncryption: { sign: "rsa", hash: "sha256", id: "3031300d060960864801650304020105000420" }, "RSA-SHA256": { sign: "ecdsa/rsa", hash: "sha256", id: "3031300d060960864801650304020105000420" }, sha384WithRSAEncryption: { sign: "rsa", hash: "sha384", id: "3041300d060960864801650304020205000430" }, "RSA-SHA384": { sign: "ecdsa/rsa", hash: "sha384", id: "3041300d060960864801650304020205000430" }, sha512WithRSAEncryption: { sign: "rsa", hash: "sha512", id: "3051300d060960864801650304020305000440" }, "RSA-SHA512": { sign: "ecdsa/rsa", hash: "sha512", id: "3051300d060960864801650304020305000440" }, "RSA-SHA1": { sign: "rsa", hash: "sha1", id: "3021300906052b0e03021a05000414" }, "ecdsa-with-SHA1": { sign: "ecdsa", hash: "sha1", id: "" }, sha256: { sign: "ecdsa", hash: "sha256", id: "" }, sha224: { sign: "ecdsa", hash: "sha224", id: "" }, sha384: { sign: "ecdsa", hash: "sha384", id: "" }, sha512: { sign: "ecdsa", hash: "sha512", id: "" }, "DSA-SHA": { sign: "dsa", hash: "sha1", id: "" }, "DSA-SHA1": { sign: "dsa", hash: "sha1", id: "" }, DSA: { sign: "dsa", hash: "sha1", id: "" }, "DSA-WITH-SHA224": { sign: "dsa", hash: "sha224", id: "" }, "DSA-SHA224": { sign: "dsa", hash: "sha224", id: "" }, "DSA-WITH-SHA256": { sign: "dsa", hash: "sha256", id: "" }, "DSA-SHA256": { sign: "dsa", hash: "sha256", id: "" }, "DSA-WITH-SHA384": { sign: "dsa", hash: "sha384", id: "" }, "DSA-SHA384": { sign: "dsa", hash: "sha384", id: "" }, "DSA-WITH-SHA512": { sign: "dsa", hash: "sha512", id: "" }, "DSA-SHA512": { sign: "dsa", hash: "sha512", id: "" }, "DSA-RIPEMD160": { sign: "dsa", hash: "rmd160", id: "" }, ripemd160WithRSA: { sign: "rsa", hash: "rmd160", id: "3021300906052b2403020105000414" }, "RSA-RIPEMD160": { sign: "rsa", hash: "rmd160", id: "3021300906052b2403020105000414" }, md5WithRSAEncryption: { sign: "rsa", hash: "md5", id: "3020300c06082a864886f70d020505000410" }, "RSA-MD5": { sign: "rsa", hash: "md5", id: "3020300c06082a864886f70d020505000410" } } }); var R1 = I((dA, I1) => { I1.exports = O0() }); var D0 = I((lA, T1) => { var Iw = Math.pow(2, 30) - 1; T1.exports = function (t, e) { if (typeof t != "number") throw new TypeError("Iterations not a number"); if (t < 0) throw new TypeError("Bad iterations"); if (typeof e != "number") throw new TypeError("Key length not a number"); if (e < 0 || e > Iw || e !== e) throw new TypeError("Bad key length") } }); var F0 = I((pA, k1) => { var ro; window.process && window.process.browser ? ro = "utf-8" : window.process && window.process.version ? (q1 = parseInt(process.version.split(".")[0].slice(1), 10), ro = q1 >= 6 ? "utf-8" : "binary") : ro = "utf-8"; var q1; k1.exports = ro }); var N0 = I((vA, P1) => { var U0 = Te().Buffer; P1.exports = function (t, e, r) { if (U0.isBuffer(t)) return t; if (typeof t == "string") return U0.from(t, e); if (ArrayBuffer.isView(t)) return U0.from(t.buffer); throw new TypeError(r + " must be a string, a Buffer, a typed array or a DataView") } }); var L0 = I((bA, F1) => { var Rw = q0(), Tw = Xs(), qw = Qs(), yn = Te().Buffer, kw = D0(), C1 = F0(), O1 = N0(), Pw = yn.alloc(128), io = { md5: 16, sha1: 20, sha224: 28, sha256: 32, sha384: 48, sha512: 64, rmd160: 20, ripemd160: 20 }; function D1(t, e, r) { var i = Cw(t), n = t === "sha512" || t === "sha384" ? 128 : 64; e.length > n ? e = i(e) : e.length < n && (e = yn.concat([e, Pw], n)); for (var f = yn.allocUnsafe(n + io[t]), h = yn.allocUnsafe(n + io[t]), c = 0; c < n; c++)f[c] = e[c] ^ 54, h[c] = e[c] ^ 92; var y = yn.allocUnsafe(n + r + 4); f.copy(y, 0, 0, n), this.ipad1 = y, this.ipad2 = f, this.opad = h, this.alg = t, this.blocksize = n, this.hash = i, this.size = io[t] } D1.prototype.run = function (t, e) { t.copy(e, this.blocksize); var r = this.hash(e); return r.copy(this.opad, this.blocksize), this.hash(this.opad) }; function Cw(t) { function e(i) { return qw(t).update(i).digest() } function r(i) { return new Tw().update(i).digest() } return t === "rmd160" || t === "ripemd160" ? r : t === "md5" ? Rw : e } function Ow(t, e, r, i, n) { kw(r, i), t = O1(t, C1, "Password"), e = O1(e, C1, "Salt"), n = n || "sha1"; var f = new D1(n, t, e.length), h = yn.allocUnsafe(i), c = yn.allocUnsafe(e.length + 4); e.copy(c, 0, 0, e.length); for (var y = 0, x = io[n], M = Math.ceil(i / x), E = 1; E <= M; E++) { c.writeUInt32BE(E, e.length); for (var A = f.run(c, f.ipad1), B = A, T = 1; T < r; T++) { B = f.run(B, f.ipad2); for (var C = 0; C < x; C++)A[C] ^= B[C] } A.copy(h, y), y += x } return h } F1.exports = Ow }); var W1 = I((yA, z1) => { var U1 = Te().Buffer, Dw = D0(), N1 = F0(), L1 = L0(), H1 = N0(), no, bf = window.crypto && window.crypto.subtle, Fw = { sha: "SHA-1", "sha-1": "SHA-1", sha1: "SHA-1", sha256: "SHA-256", "sha-256": "SHA-256", sha384: "SHA-384", "sha-384": "SHA-384", "sha-512": "SHA-512", sha512: "SHA-512" }, H0 = []; function Uw(t) { if (window.process && !window.process.browser || !bf || !bf.importKey || !bf.deriveBits) return Promise.resolve(!1); if (H0[t] !== void 0) return H0[t]; no = no || U1.alloc(8); var e = j1(no, no, 10, 128, t).then(function () { return !0 }).catch(function () { return !1 }); return H0[t] = e, e } var mn; function j0() { return mn || (window.process && window.process.nextTick ? mn = window.process.nextTick : window.queueMicrotask ? mn = window.queueMicrotask : window.setImmediate ? mn = window.setImmediate : mn = window.setTimeout, mn) } function j1(t, e, r, i, n) { return bf.importKey("raw", t, { name: "PBKDF2" }, !1, ["deriveBits"]).then(function (f) { return bf.deriveBits({ name: "PBKDF2", salt: e, iterations: r, hash: { name: n } }, f, i << 3) }).then(function (f) { return U1.from(f) }) } function Nw(t, e) { t.then(function (r) { j0()(function () { e(null, r) }) }, function (r) { j0()(function () { e(r) }) }) } z1.exports = function (t, e, r, i, n, f) { typeof n == "function" && (f = n, n = void 0), n = n || "sha1"; var h = Fw[n.toLowerCase()]; if (!h || typeof window.Promise != "function") { j0()(function () { var c; try { c = L1(t, e, r, i, n) } catch (y) { return f(y) } f(null, c) }); return } if (Dw(r, i), t = H1(t, N1, "Password"), e = H1(e, N1, "Salt"), typeof f != "function") throw new Error("No callback provided to pbkdf2"); Nw(Uw(h).then(function (c) { return c ? j1(t, e, r, i, h) : L1(t, e, r, i, n) }), f) } }); var W0 = I(z0 => { z0.pbkdf2 = W1(); z0.pbkdf2Sync = L0() }); var K0 = I(Ht => { "use strict"; Ht.readUInt32BE = function (e, r) { var i = e[0 + r] << 24 | e[1 + r] << 16 | e[2 + r] << 8 | e[3 + r]; return i >>> 0 }; Ht.writeUInt32BE = function (e, r, i) { e[0 + i] = r >>> 24, e[1 + i] = r >>> 16 & 255, e[2 + i] = r >>> 8 & 255, e[3 + i] = r & 255 }; Ht.ip = function (e, r, i, n) { for (var f = 0, h = 0, c = 6; c >= 0; c -= 2) { for (var y = 0; y <= 24; y += 8)f <<= 1, f |= r >>> y + c & 1; for (var y = 0; y <= 24; y += 8)f <<= 1, f |= e >>> y + c & 1 } for (var c = 6; c >= 0; c -= 2) { for (var y = 1; y <= 25; y += 8)h <<= 1, h |= r >>> y + c & 1; for (var y = 1; y <= 25; y += 8)h <<= 1, h |= e >>> y + c & 1 } i[n + 0] = f >>> 0, i[n + 1] = h >>> 0 }; Ht.rip = function (e, r, i, n) { for (var f = 0, h = 0, c = 0; c < 4; c++)for (var y = 24; y >= 0; y -= 8)f <<= 1, f |= r >>> y + c & 1, f <<= 1, f |= e >>> y + c & 1; for (var c = 4; c < 8; c++)for (var y = 24; y >= 0; y -= 8)h <<= 1, h |= r >>> y + c & 1, h <<= 1, h |= e >>> y + c & 1; i[n + 0] = f >>> 0, i[n + 1] = h >>> 0 }; Ht.pc1 = function (e, r, i, n) { for (var f = 0, h = 0, c = 7; c >= 5; c--) { for (var y = 0; y <= 24; y += 8)f <<= 1, f |= r >> y + c & 1; for (var y = 0; y <= 24; y += 8)f <<= 1, f |= e >> y + c & 1 } for (var y = 0; y <= 24; y += 8)f <<= 1, f |= r >> y + c & 1; for (var c = 1; c <= 3; c++) { for (var y = 0; y <= 24; y += 8)h <<= 1, h |= r >> y + c & 1; for (var y = 0; y <= 24; y += 8)h <<= 1, h |= e >> y + c & 1 } for (var y = 0; y <= 24; y += 8)h <<= 1, h |= e >> y + c & 1; i[n + 0] = f >>> 0, i[n + 1] = h >>> 0 }; Ht.r28shl = function (e, r) { return e << r & 268435455 | e >>> 28 - r }; var ao = [14, 11, 17, 4, 27, 23, 25, 0, 13, 22, 7, 18, 5, 9, 16, 24, 2, 20, 12, 21, 1, 8, 15, 26, 15, 4, 25, 19, 9, 1, 26, 16, 5, 11, 23, 8, 12, 7, 17, 0, 22, 3, 10, 14, 6, 20, 27, 24]; Ht.pc2 = function (e, r, i, n) { for (var f = 0, h = 0, c = ao.length >>> 1, y = 0; y < c; y++)f <<= 1, f |= e >>> ao[y] & 1; for (var y = c; y < ao.length; y++)h <<= 1, h |= r >>> ao[y] & 1; i[n + 0] = f >>> 0, i[n + 1] = h >>> 0 }; Ht.expand = function (e, r, i) { var n = 0, f = 0; n = (e & 1) << 5 | e >>> 27; for (var h = 23; h >= 15; h -= 4)n <<= 6, n |= e >>> h & 63; for (var h = 11; h >= 3; h -= 4)f |= e >>> h & 63, f <<= 6; f |= (e & 31) << 1 | e >>> 31, r[i + 0] = n >>> 0, r[i + 1] = f >>> 0 }; var K1 = [14, 0, 4, 15, 13, 7, 1, 4, 2, 14, 15, 2, 11, 13, 8, 1, 3, 10, 10, 6, 6, 12, 12, 11, 5, 9, 9, 5, 0, 3, 7, 8, 4, 15, 1, 12, 14, 8, 8, 2, 13, 4, 6, 9, 2, 1, 11, 7, 15, 5, 12, 11, 9, 3, 7, 14, 3, 10, 10, 0, 5, 6, 0, 13, 15, 3, 1, 13, 8, 4, 14, 7, 6, 15, 11, 2, 3, 8, 4, 14, 9, 12, 7, 0, 2, 1, 13, 10, 12, 6, 0, 9, 5, 11, 10, 5, 0, 13, 14, 8, 7, 10, 11, 1, 10, 3, 4, 15, 13, 4, 1, 2, 5, 11, 8, 6, 12, 7, 6, 12, 9, 0, 3, 5, 2, 14, 15, 9, 10, 13, 0, 7, 9, 0, 14, 9, 6, 3, 3, 4, 15, 6, 5, 10, 1, 2, 13, 8, 12, 5, 7, 14, 11, 12, 4, 11, 2, 15, 8, 1, 13, 1, 6, 10, 4, 13, 9, 0, 8, 6, 15, 9, 3, 8, 0, 7, 11, 4, 1, 15, 2, 14, 12, 3, 5, 11, 10, 5, 14, 2, 7, 12, 7, 13, 13, 8, 14, 11, 3, 5, 0, 6, 6, 15, 9, 0, 10, 3, 1, 4, 2, 7, 8, 2, 5, 12, 11, 1, 12, 10, 4, 14, 15, 9, 10, 3, 6, 15, 9, 0, 0, 6, 12, 10, 11, 1, 7, 13, 13, 8, 15, 9, 1, 4, 3, 5, 14, 11, 5, 12, 2, 7, 8, 2, 4, 14, 2, 14, 12, 11, 4, 2, 1, 12, 7, 4, 10, 7, 11, 13, 6, 1, 8, 5, 5, 0, 3, 15, 15, 10, 13, 3, 0, 9, 14, 8, 9, 6, 4, 11, 2, 8, 1, 12, 11, 7, 10, 1, 13, 14, 7, 2, 8, 13, 15, 6, 9, 15, 12, 0, 5, 9, 6, 10, 3, 4, 0, 5, 14, 3, 12, 10, 1, 15, 10, 4, 15, 2, 9, 7, 2, 12, 6, 9, 8, 5, 0, 6, 13, 1, 3, 13, 4, 14, 14, 0, 7, 11, 5, 3, 11, 8, 9, 4, 14, 3, 15, 2, 5, 12, 2, 9, 8, 5, 12, 15, 3, 10, 7, 11, 0, 14, 4, 1, 10, 7, 1, 6, 13, 0, 11, 8, 6, 13, 4, 13, 11, 0, 2, 11, 14, 7, 15, 4, 0, 9, 8, 1, 13, 10, 3, 14, 12, 3, 9, 5, 7, 12, 5, 2, 10, 15, 6, 8, 1, 6, 1, 6, 4, 11, 11, 13, 13, 8, 12, 1, 3, 4, 7, 10, 14, 7, 10, 9, 15, 5, 6, 0, 8, 15, 0, 14, 5, 2, 9, 3, 2, 12, 13, 1, 2, 15, 8, 13, 4, 8, 6, 10, 15, 3, 11, 7, 1, 4, 10, 12, 9, 5, 3, 6, 14, 11, 5, 0, 0, 14, 12, 9, 7, 2, 7, 2, 11, 1, 4, 14, 1, 7, 9, 4, 12, 10, 14, 8, 2, 13, 0, 15, 6, 12, 10, 9, 13, 0, 15, 3, 3, 5, 5, 6, 8, 11]; Ht.substitute = function (e, r) { for (var i = 0, n = 0; n < 4; n++) { var f = e >>> 18 - n * 6 & 63, h = K1[n * 64 + f]; i <<= 4, i |= h } for (var n = 0; n < 4; n++) { var f = r >>> 18 - n * 6 & 63, h = K1[4 * 64 + n * 64 + f]; i <<= 4, i |= h } return i >>> 0 }; var V1 = [16, 25, 12, 11, 3, 20, 4, 15, 31, 17, 9, 6, 27, 14, 1, 22, 30, 24, 8, 18, 0, 5, 29, 23, 13, 19, 2, 26, 10, 21, 28, 7]; Ht.permute = function (e) { for (var r = 0, i = 0; i < V1.length; i++)r <<= 1, r |= e >>> V1[i] & 1; return r >>> 0 }; Ht.padSplit = function (e, r, i) { for (var n = e.toString(2); n.length < r;)n = "0" + n; for (var f = [], h = 0; h < r; h += i)f.push(n.slice(h, h + i)); return f.join(" ") } }); var fo = I((wA, G1) => { "use strict"; var Lw = Tt(); function jt(t) { this.options = t, this.type = this.options.type, this.blockSize = 8, this._init(), this.buffer = new Array(this.blockSize), this.bufferOff = 0 } G1.exports = jt; jt.prototype._init = function () { }; jt.prototype.update = function (e) { return e.length === 0 ? [] : this.type === "decrypt" ? this._updateDecrypt(e) : this._updateEncrypt(e) }; jt.prototype._buffer = function (e, r) { for (var i = Math.min(this.buffer.length - this.bufferOff, e.length - r), n = 0; n < i; n++)this.buffer[this.bufferOff + n] = e[r + n]; return this.bufferOff += i, i }; jt.prototype._flushBuffer = function (e, r) { return this._update(this.buffer, 0, e, r), this.bufferOff = 0, this.blockSize }; jt.prototype._updateEncrypt = function (e) { var r = 0, i = 0, n = (this.bufferOff + e.length) / this.blockSize | 0, f = new Array(n * this.blockSize); this.bufferOff !== 0 && (r += this._buffer(e, r), this.bufferOff === this.buffer.length && (i += this._flushBuffer(f, i))); for (var h = e.length - (e.length - r) % this.blockSize; r < h; r += this.blockSize)this._update(e, r, f, i), i += this.blockSize; for (; r < e.length; r++, this.bufferOff++)this.buffer[this.bufferOff] = e[r]; return f }; jt.prototype._updateDecrypt = function (e) { for (var r = 0, i = 0, n = Math.ceil((this.bufferOff + e.length) / this.blockSize) - 1, f = new Array(n * this.blockSize); n > 0; n--)r += this._buffer(e, r), i += this._flushBuffer(f, i); return r += this._buffer(e, r), f }; jt.prototype.final = function (e) { var r; e && (r = this.update(e)); var i; return this.type === "encrypt" ? i = this._finalEncrypt() : i = this._finalDecrypt(), r ? r.concat(i) : i }; jt.prototype._pad = function (e, r) { if (r === 0) return !1; for (; r < e.length;)e[r++] = 0; return !0 }; jt.prototype._finalEncrypt = function () { if (!this._pad(this.buffer, this.bufferOff)) return []; var e = new Array(this.blockSize); return this._update(this.buffer, 0, e, 0), e }; jt.prototype._unpad = function (e) { return e }; jt.prototype._finalDecrypt = function () { Lw.equal(this.bufferOff, this.blockSize, "Not enough data to decrypt"); var e = new Array(this.blockSize); return this._flushBuffer(e, 0), this._unpad(e) } }); var V0 = I((_A, Y1) => { "use strict"; var $1 = Tt(), Hw = Re(), it = K0(), X1 = fo(); function jw() { this.tmp = new Array(2), this.keys = null } function Pr(t) { X1.call(this, t); var e = new jw; this._desState = e, this.deriveKeys(e, t.key) } Hw(Pr, X1); Y1.exports = Pr; Pr.create = function (e) { return new Pr(e) }; var zw = [1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1]; Pr.prototype.deriveKeys = function (e, r) { e.keys = new Array(16 * 2), $1.equal(r.length, this.blockSize, "Invalid key length"); var i = it.readUInt32BE(r, 0), n = it.readUInt32BE(r, 4); it.pc1(i, n, e.tmp, 0), i = e.tmp[0], n = e.tmp[1]; for (var f = 0; f < e.keys.length; f += 2) { var h = zw[f >>> 1]; i = it.r28shl(i, h), n = it.r28shl(n, h), it.pc2(i, n, e.keys, f) } }; Pr.prototype._update = function (e, r, i, n) { var f = this._desState, h = it.readUInt32BE(e, r), c = it.readUInt32BE(e, r + 4); it.ip(h, c, f.tmp, 0), h = f.tmp[0], c = f.tmp[1], this.type === "encrypt" ? this._encrypt(f, h, c, f.tmp, 0) : this._decrypt(f, h, c, f.tmp, 0), h = f.tmp[0], c = f.tmp[1], it.writeUInt32BE(i, h, n), it.writeUInt32BE(i, c, n + 4) }; Pr.prototype._pad = function (e, r) { for (var i = e.length - r, n = r; n < e.length; n++)e[n] = i; return !0 }; Pr.prototype._unpad = function (e) { for (var r = e[e.length - 1], i = e.length - r; i < e.length; i++)$1.equal(e[i], r); return e.slice(0, e.length - r) }; Pr.prototype._encrypt = function (e, r, i, n, f) { for (var h = r, c = i, y = 0; y < e.keys.length; y += 2) { var x = e.keys[y], M = e.keys[y + 1]; it.expand(c, e.tmp, 0), x ^= e.tmp[0], M ^= e.tmp[1]; var E = it.substitute(x, M), A = it.permute(E), B = c; c = (h ^ A) >>> 0, h = B } it.rip(c, h, n, f) }; Pr.prototype._decrypt = function (e, r, i, n, f) { for (var h = i, c = r, y = e.keys.length - 2; y >= 0; y -= 2) { var x = e.keys[y], M = e.keys[y + 1]; it.expand(h, e.tmp, 0), x ^= e.tmp[0], M ^= e.tmp[1]; var E = it.substitute(x, M), A = it.permute(E), B = h; h = (c ^ A) >>> 0, c = B } it.rip(h, c, n, f) } }); var J1 = I(Z1 => { "use strict"; var Ww = Tt(), Kw = Re(), so = {}; function Vw(t) { Ww.equal(t.length, 8, "Invalid IV length"), this.iv = new Array(8); for (var e = 0; e < this.iv.length; e++)this.iv[e] = t[e] } function Gw(t) { function e(f) { t.call(this, f), this._cbcInit() } Kw(e, t); for (var r = Object.keys(so), i = 0; i < r.length; i++) { var n = r[i]; e.prototype[n] = so[n] } return e.create = function (h) { return new e(h) }, e } Z1.instantiate = Gw; so._cbcInit = function () { var e = new Vw(this.options.iv); this._cbcState = e }; so._update = function (e, r, i, n) { var f = this._cbcState, h = this.constructor.super_.prototype, c = f.iv; if (this.type === "encrypt") { for (var y = 0; y < this.blockSize; y++)c[y] ^= e[r + y]; h._update.call(this, c, 0, i, n); for (var y = 0; y < this.blockSize; y++)c[y] = i[n + y] } else { h._update.call(this, e, r, i, n); for (var y = 0; y < this.blockSize; y++)i[n + y] ^= c[y]; for (var y = 0; y < this.blockSize; y++)c[y] = e[r + y] } } }); var tv = I((MA, ev) => { "use strict"; var $w = Tt(), Xw = Re(), Q1 = fo(), ji = V0(); function Yw(t, e) { $w.equal(e.length, 24, "Invalid key length"); var r = e.slice(0, 8), i = e.slice(8, 16), n = e.slice(16, 24); t === "encrypt" ? this.ciphers = [ji.create({ type: "encrypt", key: r }), ji.create({ type: "decrypt", key: i }), ji.create({ type: "encrypt", key: n })] : this.ciphers = [ji.create({ type: "decrypt", key: n }), ji.create({ type: "encrypt", key: i }), ji.create({ type: "decrypt", key: r })] } function gn(t) { Q1.call(this, t); var e = new Yw(this.type, this.options.key); this._edeState = e } Xw(gn, Q1); ev.exports = gn; gn.create = function (e) { return new gn(e) }; gn.prototype._update = function (e, r, i, n) { var f = this._edeState; f.ciphers[0]._update(e, r, i, n), f.ciphers[1]._update(i, n, i, n), f.ciphers[2]._update(i, n, i, n) }; gn.prototype._pad = ji.prototype._pad; gn.prototype._unpad = ji.prototype._unpad }); var rv = I(ha => { "use strict"; ha.utils = K0(); ha.Cipher = fo(); ha.DES = V0(); ha.CBC = J1(); ha.EDE = tv() }); var av = I((EA, nv) => { var iv = Jr(), Qr = rv(), Zw = Re(), wn = Te().Buffer, yf = { "des-ede3-cbc": Qr.CBC.instantiate(Qr.EDE), "des-ede3": Qr.EDE, "des-ede-cbc": Qr.CBC.instantiate(Qr.EDE), "des-ede": Qr.EDE, "des-cbc": Qr.CBC.instantiate(Qr.DES), "des-ecb": Qr.DES }; yf.des = yf["des-cbc"]; yf.des3 = yf["des-ede3-cbc"]; nv.exports = oo; Zw(oo, iv); function oo(t) { iv.call(this); var e = t.mode.toLowerCase(), r = yf[e], i; t.decrypt ? i = "decrypt" : i = "encrypt"; var n = t.key; wn.isBuffer(n) || (n = wn.from(n)), (e === "des-ede" || e === "des-ede-cbc") && (n = wn.concat([n, n.slice(0, 8)])); var f = t.iv; wn.isBuffer(f) || (f = wn.from(f)), this._des = r.create({ key: n, iv: f, type: i }) } oo.prototype._update = function (t) { return wn.from(this._des.update(t)) }; oo.prototype._final = function () { return wn.from(this._des.final()) } }); var fv = I(G0 => { G0.encrypt = function (t, e) { return t._cipher.encryptBlock(e) }; G0.decrypt = function (t, e) { return t._cipher.decryptBlock(e) } }); var ua = I((BA, sv) => { sv.exports = function (e, r) { for (var i = Math.min(e.length, r.length), n = new Buffer(i), f = 0; f < i; ++f)n[f] = e[f] ^ r[f]; return n } }); var hv = I($0 => { var ov = ua(); $0.encrypt = function (t, e) { var r = ov(e, t._prev); return t._prev = t._cipher.encryptBlock(r), t._prev }; $0.decrypt = function (t, e) { var r = t._prev; t._prev = e; var i = t._cipher.decryptBlock(e); return ov(i, r) } }); var dv = I(cv => { var mf = Te().Buffer, Jw = ua(); function uv(t, e, r) { var i = e.length, n = Jw(e, t._cache); return t._cache = t._cache.slice(i), t._prev = mf.concat([t._prev, r ? e : n]), n } cv.encrypt = function (t, e, r) { for (var i = mf.allocUnsafe(0), n; e.length;)if (t._cache.length === 0 && (t._cache = t._cipher.encryptBlock(t._prev), t._prev = mf.allocUnsafe(0)), t._cache.length <= e.length) n = t._cache.length, i = mf.concat([i, uv(t, e.slice(0, n), r)]), e = e.slice(n); else { i = mf.concat([i, uv(t, e, r)]); break } return i } }); var pv = I(lv => { var X0 = Te().Buffer; function Qw(t, e, r) { var i = t._cipher.encryptBlock(t._prev), n = i[0] ^ e; return t._prev = X0.concat([t._prev.slice(1), X0.from([r ? e : n])]), n } lv.encrypt = function (t, e, r) { for (var i = e.length, n = X0.allocUnsafe(i), f = -1; ++f < i;)n[f] = Qw(t, e[f], r); return n } }); var bv = I(vv => { var ho = Te().Buffer; function e7(t, e, r) { for (var i, n = -1, f = 8, h = 0, c, y; ++n < f;)i = t._cipher.encryptBlock(t._prev), c = e & 1 << 7 - n ? 128 : 0, y = i[0] ^ c, h += (y & 128) >> n % 8, t._prev = t7(t._prev, r ? c : y); return h } function t7(t, e) { var r = t.length, i = -1, n = ho.allocUnsafe(t.length); for (t = ho.concat([t, ho.from([e])]); ++i < r;)n[i] = t[i] << 1 | t[i + 1] >> 7; return n } vv.encrypt = function (t, e, r) { for (var i = e.length, n = ho.allocUnsafe(i), f = -1; ++f < i;)n[f] = e7(t, e[f], r); return n } }); var mv = I(yv => { var r7 = ua(); function i7(t) { return t._prev = t._cipher.encryptBlock(t._prev), t._prev } yv.encrypt = function (t, e) { for (; t._cache.length < e.length;)t._cache = Buffer.concat([t._cache, i7(t)]); var r = t._cache.slice(0, e.length); return t._cache = t._cache.slice(e.length), r7(e, r) } }); var Y0 = I((PA, gv) => { function n7(t) { for (var e = t.length, r; e--;)if (r = t.readUInt8(e), r === 255) t.writeUInt8(0, e); else { r++, t.writeUInt8(r, e); break } } gv.exports = n7 }); var J0 = I(_v => { var a7 = ua(), wv = Te().Buffer, f7 = Y0(); function s7(t) { var e = t._cipher.encryptBlockRaw(t._prev); return f7(t._prev), e } var Z0 = 16; _v.encrypt = function (t, e) { var r = Math.ceil(e.length / Z0), i = t._cache.length; t._cache = wv.concat([t._cache, wv.allocUnsafe(r * Z0)]); for (var n = 0; n < r; n++) { var f = s7(t), h = i + n * Z0; t._cache.writeUInt32BE(f[0], h + 0), t._cache.writeUInt32BE(f[1], h + 4), t._cache.writeUInt32BE(f[2], h + 8), t._cache.writeUInt32BE(f[3], h + 12) } var c = t._cache.slice(0, e.length); return t._cache = t._cache.slice(e.length), a7(e, c) } }); var Q0 = I((OA, o7) => { o7.exports = { "aes-128-ecb": { cipher: "AES", key: 128, iv: 0, mode: "ECB", type: "block" }, "aes-192-ecb": { cipher: "AES", key: 192, iv: 0, mode: "ECB", type: "block" }, "aes-256-ecb": { cipher: "AES", key: 256, iv: 0, mode: "ECB", type: "block" }, "aes-128-cbc": { cipher: "AES", key: 128, iv: 16, mode: "CBC", type: "block" }, "aes-192-cbc": { cipher: "AES", key: 192, iv: 16, mode: "CBC", type: "block" }, "aes-256-cbc": { cipher: "AES", key: 256, iv: 16, mode: "CBC", type: "block" }, aes128: { cipher: "AES", key: 128, iv: 16, mode: "CBC", type: "block" }, aes192: { cipher: "AES", key: 192, iv: 16, mode: "CBC", type: "block" }, aes256: { cipher: "AES", key: 256, iv: 16, mode: "CBC", type: "block" }, "aes-128-cfb": { cipher: "AES", key: 128, iv: 16, mode: "CFB", type: "stream" }, "aes-192-cfb": { cipher: "AES", key: 192, iv: 16, mode: "CFB", type: "stream" }, "aes-256-cfb": { cipher: "AES", key: 256, iv: 16, mode: "CFB", type: "stream" }, "aes-128-cfb8": { cipher: "AES", key: 128, iv: 16, mode: "CFB8", type: "stream" }, "aes-192-cfb8": { cipher: "AES", key: 192, iv: 16, mode: "CFB8", type: "stream" }, "aes-256-cfb8": { cipher: "AES", key: 256, iv: 16, mode: "CFB8", type: "stream" }, "aes-128-cfb1": { cipher: "AES", key: 128, iv: 16, mode: "CFB1", type: "stream" }, "aes-192-cfb1": { cipher: "AES", key: 192, iv: 16, mode: "CFB1", type: "stream" }, "aes-256-cfb1": { cipher: "AES", key: 256, iv: 16, mode: "CFB1", type: "stream" }, "aes-128-ofb": { cipher: "AES", key: 128, iv: 16, mode: "OFB", type: "stream" }, "aes-192-ofb": { cipher: "AES", key: 192, iv: 16, mode: "OFB", type: "stream" }, "aes-256-ofb": { cipher: "AES", key: 256, iv: 16, mode: "OFB", type: "stream" }, "aes-128-ctr": { cipher: "AES", key: 128, iv: 16, mode: "CTR", type: "stream" }, "aes-192-ctr": { cipher: "AES", key: 192, iv: 16, mode: "CTR", type: "stream" }, "aes-256-ctr": { cipher: "AES", key: 256, iv: 16, mode: "CTR", type: "stream" }, "aes-128-gcm": { cipher: "AES", key: 128, iv: 12, mode: "GCM", type: "auth" }, "aes-192-gcm": { cipher: "AES", key: 192, iv: 12, mode: "GCM", type: "auth" }, "aes-256-gcm": { cipher: "AES", key: 256, iv: 12, mode: "GCM", type: "auth" } } }); var co = I((DA, Mv) => { var h7 = { ECB: fv(), CBC: hv(), CFB: dv(), CFB8: pv(), CFB1: bv(), OFB: mv(), CTR: J0(), GCM: J0() }, uo = Q0(); for (var xv in uo) uo[xv].module = h7[uo[xv].mode]; Mv.exports = uo }); var gf = I((FA, Ev) => { var lo = Te().Buffer; function eu(t) { lo.isBuffer(t) || (t = lo.from(t)); for (var e = t.length / 4 | 0, r = new Array(e), i = 0; i < e; i++)r[i] = t.readUInt32BE(i * 4); return r } function tu(t) { for (var e = 0; e < t.length; t++)t[e] = 0 } function Sv(t, e, r, i, n) { for (var f = r[0], h = r[1], c = r[2], y = r[3], x = t[0] ^ e[0], M = t[1] ^ e[1], E = t[2] ^ e[2], A = t[3] ^ e[3], B, T, C, H, F = 4, we = 1; we < n; we++)B = f[x >>> 24] ^ h[M >>> 16 & 255] ^ c[E >>> 8 & 255] ^ y[A & 255] ^ e[F++], T = f[M >>> 24] ^ h[E >>> 16 & 255] ^ c[A >>> 8 & 255] ^ y[x & 255] ^ e[F++], C = f[E >>> 24] ^ h[A >>> 16 & 255] ^ c[x >>> 8 & 255] ^ y[M & 255] ^ e[F++], H = f[A >>> 24] ^ h[x >>> 16 & 255] ^ c[M >>> 8 & 255] ^ y[E & 255] ^ e[F++], x = B, M = T, E = C, A = H; return B = (i[x >>> 24] << 24 | i[M >>> 16 & 255] << 16 | i[E >>> 8 & 255] << 8 | i[A & 255]) ^ e[F++], T = (i[M >>> 24] << 24 | i[E >>> 16 & 255] << 16 | i[A >>> 8 & 255] << 8 | i[x & 255]) ^ e[F++], C = (i[E >>> 24] << 24 | i[A >>> 16 & 255] << 16 | i[x >>> 8 & 255] << 8 | i[M & 255]) ^ e[F++], H = (i[A >>> 24] << 24 | i[x >>> 16 & 255] << 16 | i[M >>> 8 & 255] << 8 | i[E & 255]) ^ e[F++], B = B >>> 0, T = T >>> 0, C = C >>> 0, H = H >>> 0, [B, T, C, H] } var u7 = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54], et = function () { for (var t = new Array(256), e = 0; e < 256; e++)e < 128 ? t[e] = e << 1 : t[e] = e << 1 ^ 283; for (var r = [], i = [], n = [[], [], [], []], f = [[], [], [], []], h = 0, c = 0, y = 0; y < 256; ++y) { var x = c ^ c << 1 ^ c << 2 ^ c << 3 ^ c << 4; x = x >>> 8 ^ x & 255 ^ 99, r[h] = x, i[x] = h; var M = t[h], E = t[M], A = t[E], B = t[x] * 257 ^ x * 16843008; n[0][h] = B << 24 | B >>> 8, n[1][h] = B << 16 | B >>> 16, n[2][h] = B << 8 | B >>> 24, n[3][h] = B, B = A * 16843009 ^ E * 65537 ^ M * 257 ^ h * 16843008, f[0][x] = B << 24 | B >>> 8, f[1][x] = B << 16 | B >>> 16, f[2][x] = B << 8 | B >>> 24, f[3][x] = B, h === 0 ? h = c = 1 : (h = M ^ t[t[t[A ^ M]]], c ^= t[t[c]]) } return { SBOX: r, INV_SBOX: i, SUB_MIX: n, INV_SUB_MIX: f } }(); function zt(t) { this._key = eu(t), this._reset() } zt.blockSize = 4 * 4; zt.keySize = 256 / 8; zt.prototype.blockSize = zt.blockSize; zt.prototype.keySize = zt.keySize; zt.prototype._reset = function () { for (var t = this._key, e = t.length, r = e + 6, i = (r + 1) * 4, n = [], f = 0; f < e; f++)n[f] = t[f]; for (f = e; f < i; f++) { var h = n[f - 1]; f % e == 0 ? (h = h << 8 | h >>> 24, h = et.SBOX[h >>> 24] << 24 | et.SBOX[h >>> 16 & 255] << 16 | et.SBOX[h >>> 8 & 255] << 8 | et.SBOX[h & 255], h ^= u7[f / e | 0] << 24) : e > 6 && f % e == 4 && (h = et.SBOX[h >>> 24] << 24 | et.SBOX[h >>> 16 & 255] << 16 | et.SBOX[h >>> 8 & 255] << 8 | et.SBOX[h & 255]), n[f] = n[f - e] ^ h } for (var c = [], y = 0; y < i; y++) { var x = i - y, M = n[x - (y % 4 ? 0 : 4)]; y < 4 || x <= 4 ? c[y] = M : c[y] = et.INV_SUB_MIX[0][et.SBOX[M >>> 24]] ^ et.INV_SUB_MIX[1][et.SBOX[M >>> 16 & 255]] ^ et.INV_SUB_MIX[2][et.SBOX[M >>> 8 & 255]] ^ et.INV_SUB_MIX[3][et.SBOX[M & 255]] } this._nRounds = r, this._keySchedule = n, this._invKeySchedule = c }; zt.prototype.encryptBlockRaw = function (t) { return t = eu(t), Sv(t, this._keySchedule, et.SUB_MIX, et.SBOX, this._nRounds) }; zt.prototype.encryptBlock = function (t) { var e = this.encryptBlockRaw(t), r = lo.allocUnsafe(16); return r.writeUInt32BE(e[0], 0), r.writeUInt32BE(e[1], 4), r.writeUInt32BE(e[2], 8), r.writeUInt32BE(e[3], 12), r }; zt.prototype.decryptBlock = function (t) { t = eu(t); var e = t[1]; t[1] = t[3], t[3] = e; var r = Sv(t, this._invKeySchedule, et.INV_SUB_MIX, et.INV_SBOX, this._nRounds), i = lo.allocUnsafe(16); return i.writeUInt32BE(r[0], 0), i.writeUInt32BE(r[3], 4), i.writeUInt32BE(r[2], 8), i.writeUInt32BE(r[1], 12), i }; zt.prototype.scrub = function () { tu(this._keySchedule), tu(this._invKeySchedule), tu(this._key) }; Ev.exports.AES = zt }); var Iv = I((UA, Bv) => { var ca = Te().Buffer, c7 = ca.alloc(16, 0); function d7(t) { return [t.readUInt32BE(0), t.readUInt32BE(4), t.readUInt32BE(8), t.readUInt32BE(12)] } function Av(t) { var e = ca.allocUnsafe(16); return e.writeUInt32BE(t[0] >>> 0, 0), e.writeUInt32BE(t[1] >>> 0, 4), e.writeUInt32BE(t[2] >>> 0, 8), e.writeUInt32BE(t[3] >>> 0, 12), e } function wf(t) { this.h = t, this.state = ca.alloc(16, 0), this.cache = ca.allocUnsafe(0) } wf.prototype.ghash = function (t) { for (var e = -1; ++e < t.length;)this.state[e] ^= t[e]; this._multiply() }; wf.prototype._multiply = function () { for (var t = d7(this.h), e = [0, 0, 0, 0], r, i, n, f = -1; ++f < 128;) { for (i = (this.state[~~(f / 8)] & 1 << 7 - f % 8) != 0, i && (e[0] ^= t[0], e[1] ^= t[1], e[2] ^= t[2], e[3] ^= t[3]), n = (t[3] & 1) != 0, r = 3; r > 0; r--)t[r] = t[r] >>> 1 | (t[r - 1] & 1) << 31; t[0] = t[0] >>> 1, n && (t[0] = t[0] ^ 225 << 24) } this.state = Av(e) }; wf.prototype.update = function (t) { this.cache = ca.concat([this.cache, t]); for (var e; this.cache.length >= 16;)e = this.cache.slice(0, 16), this.cache = this.cache.slice(16), this.ghash(e) }; wf.prototype.final = function (t, e) { return this.cache.length && this.ghash(ca.concat([this.cache, c7], 16)), this.ghash(Av([0, t, 0, e])), this.state }; Bv.exports = wf }); var ru = I((NA, qv) => { var l7 = gf(), Et = Te().Buffer, Rv = Jr(), p7 = Re(), Tv = Iv(), v7 = ua(), b7 = Y0(); function y7(t, e) { var r = 0; t.length !== e.length && r++; for (var i = Math.min(t.length, e.length), n = 0; n < i; ++n)r += t[n] ^ e[n]; return r } function m7(t, e, r) { if (e.length === 12) return t._finID = Et.concat([e, Et.from([0, 0, 0, 1])]), Et.concat([e, Et.from([0, 0, 0, 2])]); var i = new Tv(r), n = e.length, f = n % 16; i.update(e), f && (f = 16 - f, i.update(Et.alloc(f, 0))), i.update(Et.alloc(8, 0)); var h = n * 8, c = Et.alloc(8); c.writeUIntBE(h, 0, 8), i.update(c), t._finID = i.state; var y = Et.from(t._finID); return b7(y), y } function _n(t, e, r, i) { Rv.call(this); var n = Et.alloc(4, 0); this._cipher = new l7.AES(e); var f = this._cipher.encryptBlock(n); this._ghash = new Tv(f), r = m7(this, r, f), this._prev = Et.from(r), this._cache = Et.allocUnsafe(0), this._secCache = Et.allocUnsafe(0), this._decrypt = i, this._alen = 0, this._len = 0, this._mode = t, this._authTag = null, this._called = !1 } p7(_n, Rv); _n.prototype._update = function (t) { if (!this._called && this._alen) { var e = 16 - this._alen % 16; e < 16 && (e = Et.alloc(e, 0), this._ghash.update(e)) } this._called = !0; var r = this._mode.encrypt(this, t); return this._decrypt ? this._ghash.update(t) : this._ghash.update(r), this._len += t.length, r }; _n.prototype._final = function () { if (this._decrypt && !this._authTag) throw new Error("Unsupported state or unable to authenticate data"); var t = v7(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID)); if (this._decrypt && y7(t, this._authTag)) throw new Error("Unsupported state or unable to authenticate data"); this._authTag = t, this._cipher.scrub() }; _n.prototype.getAuthTag = function () { if (this._decrypt || !Et.isBuffer(this._authTag)) throw new Error("Attempting to get auth tag in unsupported state"); return this._authTag }; _n.prototype.setAuthTag = function (e) { if (!this._decrypt) throw new Error("Attempting to set auth tag in unsupported state"); this._authTag = e }; _n.prototype.setAAD = function (e) { if (this._called) throw new Error("Attempting to set AAD in unsupported state"); this._ghash.update(e), this._alen += e.length }; qv.exports = _n }); var nu = I((LA, Pv) => { var g7 = gf(), iu = Te().Buffer, kv = Jr(), w7 = Re(); function po(t, e, r, i) { kv.call(this), this._cipher = new g7.AES(e), this._prev = iu.from(r), this._cache = iu.allocUnsafe(0), this._secCache = iu.allocUnsafe(0), this._decrypt = i, this._mode = t } w7(po, kv); po.prototype._update = function (t) { return this._mode.encrypt(this, t, this._decrypt) }; po.prototype._final = function () { this._cipher.scrub() }; Pv.exports = po }); var _f = I((HA, Cv) => { var xn = Te().Buffer, _7 = Gs(); function x7(t, e, r, i) { if (xn.isBuffer(t) || (t = xn.from(t, "binary")), e && (xn.isBuffer(e) || (e = xn.from(e, "binary")), e.length !== 8)) throw new RangeError("salt should be Buffer with 8 byte length"); for (var n = r / 8, f = xn.alloc(n), h = xn.alloc(i || 0), c = xn.alloc(0); n > 0 || i > 0;) { var y = new _7; y.update(c), y.update(t), e && y.update(e), c = y.digest(); var x = 0; if (n > 0) { var M = f.length - n; x = Math.min(n, c.length), c.copy(f, M, 0, x), n -= x } if (x < c.length && i > 0) { var E = h.length - i, A = Math.min(i, c.length - x); c.copy(h, E, x, x + A), i -= A } } return c.fill(0), { key: f, iv: h } } Cv.exports = x7 }); var Uv = I(au => { var Ov = co(), M7 = ru(), ei = Te().Buffer, S7 = nu(), Dv = Jr(), E7 = gf(), A7 = _f(), B7 = Re(); function xf(t, e, r) { Dv.call(this), this._cache = new vo, this._cipher = new E7.AES(e), this._prev = ei.from(r), this._mode = t, this._autopadding = !0 } B7(xf, Dv); xf.prototype._update = function (t) { this._cache.add(t); for (var e, r, i = []; e = this._cache.get();)r = this._mode.encrypt(this, e), i.push(r); return ei.concat(i) }; var I7 = ei.alloc(16, 16); xf.prototype._final = function () { var t = this._cache.flush(); if (this._autopadding) return t = this._mode.encrypt(this, t), this._cipher.scrub(), t; if (!t.equals(I7)) throw this._cipher.scrub(), new Error("data not multiple of block length") }; xf.prototype.setAutoPadding = function (t) { return this._autopadding = !!t, this }; function vo() { this.cache = ei.allocUnsafe(0) } vo.prototype.add = function (t) { this.cache = ei.concat([this.cache, t]) }; vo.prototype.get = function () { if (this.cache.length > 15) { var t = this.cache.slice(0, 16); return this.cache = this.cache.slice(16), t } return null }; vo.prototype.flush = function () { for (var t = 16 - this.cache.length, e = ei.allocUnsafe(t), r = -1; ++r < t;)e.writeUInt8(t, r); return ei.concat([this.cache, e]) }; function Fv(t, e, r) { var i = Ov[t.toLowerCase()]; if (!i) throw new TypeError("invalid suite type"); if (typeof e == "string" && (e = ei.from(e)), e.length !== i.key / 8) throw new TypeError("invalid key length " + e.length); if (typeof r == "string" && (r = ei.from(r)), i.mode !== "GCM" && r.length !== i.iv) throw new TypeError("invalid iv length " + r.length); return i.type === "stream" ? new S7(i.module, e, r) : i.type === "auth" ? new M7(i.module, e, r) : new xf(i.module, e, r) } function R7(t, e) { var r = Ov[t.toLowerCase()]; if (!r) throw new TypeError("invalid suite type"); var i = A7(e, !1, r.key, r.iv); return Fv(t, i.key, i.iv) } au.createCipheriv = Fv; au.createCipher = R7 }); var jv = I(fu => { var T7 = ru(), da = Te().Buffer, Nv = co(), q7 = nu(), Lv = Jr(), k7 = gf(), P7 = _f(), C7 = Re(); function Mf(t, e, r) { Lv.call(this), this._cache = new bo, this._last = void 0, this._cipher = new k7.AES(e), this._prev = da.from(r), this._mode = t, this._autopadding = !0 } C7(Mf, Lv); Mf.prototype._update = function (t) { this._cache.add(t); for (var e, r, i = []; e = this._cache.get(this._autopadding);)r = this._mode.decrypt(this, e), i.push(r); return da.concat(i) }; Mf.prototype._final = function () { var t = this._cache.flush(); if (this._autopadding) return O7(this._mode.decrypt(this, t)); if (t) throw new Error("data not multiple of block length") }; Mf.prototype.setAutoPadding = function (t) { return this._autopadding = !!t, this }; function bo() { this.cache = da.allocUnsafe(0) } bo.prototype.add = function (t) { this.cache = da.concat([this.cache, t]) }; bo.prototype.get = function (t) { var e; if (t) { if (this.cache.length > 16) return e = this.cache.slice(0, 16), this.cache = this.cache.slice(16), e } else if (this.cache.length >= 16) return e = this.cache.slice(0, 16), this.cache = this.cache.slice(16), e; return null }; bo.prototype.flush = function () { if (this.cache.length) return this.cache }; function O7(t) { var e = t[15]; if (e < 1 || e > 16) throw new Error("unable to decrypt data"); for (var r = -1; ++r < e;)if (t[r + (16 - e)] !== e) throw new Error("unable to decrypt data"); if (e !== 16) return t.slice(0, 16 - e) } function Hv(t, e, r) { var i = Nv[t.toLowerCase()]; if (!i) throw new TypeError("invalid suite type"); if (typeof r == "string" && (r = da.from(r)), i.mode !== "GCM" && r.length !== i.iv) throw new TypeError("invalid iv length " + r.length); if (typeof e == "string" && (e = da.from(e)), e.length !== i.key / 8) throw new TypeError("invalid key length " + e.length); return i.type === "stream" ? new q7(i.module, e, r, !0) : i.type === "auth" ? new T7(i.module, e, r, !0) : new Mf(i.module, e, r) } function D7(t, e) { var r = Nv[t.toLowerCase()]; if (!r) throw new TypeError("invalid suite type"); var i = P7(e, !1, r.key, r.iv); return Hv(t, i.key, i.iv) } fu.createDecipher = D7; fu.createDecipheriv = Hv }); var yo = I(gr => { var zv = Uv(), Wv = jv(), F7 = Q0(); function U7() { return Object.keys(F7) } gr.createCipher = gr.Cipher = zv.createCipher; gr.createCipheriv = gr.Cipheriv = zv.createCipheriv; gr.createDecipher = gr.Decipher = Wv.createDecipher; gr.createDecipheriv = gr.Decipheriv = Wv.createDecipheriv; gr.listCiphers = gr.getCiphers = U7 }); var Kv = I(ti => { ti["des-ecb"] = { key: 8, iv: 0 }; ti["des-cbc"] = ti.des = { key: 8, iv: 8 }; ti["des-ede3-cbc"] = ti.des3 = { key: 24, iv: 8 }; ti["des-ede3"] = { key: 24, iv: 0 }; ti["des-ede-cbc"] = { key: 16, iv: 8 }; ti["des-ede"] = { key: 16, iv: 0 } }); var Yv = I(wr => { var Vv = av(), su = yo(), zi = co(), ri = Kv(), Gv = _f(); function N7(t, e) { t = t.toLowerCase(); var r, i; if (zi[t]) r = zi[t].key, i = zi[t].iv; else if (ri[t]) r = ri[t].key * 8, i = ri[t].iv; else throw new TypeError("invalid suite type"); var n = Gv(e, !1, r, i); return $v(t, n.key, n.iv) } function L7(t, e) { t = t.toLowerCase(); var r, i; if (zi[t]) r = zi[t].key, i = zi[t].iv; else if (ri[t]) r = ri[t].key * 8, i = ri[t].iv; else throw new TypeError("invalid suite type"); var n = Gv(e, !1, r, i); return Xv(t, n.key, n.iv) } function $v(t, e, r) { if (t = t.toLowerCase(), zi[t]) return su.createCipheriv(t, e, r); if (ri[t]) return new Vv({ key: e, iv: r, mode: t }); throw new TypeError("invalid suite type") } function Xv(t, e, r) { if (t = t.toLowerCase(), zi[t]) return su.createDecipheriv(t, e, r); if (ri[t]) return new Vv({ key: e, iv: r, mode: t, decrypt: !0 }); throw new TypeError("invalid suite type") } function H7() { return Object.keys(ri).concat(su.getCiphers()) } wr.createCipher = wr.Cipher = N7; wr.createCipheriv = wr.Cipheriv = $v; wr.createDecipher = wr.Decipher = L7; wr.createDecipheriv = wr.Decipheriv = Xv; wr.listCiphers = wr.getCiphers = H7 }); var ou = I((GA, Zv) => { var Mn = rt(), j7 = mo(); function Sn(t) { this.rand = t || new j7.Rand } Zv.exports = Sn; Sn.create = function (e) { return new Sn(e) }; Sn.prototype._randbelow = function (e) { var r = e.bitLength(), i = Math.ceil(r / 8); do var n = new Mn(this.rand.generate(i)); while (n.cmp(e) >= 0); return n }; Sn.prototype._randrange = function (e, r) { var i = r.sub(e); return e.add(this._randbelow(i)) }; Sn.prototype.test = function (e, r, i) { var n = e.bitLength(), f = Mn.mont(e), h = new Mn(1).toRed(f); r || (r = Math.max(1, n / 48 | 0)); for (var c = e.subn(1), y = 0; !c.testn(y); y++); for (var x = e.shrn(y), M = c.toRed(f), E = !0; r > 0; r--) { var A = this._randrange(new Mn(2), c); i && i(A); var B = A.toRed(f).redPow(x); if (!(B.cmp(h) === 0 || B.cmp(M) === 0)) { for (var T = 1; T < y; T++) { if (B = B.redSqr(), B.cmp(h) === 0) return !1; if (B.cmp(M) === 0) break } if (T === y) return !1 } } return E }; Sn.prototype.getDivisor = function (e, r) { var i = e.bitLength(), n = Mn.mont(e), f = new Mn(1).toRed(n); r || (r = Math.max(1, i / 48 | 0)); for (var h = e.subn(1), c = 0; !h.testn(c); c++); for (var y = e.shrn(c), x = h.toRed(n); r > 0; r--) { var M = this._randrange(new Mn(2), h), E = e.gcd(M); if (E.cmpn(1) !== 0) return E; var A = M.toRed(n).redPow(y); if (!(A.cmp(f) === 0 || A.cmp(x) === 0)) { for (var B = 1; B < c; B++) { if (A = A.redSqr(), A.cmp(f) === 0) return A.fromRed().subn(1).gcd(e); if (A.cmp(x) === 0) break } if (B === c) return A = A.redSqr(), A.fromRed().subn(1).gcd(e) } } return !1 } }); var pu = I((JA, eb) => { var z7 = an(); eb.exports = lu; lu.simpleSieve = cu; lu.fermatTest = du; var dt = rt(), W7 = new dt(24), K7 = ou(), Jv = new K7, V7 = new dt(1), hu = new dt(2), G7 = new dt(5), $A = new dt(16), XA = new dt(8), $7 = new dt(10), X7 = new dt(3), YA = new dt(7), Y7 = new dt(11), Qv = new dt(4), ZA = new dt(12), uu = null; function Z7() { if (uu !== null) return uu; var t = 1048576, e = []; e[0] = 2; for (var r = 1, i = 3; i < t; i += 2) { for (var n = Math.ceil(Math.sqrt(i)), f = 0; f < r && e[f] <= n && i % e[f] != 0; f++); r !== f && e[f] <= n || (e[r++] = i) } return uu = e, e } function cu(t) { for (var e = Z7(), r = 0; r < e.length; r++)if (t.modn(e[r]) === 0) return t.cmpn(e[r]) === 0; return !0 } function du(t) { var e = dt.mont(t); return hu.toRed(e).redPow(t.subn(1)).fromRed().cmpn(1) === 0 } function lu(t, e) { if (t < 16) return e === 2 || e === 5 ? new dt([140, 123]) : new dt([140, 39]); e = new dt(e); for (var r, i; ;) { for (r = new dt(z7(Math.ceil(t / 8))); r.bitLength() > t;)r.ishrn(1); if (r.isEven() && r.iadd(V7), r.testn(1) || r.iadd(hu), e.cmp(hu)) { if (!e.cmp(G7)) for (; r.mod($7).cmp(X7);)r.iadd(Qv) } else for (; r.mod(W7).cmp(Y7);)r.iadd(Qv); if (i = r.shrn(1), cu(i) && cu(r) && du(i) && du(r) && Jv.test(i) && Jv.test(r)) return r } } }); var tb = I((QA, J7) => { J7.exports = { modp1: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff" }, modp2: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff" }, modp5: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff" }, modp14: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff" }, modp15: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff" }, modp16: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff" }, modp17: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff" }, modp18: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff" } } }); var ab = I((eB, nb) => { var Wt = rt(), Q7 = ou(), rb = new Q7, e9 = new Wt(24), t9 = new Wt(11), r9 = new Wt(10), i9 = new Wt(3), n9 = new Wt(7), ib = pu(), a9 = an(); nb.exports = ii; function f9(t, e) { return e = e || "utf8", Buffer.isBuffer(t) || (t = new Buffer(t, e)), this._pub = new Wt(t), this } function s9(t, e) { return e = e || "utf8", Buffer.isBuffer(t) || (t = new Buffer(t, e)), this._priv = new Wt(t), this } var go = {}; function o9(t, e) { var r = e.toString("hex"), i = [r, t.toString(16)].join("_"); if (i in go) return go[i]; var n = 0; if (t.isEven() || !ib.simpleSieve || !ib.fermatTest(t) || !rb.test(t)) return n += 1, r === "02" || r === "05" ? n += 8 : n += 4, go[i] = n, n; rb.test(t.shrn(1)) || (n += 2); var f; switch (r) { case "02": t.mod(e9).cmp(t9) && (n += 8); break; case "05": f = t.mod(r9), f.cmp(i9) && f.cmp(n9) && (n += 8); break; default: n += 4 }return go[i] = n, n } function ii(t, e, r) { this.setGenerator(e), this.__prime = new Wt(t), this._prime = Wt.mont(this.__prime), this._primeLen = t.length, this._pub = void 0, this._priv = void 0, this._primeCode = void 0, r ? (this.setPublicKey = f9, this.setPrivateKey = s9) : this._primeCode = 8 } Object.defineProperty(ii.prototype, "verifyError", { enumerable: !0, get: function () { return typeof this._primeCode != "number" && (this._primeCode = o9(this.__prime, this.__gen)), this._primeCode } }); ii.prototype.generateKeys = function () { return this._priv || (this._priv = new Wt(a9(this._primeLen))), this._pub = this._gen.toRed(this._prime).redPow(this._priv).fromRed(), this.getPublicKey() }; ii.prototype.computeSecret = function (t) { t = new Wt(t), t = t.toRed(this._prime); var e = t.redPow(this._priv).fromRed(), r = new Buffer(e.toArray()), i = this.getPrime(); if (r.length < i.length) { var n = new Buffer(i.length - r.length); n.fill(0), r = Buffer.concat([n, r]) } return r }; ii.prototype.getPublicKey = function (e) { return wo(this._pub, e) }; ii.prototype.getPrivateKey = function (e) { return wo(this._priv, e) }; ii.prototype.getPrime = function (t) { return wo(this.__prime, t) }; ii.prototype.getGenerator = function (t) { return wo(this._gen, t) }; ii.prototype.setGenerator = function (t, e) { return e = e || "utf8", Buffer.isBuffer(t) || (t = new Buffer(t, e)), this.__gen = t, this._gen = new Wt(t), this }; function wo(t, e) { var r = new Buffer(t.toArray()); return e ? r.toString(e) : r } }); var ob = I(la => { var h9 = pu(), fb = tb(), vu = ab(); function u9(t) { var e = new Buffer(fb[t].prime, "hex"), r = new Buffer(fb[t].gen, "hex"); return new vu(e, r) } var c9 = { binary: !0, hex: !0, base64: !0 }; function sb(t, e, r, i) { return Buffer.isBuffer(e) || c9[e] === void 0 ? sb(t, "binary", e, r) : (e = e || "binary", i = i || "binary", r = r || new Buffer([2]), Buffer.isBuffer(r) || (r = new Buffer(r, i)), typeof t == "number" ? new vu(h9(t, r), r, !0) : (Buffer.isBuffer(t) || (t = new Buffer(t, e)), new vu(t, r, !0))) } la.DiffieHellmanGroup = la.createDiffieHellmanGroup = la.getDiffieHellman = u9; la.createDiffieHellman = la.DiffieHellman = sb }); var ub = I((hb, bu) => { (function (t, e) { "use strict"; function r(l, a) { if (!l) throw new Error(a || "Assertion failed") } function i(l, a) { l.super_ = a; var s = function () { }; s.prototype = a.prototype, l.prototype = new s, l.prototype.constructor = l } function n(l, a, s) { if (n.isBN(l)) return l; this.negative = 0, this.words = null, this.length = 0, this.red = null, l !== null && ((a === "le" || a === "be") && (s = a, a = 10), this._init(l || 0, a || 10, s || "be")) } typeof t == "object" ? t.exports = n : e.BN = n, n.BN = n, n.wordSize = 26; var f; try { typeof window != "undefined" && typeof window.Buffer != "undefined" ? f = window.Buffer : f = ct().Buffer } catch (l) { } n.isBN = function (a) { return a instanceof n ? !0 : a !== null && typeof a == "object" && a.constructor.wordSize === n.wordSize && Array.isArray(a.words) }, n.max = function (a, s) { return a.cmp(s) > 0 ? a : s }, n.min = function (a, s) { return a.cmp(s) < 0 ? a : s }, n.prototype._init = function (a, s, d) { if (typeof a == "number") return this._initNumber(a, s, d); if (typeof a == "object") return this._initArray(a, s, d); s === "hex" && (s = 16), r(s === (s | 0) && s >= 2 && s <= 36), a = a.toString().replace(/\s+/g, ""); var v = 0; a[0] === "-" && (v++, this.negative = 1), v < a.length && (s === 16 ? this._parseHex(a, v, d) : (this._parseBase(a, s, v), d === "le" && this._initArray(this.toArray(), s, d))) }, n.prototype._initNumber = function (a, s, d) { a < 0 && (this.negative = 1, a = -a), a < 67108864 ? (this.words = [a & 67108863], this.length = 1) : a < 4503599627370496 ? (this.words = [a & 67108863, a / 67108864 & 67108863], this.length = 2) : (r(a < 9007199254740992), this.words = [a & 67108863, a / 67108864 & 67108863, 1], this.length = 3), d === "le" && this._initArray(this.toArray(), s, d) }, n.prototype._initArray = function (a, s, d) { if (r(typeof a.length == "number"), a.length <= 0) return this.words = [0], this.length = 1, this; this.length = Math.ceil(a.length / 3), this.words = new Array(this.length); for (var v = 0; v < this.length; v++)this.words[v] = 0; var p, u, m = 0; if (d === "be") for (v = a.length - 1, p = 0; v >= 0; v -= 3)u = a[v] | a[v - 1] << 8 | a[v - 2] << 16, this.words[p] |= u << m & 67108863, this.words[p + 1] = u >>> 26 - m & 67108863, m += 24, m >= 26 && (m -= 26, p++); else if (d === "le") for (v = 0, p = 0; v < a.length; v += 3)u = a[v] | a[v + 1] << 8 | a[v + 2] << 16, this.words[p] |= u << m & 67108863, this.words[p + 1] = u >>> 26 - m & 67108863, m += 24, m >= 26 && (m -= 26, p++); return this._strip() }; function h(l, a) { var s = l.charCodeAt(a); if (s >= 48 && s <= 57) return s - 48; if (s >= 65 && s <= 70) return s - 55; if (s >= 97 && s <= 102) return s - 87; r(!1, "Invalid character in " + l) } function c(l, a, s) { var d = h(l, s); return s - 1 >= a && (d |= h(l, s - 1) << 4), d } n.prototype._parseHex = function (a, s, d) { this.length = Math.ceil((a.length - s) / 6), this.words = new Array(this.length); for (var v = 0; v < this.length; v++)this.words[v] = 0; var p = 0, u = 0, m; if (d === "be") for (v = a.length - 1; v >= s; v -= 2)m = c(a, s, v) << p, this.words[u] |= m & 67108863, p >= 18 ? (p -= 18, u += 1, this.words[u] |= m >>> 26) : p += 8; else { var g = a.length - s; for (v = g % 2 == 0 ? s + 1 : s; v < a.length; v += 2)m = c(a, s, v) << p, this.words[u] |= m & 67108863, p >= 18 ? (p -= 18, u += 1, this.words[u] |= m >>> 26) : p += 8 } this._strip() }; function y(l, a, s, d) { for (var v = 0, p = 0, u = Math.min(l.length, s), m = a; m < u; m++) { var g = l.charCodeAt(m) - 48; v *= d, g >= 49 ? p = g - 49 + 10 : g >= 17 ? p = g - 17 + 10 : p = g, r(g >= 0 && p < d, "Invalid character"), v += p } return v } n.prototype._parseBase = function (a, s, d) { this.words = [0], this.length = 1; for (var v = 0, p = 1; p <= 67108863; p *= s)v++; v--, p = p / s | 0; for (var u = a.length - d, m = u % v, g = Math.min(u, u - m) + d, o = 0, w = d; w < g; w += v)o = y(a, w, w + v, s), this.imuln(p), this.words[0] + o < 67108864 ? this.words[0] += o : this._iaddn(o); if (m !== 0) { var R = 1; for (o = y(a, w, a.length, s), w = 0; w < m; w++)R *= s; this.imuln(R), this.words[0] + o < 67108864 ? this.words[0] += o : this._iaddn(o) } this._strip() }, n.prototype.copy = function (a) { a.words = new Array(this.length); for (var s = 0; s < this.length; s++)a.words[s] = this.words[s]; a.length = this.length, a.negative = this.negative, a.red = this.red }; function x(l, a) { l.words = a.words, l.length = a.length, l.negative = a.negative, l.red = a.red } if (n.prototype._move = function (a) { x(a, this) }, n.prototype.clone = function () { var a = new n(null); return this.copy(a), a }, n.prototype._expand = function (a) { for (; this.length < a;)this.words[this.length++] = 0; return this }, n.prototype._strip = function () { for (; this.length > 1 && this.words[this.length - 1] === 0;)this.length--; return this._normSign() }, n.prototype._normSign = function () { return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this }, typeof Symbol != "undefined" && typeof Symbol.for == "function") try { n.prototype[Symbol.for("nodejs.util.inspect.custom")] = M } catch (l) { n.prototype.inspect = M } else n.prototype.inspect = M; function M() { return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">" } var E = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], A = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], B = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176]; n.prototype.toString = function (a, s) { a = a || 10, s = s | 0 || 1; var d; if (a === 16 || a === "hex") { d = ""; for (var v = 0, p = 0, u = 0; u < this.length; u++) { var m = this.words[u], g = ((m << v | p) & 16777215).toString(16); p = m >>> 24 - v & 16777215, p !== 0 || u !== this.length - 1 ? d = E[6 - g.length] + g + d : d = g + d, v += 2, v >= 26 && (v -= 26, u--) } for (p !== 0 && (d = p.toString(16) + d); d.length % s != 0;)d = "0" + d; return this.negative !== 0 && (d = "-" + d), d } if (a === (a | 0) && a >= 2 && a <= 36) { var o = A[a], w = B[a]; d = ""; var R = this.clone(); for (R.negative = 0; !R.isZero();) { var k = R.modrn(w).toString(a); R = R.idivn(w), R.isZero() ? d = k + d : d = E[o - k.length] + k + d } for (this.isZero() && (d = "0" + d); d.length % s != 0;)d = "0" + d; return this.negative !== 0 && (d = "-" + d), d } r(!1, "Base should be between 2 and 36") }, n.prototype.toNumber = function () { var a = this.words[0]; return this.length === 2 ? a += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? a += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && r(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -a : a }, n.prototype.toJSON = function () { return this.toString(16, 2) }, f && (n.prototype.toBuffer = function (a, s) { return this.toArrayLike(f, a, s) }), n.prototype.toArray = function (a, s) { return this.toArrayLike(Array, a, s) }; var T = function (a, s) { return a.allocUnsafe ? a.allocUnsafe(s) : new a(s) }; n.prototype.toArrayLike = function (a, s, d) { this._strip(); var v = this.byteLength(), p = d || Math.max(1, v); r(v <= p, "byte array longer than desired length"), r(p > 0, "Requested array length <= 0"); var u = T(a, p), m = s === "le" ? "LE" : "BE"; return this["_toArrayLike" + m](u, v), u }, n.prototype._toArrayLikeLE = function (a, s) { for (var d = 0, v = 0, p = 0, u = 0; p < this.length; p++) { var m = this.words[p] << u | v; a[d++] = m & 255, d < a.length && (a[d++] = m >> 8 & 255), d < a.length && (a[d++] = m >> 16 & 255), u === 6 ? (d < a.length && (a[d++] = m >> 24 & 255), v = 0, u = 0) : (v = m >>> 24, u += 2) } if (d < a.length) for (a[d++] = v; d < a.length;)a[d++] = 0 }, n.prototype._toArrayLikeBE = function (a, s) { for (var d = a.length - 1, v = 0, p = 0, u = 0; p < this.length; p++) { var m = this.words[p] << u | v; a[d--] = m & 255, d >= 0 && (a[d--] = m >> 8 & 255), d >= 0 && (a[d--] = m >> 16 & 255), u === 6 ? (d >= 0 && (a[d--] = m >> 24 & 255), v = 0, u = 0) : (v = m >>> 24, u += 2) } if (d >= 0) for (a[d--] = v; d >= 0;)a[d--] = 0 }, Math.clz32 ? n.prototype._countBits = function (a) { return 32 - Math.clz32(a) } : n.prototype._countBits = function (a) { var s = a, d = 0; return s >= 4096 && (d += 13, s >>>= 13), s >= 64 && (d += 7, s >>>= 7), s >= 8 && (d += 4, s >>>= 4), s >= 2 && (d += 2, s >>>= 2), d + s }, n.prototype._zeroBits = function (a) { if (a === 0) return 26; var s = a, d = 0; return (s & 8191) == 0 && (d += 13, s >>>= 13), (s & 127) == 0 && (d += 7, s >>>= 7), (s & 15) == 0 && (d += 4, s >>>= 4), (s & 3) == 0 && (d += 2, s >>>= 2), (s & 1) == 0 && d++, d }, n.prototype.bitLength = function () { var a = this.words[this.length - 1], s = this._countBits(a); return (this.length - 1) * 26 + s }; function C(l) { for (var a = new Array(l.bitLength()), s = 0; s < a.length; s++) { var d = s / 26 | 0, v = s % 26; a[s] = l.words[d] >>> v & 1 } return a } n.prototype.zeroBits = function () { if (this.isZero()) return 0; for (var a = 0, s = 0; s < this.length; s++) { var d = this._zeroBits(this.words[s]); if (a += d, d !== 26) break } return a }, n.prototype.byteLength = function () { return Math.ceil(this.bitLength() / 8) }, n.prototype.toTwos = function (a) { return this.negative !== 0 ? this.abs().inotn(a).iaddn(1) : this.clone() }, n.prototype.fromTwos = function (a) { return this.testn(a - 1) ? this.notn(a).iaddn(1).ineg() : this.clone() }, n.prototype.isNeg = function () { return this.negative !== 0 }, n.prototype.neg = function () { return this.clone().ineg() }, n.prototype.ineg = function () { return this.isZero() || (this.negative ^= 1), this }, n.prototype.iuor = function (a) { for (; this.length < a.length;)this.words[this.length++] = 0; for (var s = 0; s < a.length; s++)this.words[s] = this.words[s] | a.words[s]; return this._strip() }, n.prototype.ior = function (a) { return r((this.negative | a.negative) == 0), this.iuor(a) }, n.prototype.or = function (a) { return this.length > a.length ? this.clone().ior(a) : a.clone().ior(this) }, n.prototype.uor = function (a) { return this.length > a.length ? this.clone().iuor(a) : a.clone().iuor(this) }, n.prototype.iuand = function (a) { var s; this.length > a.length ? s = a : s = this; for (var d = 0; d < s.length; d++)this.words[d] = this.words[d] & a.words[d]; return this.length = s.length, this._strip() }, n.prototype.iand = function (a) { return r((this.negative | a.negative) == 0), this.iuand(a) }, n.prototype.and = function (a) { return this.length > a.length ? this.clone().iand(a) : a.clone().iand(this) }, n.prototype.uand = function (a) { return this.length > a.length ? this.clone().iuand(a) : a.clone().iuand(this) }, n.prototype.iuxor = function (a) { var s, d; this.length > a.length ? (s = this, d = a) : (s = a, d = this); for (var v = 0; v < d.length; v++)this.words[v] = s.words[v] ^ d.words[v]; if (this !== s) for (; v < s.length; v++)this.words[v] = s.words[v]; return this.length = s.length, this._strip() }, n.prototype.ixor = function (a) { return r((this.negative | a.negative) == 0), this.iuxor(a) }, n.prototype.xor = function (a) { return this.length > a.length ? this.clone().ixor(a) : a.clone().ixor(this) }, n.prototype.uxor = function (a) { return this.length > a.length ? this.clone().iuxor(a) : a.clone().iuxor(this) }, n.prototype.inotn = function (a) { r(typeof a == "number" && a >= 0); var s = Math.ceil(a / 26) | 0, d = a % 26; this._expand(s), d > 0 && s--; for (var v = 0; v < s; v++)this.words[v] = ~this.words[v] & 67108863; return d > 0 && (this.words[v] = ~this.words[v] & 67108863 >> 26 - d), this._strip() }, n.prototype.notn = function (a) { return this.clone().inotn(a) }, n.prototype.setn = function (a, s) { r(typeof a == "number" && a >= 0); var d = a / 26 | 0, v = a % 26; return this._expand(d + 1), s ? this.words[d] = this.words[d] | 1 << v : this.words[d] = this.words[d] & ~(1 << v), this._strip() }, n.prototype.iadd = function (a) { var s; if (this.negative !== 0 && a.negative === 0) return this.negative = 0, s = this.isub(a), this.negative ^= 1, this._normSign(); if (this.negative === 0 && a.negative !== 0) return a.negative = 0, s = this.isub(a), a.negative = 1, s._normSign(); var d, v; this.length > a.length ? (d = this, v = a) : (d = a, v = this); for (var p = 0, u = 0; u < v.length; u++)s = (d.words[u] | 0) + (v.words[u] | 0) + p, this.words[u] = s & 67108863, p = s >>> 26; for (; p !== 0 && u < d.length; u++)s = (d.words[u] | 0) + p, this.words[u] = s & 67108863, p = s >>> 26; if (this.length = d.length, p !== 0) this.words[this.length] = p, this.length++; else if (d !== this) for (; u < d.length; u++)this.words[u] = d.words[u]; return this }, n.prototype.add = function (a) { var s; return a.negative !== 0 && this.negative === 0 ? (a.negative = 0, s = this.sub(a), a.negative ^= 1, s) : a.negative === 0 && this.negative !== 0 ? (this.negative = 0, s = a.sub(this), this.negative = 1, s) : this.length > a.length ? this.clone().iadd(a) : a.clone().iadd(this) }, n.prototype.isub = function (a) { if (a.negative !== 0) { a.negative = 0; var s = this.iadd(a); return a.negative = 1, s._normSign() } else if (this.negative !== 0) return this.negative = 0, this.iadd(a), this.negative = 1, this._normSign(); var d = this.cmp(a); if (d === 0) return this.negative = 0, this.length = 1, this.words[0] = 0, this; var v, p; d > 0 ? (v = this, p = a) : (v = a, p = this); for (var u = 0, m = 0; m < p.length; m++)s = (v.words[m] | 0) - (p.words[m] | 0) + u, u = s >> 26, this.words[m] = s & 67108863; for (; u !== 0 && m < v.length; m++)s = (v.words[m] | 0) + u, u = s >> 26, this.words[m] = s & 67108863; if (u === 0 && m < v.length && v !== this) for (; m < v.length; m++)this.words[m] = v.words[m]; return this.length = Math.max(this.length, m), v !== this && (this.negative = 1), this._strip() }, n.prototype.sub = function (a) { return this.clone().isub(a) }; function H(l, a, s) { s.negative = a.negative ^ l.negative; var d = l.length + a.length | 0; s.length = d, d = d - 1 | 0; var v = l.words[0] | 0, p = a.words[0] | 0, u = v * p, m = u & 67108863, g = u / 67108864 | 0; s.words[0] = m; for (var o = 1; o < d; o++) { for (var w = g >>> 26, R = g & 67108863, k = Math.min(o, a.length - 1), q = Math.max(0, o - l.length + 1); q <= k; q++) { var O = o - q | 0; v = l.words[O] | 0, p = a.words[q] | 0, u = v * p + R, w += u / 67108864 | 0, R = u & 67108863 } s.words[o] = R | 0, g = w | 0 } return g !== 0 ? s.words[o] = g | 0 : s.length--, s._strip() } var F = function (a, s, d) { var v = a.words, p = s.words, u = d.words, m = 0, g, o, w, R = v[0] | 0, k = R & 8191, q = R >>> 13, O = v[1] | 0, D = O & 8191, U = O >>> 13, Qe = v[2] | 0, N = Qe & 8191, L = Qe >>> 13, vi = v[3] | 0, j = vi & 8191, z = vi >>> 13, bi = v[4] | 0, W = bi & 8191, K = bi >>> 13, yi = v[5] | 0, V = yi & 8191, G = yi >>> 13, mi = v[6] | 0, $ = mi & 8191, X = mi >>> 13, gi = v[7] | 0, Y = gi & 8191, Z = gi >>> 13, wi = v[8] | 0, J = wi & 8191, Q = wi >>> 13, _i = v[9] | 0, ee = _i & 8191, te = _i >>> 13, xi = p[0] | 0, re = xi & 8191, ie = xi >>> 13, Mi = p[1] | 0, ne = Mi & 8191, ae = Mi >>> 13, Si = p[2] | 0, fe = Si & 8191, se = Si >>> 13, Ei = p[3] | 0, oe = Ei & 8191, he = Ei >>> 13, Ai = p[4] | 0, ue = Ai & 8191, ce = Ai >>> 13, Bi = p[5] | 0, de = Bi & 8191, le = Bi >>> 13, Ii = p[6] | 0, pe = Ii & 8191, ve = Ii >>> 13, Ri = p[7] | 0, be = Ri & 8191, ye = Ri >>> 13, Ti = p[8] | 0, me = Ti & 8191, ge = Ti >>> 13, Vr = p[9] | 0, Se = Vr & 8191, Ee = Vr >>> 13; d.negative = a.negative ^ s.negative, d.length = 19, g = Math.imul(k, re), o = Math.imul(k, ie), o = o + Math.imul(q, re) | 0, w = Math.imul(q, ie); var Qt = (m + g | 0) + ((o & 8191) << 13) | 0; m = (w + (o >>> 13) | 0) + (Qt >>> 26) | 0, Qt &= 67108863, g = Math.imul(D, re), o = Math.imul(D, ie), o = o + Math.imul(U, re) | 0, w = Math.imul(U, ie), g = g + Math.imul(k, ne) | 0, o = o + Math.imul(k, ae) | 0, o = o + Math.imul(q, ne) | 0, w = w + Math.imul(q, ae) | 0; var er = (m + g | 0) + ((o & 8191) << 13) | 0; m = (w + (o >>> 13) | 0) + (er >>> 26) | 0, er &= 67108863, g = Math.imul(N, re), o = Math.imul(N, ie), o = o + Math.imul(L, re) | 0, w = Math.imul(L, ie), g = g + Math.imul(D, ne) | 0, o = o + Math.imul(D, ae) | 0, o = o + Math.imul(U, ne) | 0, w = w + Math.imul(U, ae) | 0, g = g + Math.imul(k, fe) | 0, o = o + Math.imul(k, se) | 0, o = o + Math.imul(q, fe) | 0, w = w + Math.imul(q, se) | 0; var tr = (m + g | 0) + ((o & 8191) << 13) | 0; m = (w + (o >>> 13) | 0) + (tr >>> 26) | 0, tr &= 67108863, g = Math.imul(j, re), o = Math.imul(j, ie), o = o + Math.imul(z, re) | 0, w = Math.imul(z, ie), g = g + Math.imul(N, ne) | 0, o = o + Math.imul(N, ae) | 0, o = o + Math.imul(L, ne) | 0, w = w + Math.imul(L, ae) | 0, g = g + Math.imul(D, fe) | 0, o = o + Math.imul(D, se) | 0, o = o + Math.imul(U, fe) | 0, w = w + Math.imul(U, se) | 0, g = g + Math.imul(k, oe) | 0, o = o + Math.imul(k, he) | 0, o = o + Math.imul(q, oe) | 0, w = w + Math.imul(q, he) | 0; var rr = (m + g | 0) + ((o & 8191) << 13) | 0; m = (w + (o >>> 13) | 0) + (rr >>> 26) | 0, rr &= 67108863, g = Math.imul(W, re), o = Math.imul(W, ie), o = o + Math.imul(K, re) | 0, w = Math.imul(K, ie), g = g + Math.imul(j, ne) | 0, o = o + Math.imul(j, ae) | 0, o = o + Math.imul(z, ne) | 0, w = w + Math.imul(z, ae) | 0, g = g + Math.imul(N, fe) | 0, o = o + Math.imul(N, se) | 0, o = o + Math.imul(L, fe) | 0, w = w + Math.imul(L, se) | 0, g = g + Math.imul(D, oe) | 0, o = o + Math.imul(D, he) | 0, o = o + Math.imul(U, oe) | 0, w = w + Math.imul(U, he) | 0, g = g + Math.imul(k, ue) | 0, o = o + Math.imul(k, ce) | 0, o = o + Math.imul(q, ue) | 0, w = w + Math.imul(q, ce) | 0; var ir = (m + g | 0) + ((o & 8191) << 13) | 0; m = (w + (o >>> 13) | 0) + (ir >>> 26) | 0, ir &= 67108863, g = Math.imul(V, re), o = Math.imul(V, ie), o = o + Math.imul(G, re) | 0, w = Math.imul(G, ie), g = g + Math.imul(W, ne) | 0, o = o + Math.imul(W, ae) | 0, o = o + Math.imul(K, ne) | 0, w = w + Math.imul(K, ae) | 0, g = g + Math.imul(j, fe) | 0, o = o + Math.imul(j, se) | 0, o = o + Math.imul(z, fe) | 0, w = w + Math.imul(z, se) | 0, g = g + Math.imul(N, oe) | 0, o = o + Math.imul(N, he) | 0, o = o + Math.imul(L, oe) | 0, w = w + Math.imul(L, he) | 0, g = g + Math.imul(D, ue) | 0, o = o + Math.imul(D, ce) | 0, o = o + Math.imul(U, ue) | 0, w = w + Math.imul(U, ce) | 0, g = g + Math.imul(k, de) | 0, o = o + Math.imul(k, le) | 0, o = o + Math.imul(q, de) | 0, w = w + Math.imul(q, le) | 0; var nr = (m + g | 0) + ((o & 8191) << 13) | 0; m = (w + (o >>> 13) | 0) + (nr >>> 26) | 0, nr &= 67108863, g = Math.imul($, re), o = Math.imul($, ie), o = o + Math.imul(X, re) | 0, w = Math.imul(X, ie), g = g + Math.imul(V, ne) | 0, o = o + Math.imul(V, ae) | 0, o = o + Math.imul(G, ne) | 0, w = w + Math.imul(G, ae) | 0, g = g + Math.imul(W, fe) | 0, o = o + Math.imul(W, se) | 0, o = o + Math.imul(K, fe) | 0, w = w + Math.imul(K, se) | 0, g = g + Math.imul(j, oe) | 0, o = o + Math.imul(j, he) | 0, o = o + Math.imul(z, oe) | 0, w = w + Math.imul(z, he) | 0, g = g + Math.imul(N, ue) | 0, o = o + Math.imul(N, ce) | 0, o = o + Math.imul(L, ue) | 0, w = w + Math.imul(L, ce) | 0, g = g + Math.imul(D, de) | 0, o = o + Math.imul(D, le) | 0, o = o + Math.imul(U, de) | 0, w = w + Math.imul(U, le) | 0, g = g + Math.imul(k, pe) | 0, o = o + Math.imul(k, ve) | 0, o = o + Math.imul(q, pe) | 0, w = w + Math.imul(q, ve) | 0; var ar = (m + g | 0) + ((o & 8191) << 13) | 0; m = (w + (o >>> 13) | 0) + (ar >>> 26) | 0, ar &= 67108863, g = Math.imul(Y, re), o = Math.imul(Y, ie), o = o + Math.imul(Z, re) | 0, w = Math.imul(Z, ie), g = g + Math.imul($, ne) | 0, o = o + Math.imul($, ae) | 0, o = o + Math.imul(X, ne) | 0, w = w + Math.imul(X, ae) | 0, g = g + Math.imul(V, fe) | 0, o = o + Math.imul(V, se) | 0, o = o + Math.imul(G, fe) | 0, w = w + Math.imul(G, se) | 0, g = g + Math.imul(W, oe) | 0, o = o + Math.imul(W, he) | 0, o = o + Math.imul(K, oe) | 0, w = w + Math.imul(K, he) | 0, g = g + Math.imul(j, ue) | 0, o = o + Math.imul(j, ce) | 0, o = o + Math.imul(z, ue) | 0, w = w + Math.imul(z, ce) | 0, g = g + Math.imul(N, de) | 0, o = o + Math.imul(N, le) | 0, o = o + Math.imul(L, de) | 0, w = w + Math.imul(L, le) | 0, g = g + Math.imul(D, pe) | 0, o = o + Math.imul(D, ve) | 0, o = o + Math.imul(U, pe) | 0, w = w + Math.imul(U, ve) | 0, g = g + Math.imul(k, be) | 0, o = o + Math.imul(k, ye) | 0, o = o + Math.imul(q, be) | 0, w = w + Math.imul(q, ye) | 0; var fr = (m + g | 0) + ((o & 8191) << 13) | 0; m = (w + (o >>> 13) | 0) + (fr >>> 26) | 0, fr &= 67108863, g = Math.imul(J, re), o = Math.imul(J, ie), o = o + Math.imul(Q, re) | 0, w = Math.imul(Q, ie), g = g + Math.imul(Y, ne) | 0, o = o + Math.imul(Y, ae) | 0, o = o + Math.imul(Z, ne) | 0, w = w + Math.imul(Z, ae) | 0, g = g + Math.imul($, fe) | 0, o = o + Math.imul($, se) | 0, o = o + Math.imul(X, fe) | 0, w = w + Math.imul(X, se) | 0, g = g + Math.imul(V, oe) | 0, o = o + Math.imul(V, he) | 0, o = o + Math.imul(G, oe) | 0, w = w + Math.imul(G, he) | 0, g = g + Math.imul(W, ue) | 0, o = o + Math.imul(W, ce) | 0, o = o + Math.imul(K, ue) | 0, w = w + Math.imul(K, ce) | 0, g = g + Math.imul(j, de) | 0, o = o + Math.imul(j, le) | 0, o = o + Math.imul(z, de) | 0, w = w + Math.imul(z, le) | 0, g = g + Math.imul(N, pe) | 0, o = o + Math.imul(N, ve) | 0, o = o + Math.imul(L, pe) | 0, w = w + Math.imul(L, ve) | 0, g = g + Math.imul(D, be) | 0, o = o + Math.imul(D, ye) | 0, o = o + Math.imul(U, be) | 0, w = w + Math.imul(U, ye) | 0, g = g + Math.imul(k, me) | 0, o = o + Math.imul(k, ge) | 0, o = o + Math.imul(q, me) | 0, w = w + Math.imul(q, ge) | 0; var sr = (m + g | 0) + ((o & 8191) << 13) | 0; m = (w + (o >>> 13) | 0) + (sr >>> 26) | 0, sr &= 67108863, g = Math.imul(ee, re), o = Math.imul(ee, ie), o = o + Math.imul(te, re) | 0, w = Math.imul(te, ie), g = g + Math.imul(J, ne) | 0, o = o + Math.imul(J, ae) | 0, o = o + Math.imul(Q, ne) | 0, w = w + Math.imul(Q, ae) | 0, g = g + Math.imul(Y, fe) | 0, o = o + Math.imul(Y, se) | 0, o = o + Math.imul(Z, fe) | 0, w = w + Math.imul(Z, se) | 0, g = g + Math.imul($, oe) | 0, o = o + Math.imul($, he) | 0, o = o + Math.imul(X, oe) | 0, w = w + Math.imul(X, he) | 0, g = g + Math.imul(V, ue) | 0, o = o + Math.imul(V, ce) | 0, o = o + Math.imul(G, ue) | 0, w = w + Math.imul(G, ce) | 0, g = g + Math.imul(W, de) | 0, o = o + Math.imul(W, le) | 0, o = o + Math.imul(K, de) | 0, w = w + Math.imul(K, le) | 0, g = g + Math.imul(j, pe) | 0, o = o + Math.imul(j, ve) | 0, o = o + Math.imul(z, pe) | 0, w = w + Math.imul(z, ve) | 0, g = g + Math.imul(N, be) | 0, o = o + Math.imul(N, ye) | 0, o = o + Math.imul(L, be) | 0, w = w + Math.imul(L, ye) | 0, g = g + Math.imul(D, me) | 0, o = o + Math.imul(D, ge) | 0, o = o + Math.imul(U, me) | 0, w = w + Math.imul(U, ge) | 0, g = g + Math.imul(k, Se) | 0, o = o + Math.imul(k, Ee) | 0, o = o + Math.imul(q, Se) | 0, w = w + Math.imul(q, Ee) | 0; var or = (m + g | 0) + ((o & 8191) << 13) | 0; m = (w + (o >>> 13) | 0) + (or >>> 26) | 0, or &= 67108863, g = Math.imul(ee, ne), o = Math.imul(ee, ae), o = o + Math.imul(te, ne) | 0, w = Math.imul(te, ae), g = g + Math.imul(J, fe) | 0, o = o + Math.imul(J, se) | 0, o = o + Math.imul(Q, fe) | 0, w = w + Math.imul(Q, se) | 0, g = g + Math.imul(Y, oe) | 0, o = o + Math.imul(Y, he) | 0, o = o + Math.imul(Z, oe) | 0, w = w + Math.imul(Z, he) | 0, g = g + Math.imul($, ue) | 0, o = o + Math.imul($, ce) | 0, o = o + Math.imul(X, ue) | 0, w = w + Math.imul(X, ce) | 0, g = g + Math.imul(V, de) | 0, o = o + Math.imul(V, le) | 0, o = o + Math.imul(G, de) | 0, w = w + Math.imul(G, le) | 0, g = g + Math.imul(W, pe) | 0, o = o + Math.imul(W, ve) | 0, o = o + Math.imul(K, pe) | 0, w = w + Math.imul(K, ve) | 0, g = g + Math.imul(j, be) | 0, o = o + Math.imul(j, ye) | 0, o = o + Math.imul(z, be) | 0, w = w + Math.imul(z, ye) | 0, g = g + Math.imul(N, me) | 0, o = o + Math.imul(N, ge) | 0, o = o + Math.imul(L, me) | 0, w = w + Math.imul(L, ge) | 0, g = g + Math.imul(D, Se) | 0, o = o + Math.imul(D, Ee) | 0, o = o + Math.imul(U, Se) | 0, w = w + Math.imul(U, Ee) | 0; var hr = (m + g | 0) + ((o & 8191) << 13) | 0; m = (w + (o >>> 13) | 0) + (hr >>> 26) | 0, hr &= 67108863, g = Math.imul(ee, fe), o = Math.imul(ee, se), o = o + Math.imul(te, fe) | 0, w = Math.imul(te, se), g = g + Math.imul(J, oe) | 0, o = o + Math.imul(J, he) | 0, o = o + Math.imul(Q, oe) | 0, w = w + Math.imul(Q, he) | 0, g = g + Math.imul(Y, ue) | 0, o = o + Math.imul(Y, ce) | 0, o = o + Math.imul(Z, ue) | 0, w = w + Math.imul(Z, ce) | 0, g = g + Math.imul($, de) | 0, o = o + Math.imul($, le) | 0, o = o + Math.imul(X, de) | 0, w = w + Math.imul(X, le) | 0, g = g + Math.imul(V, pe) | 0, o = o + Math.imul(V, ve) | 0, o = o + Math.imul(G, pe) | 0, w = w + Math.imul(G, ve) | 0, g = g + Math.imul(W, be) | 0, o = o + Math.imul(W, ye) | 0, o = o + Math.imul(K, be) | 0, w = w + Math.imul(K, ye) | 0, g = g + Math.imul(j, me) | 0, o = o + Math.imul(j, ge) | 0, o = o + Math.imul(z, me) | 0, w = w + Math.imul(z, ge) | 0, g = g + Math.imul(N, Se) | 0, o = o + Math.imul(N, Ee) | 0, o = o + Math.imul(L, Se) | 0, w = w + Math.imul(L, Ee) | 0; var ur = (m + g | 0) + ((o & 8191) << 13) | 0; m = (w + (o >>> 13) | 0) + (ur >>> 26) | 0, ur &= 67108863, g = Math.imul(ee, oe), o = Math.imul(ee, he), o = o + Math.imul(te, oe) | 0, w = Math.imul(te, he), g = g + Math.imul(J, ue) | 0, o = o + Math.imul(J, ce) | 0, o = o + Math.imul(Q, ue) | 0, w = w + Math.imul(Q, ce) | 0, g = g + Math.imul(Y, de) | 0, o = o + Math.imul(Y, le) | 0, o = o + Math.imul(Z, de) | 0, w = w + Math.imul(Z, le) | 0, g = g + Math.imul($, pe) | 0, o = o + Math.imul($, ve) | 0, o = o + Math.imul(X, pe) | 0, w = w + Math.imul(X, ve) | 0, g = g + Math.imul(V, be) | 0, o = o + Math.imul(V, ye) | 0, o = o + Math.imul(G, be) | 0, w = w + Math.imul(G, ye) | 0, g = g + Math.imul(W, me) | 0, o = o + Math.imul(W, ge) | 0, o = o + Math.imul(K, me) | 0, w = w + Math.imul(K, ge) | 0, g = g + Math.imul(j, Se) | 0, o = o + Math.imul(j, Ee) | 0, o = o + Math.imul(z, Se) | 0, w = w + Math.imul(z, Ee) | 0; var cr = (m + g | 0) + ((o & 8191) << 13) | 0; m = (w + (o >>> 13) | 0) + (cr >>> 26) | 0, cr &= 67108863, g = Math.imul(ee, ue), o = Math.imul(ee, ce), o = o + Math.imul(te, ue) | 0, w = Math.imul(te, ce), g = g + Math.imul(J, de) | 0, o = o + Math.imul(J, le) | 0, o = o + Math.imul(Q, de) | 0, w = w + Math.imul(Q, le) | 0, g = g + Math.imul(Y, pe) | 0, o = o + Math.imul(Y, ve) | 0, o = o + Math.imul(Z, pe) | 0, w = w + Math.imul(Z, ve) | 0, g = g + Math.imul($, be) | 0, o = o + Math.imul($, ye) | 0, o = o + Math.imul(X, be) | 0, w = w + Math.imul(X, ye) | 0, g = g + Math.imul(V, me) | 0, o = o + Math.imul(V, ge) | 0, o = o + Math.imul(G, me) | 0, w = w + Math.imul(G, ge) | 0, g = g + Math.imul(W, Se) | 0, o = o + Math.imul(W, Ee) | 0, o = o + Math.imul(K, Se) | 0, w = w + Math.imul(K, Ee) | 0; var dr = (m + g | 0) + ((o & 8191) << 13) | 0; m = (w + (o >>> 13) | 0) + (dr >>> 26) | 0, dr &= 67108863, g = Math.imul(ee, de), o = Math.imul(ee, le), o = o + Math.imul(te, de) | 0, w = Math.imul(te, le), g = g + Math.imul(J, pe) | 0, o = o + Math.imul(J, ve) | 0, o = o + Math.imul(Q, pe) | 0, w = w + Math.imul(Q, ve) | 0, g = g + Math.imul(Y, be) | 0, o = o + Math.imul(Y, ye) | 0, o = o + Math.imul(Z, be) | 0, w = w + Math.imul(Z, ye) | 0, g = g + Math.imul($, me) | 0, o = o + Math.imul($, ge) | 0, o = o + Math.imul(X, me) | 0, w = w + Math.imul(X, ge) | 0, g = g + Math.imul(V, Se) | 0, o = o + Math.imul(V, Ee) | 0, o = o + Math.imul(G, Se) | 0, w = w + Math.imul(G, Ee) | 0; var lr = (m + g | 0) + ((o & 8191) << 13) | 0; m = (w + (o >>> 13) | 0) + (lr >>> 26) | 0, lr &= 67108863, g = Math.imul(ee, pe), o = Math.imul(ee, ve), o = o + Math.imul(te, pe) | 0, w = Math.imul(te, ve), g = g + Math.imul(J, be) | 0, o = o + Math.imul(J, ye) | 0, o = o + Math.imul(Q, be) | 0, w = w + Math.imul(Q, ye) | 0, g = g + Math.imul(Y, me) | 0, o = o + Math.imul(Y, ge) | 0, o = o + Math.imul(Z, me) | 0, w = w + Math.imul(Z, ge) | 0, g = g + Math.imul($, Se) | 0, o = o + Math.imul($, Ee) | 0, o = o + Math.imul(X, Se) | 0, w = w + Math.imul(X, Ee) | 0; var pr = (m + g | 0) + ((o & 8191) << 13) | 0; m = (w + (o >>> 13) | 0) + (pr >>> 26) | 0, pr &= 67108863, g = Math.imul(ee, be), o = Math.imul(ee, ye), o = o + Math.imul(te, be) | 0, w = Math.imul(te, ye), g = g + Math.imul(J, me) | 0, o = o + Math.imul(J, ge) | 0, o = o + Math.imul(Q, me) | 0, w = w + Math.imul(Q, ge) | 0, g = g + Math.imul(Y, Se) | 0, o = o + Math.imul(Y, Ee) | 0, o = o + Math.imul(Z, Se) | 0, w = w + Math.imul(Z, Ee) | 0; var Ji = (m + g | 0) + ((o & 8191) << 13) | 0; m = (w + (o >>> 13) | 0) + (Ji >>> 26) | 0, Ji &= 67108863, g = Math.imul(ee, me), o = Math.imul(ee, ge), o = o + Math.imul(te, me) | 0, w = Math.imul(te, ge), g = g + Math.imul(J, Se) | 0, o = o + Math.imul(J, Ee) | 0, o = o + Math.imul(Q, Se) | 0, w = w + Math.imul(Q, Ee) | 0; var Qi = (m + g | 0) + ((o & 8191) << 13) | 0; m = (w + (o >>> 13) | 0) + (Qi >>> 26) | 0, Qi &= 67108863, g = Math.imul(ee, Se), o = Math.imul(ee, Ee), o = o + Math.imul(te, Se) | 0, w = Math.imul(te, Ee); var en = (m + g | 0) + ((o & 8191) << 13) | 0; return m = (w + (o >>> 13) | 0) + (en >>> 26) | 0, en &= 67108863, u[0] = Qt, u[1] = er, u[2] = tr, u[3] = rr, u[4] = ir, u[5] = nr, u[6] = ar, u[7] = fr, u[8] = sr, u[9] = or, u[10] = hr, u[11] = ur, u[12] = cr, u[13] = dr, u[14] = lr, u[15] = pr, u[16] = Ji, u[17] = Qi, u[18] = en, m !== 0 && (u[19] = m, d.length++), d }; Math.imul || (F = H); function we(l, a, s) { s.negative = a.negative ^ l.negative, s.length = l.length + a.length; for (var d = 0, v = 0, p = 0; p < s.length - 1; p++) { var u = v; v = 0; for (var m = d & 67108863, g = Math.min(p, a.length - 1), o = Math.max(0, p - l.length + 1); o <= g; o++) { var w = p - o, R = l.words[w] | 0, k = a.words[o] | 0, q = R * k, O = q & 67108863; u = u + (q / 67108864 | 0) | 0, O = O + m | 0, m = O & 67108863, u = u + (O >>> 26) | 0, v += u >>> 26, u &= 67108863 } s.words[p] = m, d = u, u = v } return d !== 0 ? s.words[p] = d : s.length--, s._strip() } function Be(l, a, s) { return we(l, a, s) } n.prototype.mulTo = function (a, s) { var d, v = this.length + a.length; return this.length === 10 && a.length === 10 ? d = F(this, a, s) : v < 63 ? d = H(this, a, s) : v < 1024 ? d = we(this, a, s) : d = Be(this, a, s), d }; function xe(l, a) { this.x = l, this.y = a } xe.prototype.makeRBT = function (a) { for (var s = new Array(a), d = n.prototype._countBits(a) - 1, v = 0; v < a; v++)s[v] = this.revBin(v, d, a); return s }, xe.prototype.revBin = function (a, s, d) { if (a === 0 || a === d - 1) return a; for (var v = 0, p = 0; p < s; p++)v |= (a & 1) << s - p - 1, a >>= 1; return v }, xe.prototype.permute = function (a, s, d, v, p, u) { for (var m = 0; m < u; m++)v[m] = s[a[m]], p[m] = d[a[m]] }, xe.prototype.transform = function (a, s, d, v, p, u) { this.permute(u, a, s, d, v, p); for (var m = 1; m < p; m <<= 1)for (var g = m << 1, o = Math.cos(2 * Math.PI / g), w = Math.sin(2 * Math.PI / g), R = 0; R < p; R += g)for (var k = o, q = w, O = 0; O < m; O++) { var D = d[R + O], U = v[R + O], Qe = d[R + O + m], N = v[R + O + m], L = k * Qe - q * N; N = k * N + q * Qe, Qe = L, d[R + O] = D + Qe, v[R + O] = U + N, d[R + O + m] = D - Qe, v[R + O + m] = U - N, O !== g && (L = o * k - w * q, q = o * q + w * k, k = L) } }, xe.prototype.guessLen13b = function (a, s) { var d = Math.max(s, a) | 1, v = d & 1, p = 0; for (d = d / 2 | 0; d; d = d >>> 1)p++; return 1 << p + 1 + v }, xe.prototype.conjugate = function (a, s, d) { if (!(d <= 1)) for (var v = 0; v < d / 2; v++) { var p = a[v]; a[v] = a[d - v - 1], a[d - v - 1] = p, p = s[v], s[v] = -s[d - v - 1], s[d - v - 1] = -p } }, xe.prototype.normalize13b = function (a, s) { for (var d = 0, v = 0; v < s / 2; v++) { var p = Math.round(a[2 * v + 1] / s) * 8192 + Math.round(a[2 * v] / s) + d; a[v] = p & 67108863, p < 67108864 ? d = 0 : d = p / 67108864 | 0 } return a }, xe.prototype.convert13b = function (a, s, d, v) { for (var p = 0, u = 0; u < s; u++)p = p + (a[u] | 0), d[2 * u] = p & 8191, p = p >>> 13, d[2 * u + 1] = p & 8191, p = p >>> 13; for (u = 2 * s; u < v; ++u)d[u] = 0; r(p === 0), r((p & ~8191) == 0) }, xe.prototype.stub = function (a) { for (var s = new Array(a), d = 0; d < a; d++)s[d] = 0; return s }, xe.prototype.mulp = function (a, s, d) { var v = 2 * this.guessLen13b(a.length, s.length), p = this.makeRBT(v), u = this.stub(v), m = new Array(v), g = new Array(v), o = new Array(v), w = new Array(v), R = new Array(v), k = new Array(v), q = d.words; q.length = v, this.convert13b(a.words, a.length, m, v), this.convert13b(s.words, s.length, w, v), this.transform(m, u, g, o, v, p), this.transform(w, u, R, k, v, p); for (var O = 0; O < v; O++) { var D = g[O] * R[O] - o[O] * k[O]; o[O] = g[O] * k[O] + o[O] * R[O], g[O] = D } return this.conjugate(g, o, v), this.transform(g, o, q, u, v, p), this.conjugate(q, u, v), this.normalize13b(q, v), d.negative = a.negative ^ s.negative, d.length = a.length + s.length, d._strip() }, n.prototype.mul = function (a) { var s = new n(null); return s.words = new Array(this.length + a.length), this.mulTo(a, s) }, n.prototype.mulf = function (a) { var s = new n(null); return s.words = new Array(this.length + a.length), Be(this, a, s) }, n.prototype.imul = function (a) { return this.clone().mulTo(a, this) }, n.prototype.imuln = function (a) { var s = a < 0; s && (a = -a), r(typeof a == "number"), r(a < 67108864); for (var d = 0, v = 0; v < this.length; v++) { var p = (this.words[v] | 0) * a, u = (p & 67108863) + (d & 67108863); d >>= 26, d += p / 67108864 | 0, d += u >>> 26, this.words[v] = u & 67108863 } return d !== 0 && (this.words[v] = d, this.length++), s ? this.ineg() : this }, n.prototype.muln = function (a) { return this.clone().imuln(a) }, n.prototype.sqr = function () { return this.mul(this) }, n.prototype.isqr = function () { return this.imul(this.clone()) }, n.prototype.pow = function (a) { var s = C(a); if (s.length === 0) return new n(1); for (var d = this, v = 0; v < s.length && s[v] === 0; v++, d = d.sqr()); if (++v < s.length) for (var p = d.sqr(); v < s.length; v++, p = p.sqr())s[v] !== 0 && (d = d.mul(p)); return d }, n.prototype.iushln = function (a) { r(typeof a == "number" && a >= 0); var s = a % 26, d = (a - s) / 26, v = 67108863 >>> 26 - s << 26 - s, p; if (s !== 0) { var u = 0; for (p = 0; p < this.length; p++) { var m = this.words[p] & v, g = (this.words[p] | 0) - m << s; this.words[p] = g | u, u = m >>> 26 - s } u && (this.words[p] = u, this.length++) } if (d !== 0) { for (p = this.length - 1; p >= 0; p--)this.words[p + d] = this.words[p]; for (p = 0; p < d; p++)this.words[p] = 0; this.length += d } return this._strip() }, n.prototype.ishln = function (a) { return r(this.negative === 0), this.iushln(a) }, n.prototype.iushrn = function (a, s, d) { r(typeof a == "number" && a >= 0); var v; s ? v = (s - s % 26) / 26 : v = 0; var p = a % 26, u = Math.min((a - p) / 26, this.length), m = 67108863 ^ 67108863 >>> p << p, g = d; if (v -= u, v = Math.max(0, v), g) { for (var o = 0; o < u; o++)g.words[o] = this.words[o]; g.length = u } if (u !== 0) if (this.length > u) for (this.length -= u, o = 0; o < this.length; o++)this.words[o] = this.words[o + u]; else this.words[0] = 0, this.length = 1; var w = 0; for (o = this.length - 1; o >= 0 && (w !== 0 || o >= v); o--) { var R = this.words[o] | 0; this.words[o] = w << 26 - p | R >>> p, w = R & m } return g && w !== 0 && (g.words[g.length++] = w), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip() }, n.prototype.ishrn = function (a, s, d) { return r(this.negative === 0), this.iushrn(a, s, d) }, n.prototype.shln = function (a) { return this.clone().ishln(a) }, n.prototype.ushln = function (a) { return this.clone().iushln(a) }, n.prototype.shrn = function (a) { return this.clone().ishrn(a) }, n.prototype.ushrn = function (a) { return this.clone().iushrn(a) }, n.prototype.testn = function (a) { r(typeof a == "number" && a >= 0); var s = a % 26, d = (a - s) / 26, v = 1 << s; if (this.length <= d) return !1; var p = this.words[d]; return !!(p & v) }, n.prototype.imaskn = function (a) { r(typeof a == "number" && a >= 0); var s = a % 26, d = (a - s) / 26; if (r(this.negative === 0, "imaskn works only with positive numbers"), this.length <= d) return this; if (s !== 0 && d++, this.length = Math.min(d, this.length), s !== 0) { var v = 67108863 ^ 67108863 >>> s << s; this.words[this.length - 1] &= v } return this._strip() }, n.prototype.maskn = function (a) { return this.clone().imaskn(a) }, n.prototype.iaddn = function (a) { return r(typeof a == "number"), r(a < 67108864), a < 0 ? this.isubn(-a) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= a ? (this.words[0] = a - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(a), this.negative = 1, this) : this._iaddn(a) }, n.prototype._iaddn = function (a) { this.words[0] += a; for (var s = 0; s < this.length && this.words[s] >= 67108864; s++)this.words[s] -= 67108864, s === this.length - 1 ? this.words[s + 1] = 1 : this.words[s + 1]++; return this.length = Math.max(this.length, s + 1), this }, n.prototype.isubn = function (a) { if (r(typeof a == "number"), r(a < 67108864), a < 0) return this.iaddn(-a); if (this.negative !== 0) return this.negative = 0, this.iaddn(a), this.negative = 1, this; if (this.words[0] -= a, this.length === 1 && this.words[0] < 0) this.words[0] = -this.words[0], this.negative = 1; else for (var s = 0; s < this.length && this.words[s] < 0; s++)this.words[s] += 67108864, this.words[s + 1] -= 1; return this._strip() }, n.prototype.addn = function (a) { return this.clone().iaddn(a) }, n.prototype.subn = function (a) { return this.clone().isubn(a) }, n.prototype.iabs = function () { return this.negative = 0, this }, n.prototype.abs = function () { return this.clone().iabs() }, n.prototype._ishlnsubmul = function (a, s, d) { var v = a.length + d, p; this._expand(v); var u, m = 0; for (p = 0; p < a.length; p++) { u = (this.words[p + d] | 0) + m; var g = (a.words[p] | 0) * s; u -= g & 67108863, m = (u >> 26) - (g / 67108864 | 0), this.words[p + d] = u & 67108863 } for (; p < this.length - d; p++)u = (this.words[p + d] | 0) + m, m = u >> 26, this.words[p + d] = u & 67108863; if (m === 0) return this._strip(); for (r(m === -1), m = 0, p = 0; p < this.length; p++)u = -(this.words[p] | 0) + m, m = u >> 26, this.words[p] = u & 67108863; return this.negative = 1, this._strip() }, n.prototype._wordDiv = function (a, s) { var d = this.length - a.length, v = this.clone(), p = a, u = p.words[p.length - 1] | 0, m = this._countBits(u); d = 26 - m, d !== 0 && (p = p.ushln(d), v.iushln(d), u = p.words[p.length - 1] | 0); var g = v.length - p.length, o; if (s !== "mod") { o = new n(null), o.length = g + 1, o.words = new Array(o.length); for (var w = 0; w < o.length; w++)o.words[w] = 0 } var R = v.clone()._ishlnsubmul(p, 1, g); R.negative === 0 && (v = R, o && (o.words[g] = 1)); for (var k = g - 1; k >= 0; k--) { var q = (v.words[p.length + k] | 0) * 67108864 + (v.words[p.length + k - 1] | 0); for (q = Math.min(q / u | 0, 67108863), v._ishlnsubmul(p, q, k); v.negative !== 0;)q--, v.negative = 0, v._ishlnsubmul(p, 1, k), v.isZero() || (v.negative ^= 1); o && (o.words[k] = q) } return o && o._strip(), v._strip(), s !== "div" && d !== 0 && v.iushrn(d), { div: o || null, mod: v } }, n.prototype.divmod = function (a, s, d) { if (r(!a.isZero()), this.isZero()) return { div: new n(0), mod: new n(0) }; var v, p, u; return this.negative !== 0 && a.negative === 0 ? (u = this.neg().divmod(a, s), s !== "mod" && (v = u.div.neg()), s !== "div" && (p = u.mod.neg(), d && p.negative !== 0 && p.iadd(a)), { div: v, mod: p }) : this.negative === 0 && a.negative !== 0 ? (u = this.divmod(a.neg(), s), s !== "mod" && (v = u.div.neg()), { div: v, mod: u.mod }) : (this.negative & a.negative) != 0 ? (u = this.neg().divmod(a.neg(), s), s !== "div" && (p = u.mod.neg(), d && p.negative !== 0 && p.isub(a)), { div: u.div, mod: p }) : a.length > this.length || this.cmp(a) < 0 ? { div: new n(0), mod: this } : a.length === 1 ? s === "div" ? { div: this.divn(a.words[0]), mod: null } : s === "mod" ? { div: null, mod: new n(this.modrn(a.words[0])) } : { div: this.divn(a.words[0]), mod: new n(this.modrn(a.words[0])) } : this._wordDiv(a, s) }, n.prototype.div = function (a) { return this.divmod(a, "div", !1).div }, n.prototype.mod = function (a) { return this.divmod(a, "mod", !1).mod }, n.prototype.umod = function (a) { return this.divmod(a, "mod", !0).mod }, n.prototype.divRound = function (a) { var s = this.divmod(a); if (s.mod.isZero()) return s.div; var d = s.div.negative !== 0 ? s.mod.isub(a) : s.mod, v = a.ushrn(1), p = a.andln(1), u = d.cmp(v); return u < 0 || p === 1 && u === 0 ? s.div : s.div.negative !== 0 ? s.div.isubn(1) : s.div.iaddn(1) }, n.prototype.modrn = function (a) { var s = a < 0; s && (a = -a), r(a <= 67108863); for (var d = (1 << 26) % a, v = 0, p = this.length - 1; p >= 0; p--)v = (d * v + (this.words[p] | 0)) % a; return s ? -v : v }, n.prototype.modn = function (a) { return this.modrn(a) }, n.prototype.idivn = function (a) { var s = a < 0; s && (a = -a), r(a <= 67108863); for (var d = 0, v = this.length - 1; v >= 0; v--) { var p = (this.words[v] | 0) + d * 67108864; this.words[v] = p / a | 0, d = p % a } return this._strip(), s ? this.ineg() : this }, n.prototype.divn = function (a) { return this.clone().idivn(a) }, n.prototype.egcd = function (a) { r(a.negative === 0), r(!a.isZero()); var s = this, d = a.clone(); s.negative !== 0 ? s = s.umod(a) : s = s.clone(); for (var v = new n(1), p = new n(0), u = new n(0), m = new n(1), g = 0; s.isEven() && d.isEven();)s.iushrn(1), d.iushrn(1), ++g; for (var o = d.clone(), w = s.clone(); !s.isZero();) { for (var R = 0, k = 1; (s.words[0] & k) == 0 && R < 26; ++R, k <<= 1); if (R > 0) for (s.iushrn(R); R-- > 0;)(v.isOdd() || p.isOdd()) && (v.iadd(o), p.isub(w)), v.iushrn(1), p.iushrn(1); for (var q = 0, O = 1; (d.words[0] & O) == 0 && q < 26; ++q, O <<= 1); if (q > 0) for (d.iushrn(q); q-- > 0;)(u.isOdd() || m.isOdd()) && (u.iadd(o), m.isub(w)), u.iushrn(1), m.iushrn(1); s.cmp(d) >= 0 ? (s.isub(d), v.isub(u), p.isub(m)) : (d.isub(s), u.isub(v), m.isub(p)) } return { a: u, b: m, gcd: d.iushln(g) } }, n.prototype._invmp = function (a) { r(a.negative === 0), r(!a.isZero()); var s = this, d = a.clone(); s.negative !== 0 ? s = s.umod(a) : s = s.clone(); for (var v = new n(1), p = new n(0), u = d.clone(); s.cmpn(1) > 0 && d.cmpn(1) > 0;) { for (var m = 0, g = 1; (s.words[0] & g) == 0 && m < 26; ++m, g <<= 1); if (m > 0) for (s.iushrn(m); m-- > 0;)v.isOdd() && v.iadd(u), v.iushrn(1); for (var o = 0, w = 1; (d.words[0] & w) == 0 && o < 26; ++o, w <<= 1); if (o > 0) for (d.iushrn(o); o-- > 0;)p.isOdd() && p.iadd(u), p.iushrn(1); s.cmp(d) >= 0 ? (s.isub(d), v.isub(p)) : (d.isub(s), p.isub(v)) } var R; return s.cmpn(1) === 0 ? R = v : R = p, R.cmpn(0) < 0 && R.iadd(a), R }, n.prototype.gcd = function (a) { if (this.isZero()) return a.abs(); if (a.isZero()) return this.abs(); var s = this.clone(), d = a.clone(); s.negative = 0, d.negative = 0; for (var v = 0; s.isEven() && d.isEven(); v++)s.iushrn(1), d.iushrn(1); do { for (; s.isEven();)s.iushrn(1); for (; d.isEven();)d.iushrn(1); var p = s.cmp(d); if (p < 0) { var u = s; s = d, d = u } else if (p === 0 || d.cmpn(1) === 0) break; s.isub(d) } while (!0); return d.iushln(v) }, n.prototype.invm = function (a) { return this.egcd(a).a.umod(a) }, n.prototype.isEven = function () { return (this.words[0] & 1) == 0 }, n.prototype.isOdd = function () { return (this.words[0] & 1) == 1 }, n.prototype.andln = function (a) { return this.words[0] & a }, n.prototype.bincn = function (a) { r(typeof a == "number"); var s = a % 26, d = (a - s) / 26, v = 1 << s; if (this.length <= d) return this._expand(d + 1), this.words[d] |= v, this; for (var p = v, u = d; p !== 0 && u < this.length; u++) { var m = this.words[u] | 0; m += p, p = m >>> 26, m &= 67108863, this.words[u] = m } return p !== 0 && (this.words[u] = p, this.length++), this }, n.prototype.isZero = function () { return this.length === 1 && this.words[0] === 0 }, n.prototype.cmpn = function (a) { var s = a < 0; if (this.negative !== 0 && !s) return -1; if (this.negative === 0 && s) return 1; this._strip(); var d; if (this.length > 1) d = 1; else { s && (a = -a), r(a <= 67108863, "Number is too big"); var v = this.words[0] | 0; d = v === a ? 0 : v < a ? -1 : 1 } return this.negative !== 0 ? -d | 0 : d }, n.prototype.cmp = function (a) { if (this.negative !== 0 && a.negative === 0) return -1; if (this.negative === 0 && a.negative !== 0) return 1; var s = this.ucmp(a); return this.negative !== 0 ? -s | 0 : s }, n.prototype.ucmp = function (a) { if (this.length > a.length) return 1; if (this.length < a.length) return -1; for (var s = 0, d = this.length - 1; d >= 0; d--) { var v = this.words[d] | 0, p = a.words[d] | 0; if (v !== p) { v < p ? s = -1 : v > p && (s = 1); break } } return s }, n.prototype.gtn = function (a) { return this.cmpn(a) === 1 }, n.prototype.gt = function (a) { return this.cmp(a) === 1 }, n.prototype.gten = function (a) { return this.cmpn(a) >= 0 }, n.prototype.gte = function (a) { return this.cmp(a) >= 0 }, n.prototype.ltn = function (a) { return this.cmpn(a) === -1 }, n.prototype.lt = function (a) { return this.cmp(a) === -1 }, n.prototype.lten = function (a) { return this.cmpn(a) <= 0 }, n.prototype.lte = function (a) { return this.cmp(a) <= 0 }, n.prototype.eqn = function (a) { return this.cmpn(a) === 0 }, n.prototype.eq = function (a) { return this.cmp(a) === 0 }, n.red = function (a) { return new b(a) }, n.prototype.toRed = function (a) { return r(!this.red, "Already a number in reduction context"), r(this.negative === 0, "red works only with positives"), a.convertTo(this)._forceRed(a) }, n.prototype.fromRed = function () { return r(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this) }, n.prototype._forceRed = function (a) { return this.red = a, this }, n.prototype.forceRed = function (a) { return r(!this.red, "Already a number in reduction context"), this._forceRed(a) }, n.prototype.redAdd = function (a) { return r(this.red, "redAdd works only with red numbers"), this.red.add(this, a) }, n.prototype.redIAdd = function (a) { return r(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, a) }, n.prototype.redSub = function (a) { return r(this.red, "redSub works only with red numbers"), this.red.sub(this, a) }, n.prototype.redISub = function (a) { return r(this.red, "redISub works only with red numbers"), this.red.isub(this, a) }, n.prototype.redShl = function (a) { return r(this.red, "redShl works only with red numbers"), this.red.shl(this, a) }, n.prototype.redMul = function (a) { return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, a), this.red.mul(this, a) }, n.prototype.redIMul = function (a) { return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, a), this.red.imul(this, a) }, n.prototype.redSqr = function () { return r(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this) }, n.prototype.redISqr = function () { return r(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this) }, n.prototype.redSqrt = function () { return r(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this) }, n.prototype.redInvm = function () { return r(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this) }, n.prototype.redNeg = function () { return r(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this) }, n.prototype.redPow = function (a) { return r(this.red && !a.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, a) }; var Le = { k256: null, p224: null, p192: null, p25519: null }; function Me(l, a) { this.name = l, this.p = new n(a, 16), this.n = this.p.bitLength(), this.k = new n(1).iushln(this.n).isub(this.p), this.tmp = this._tmp() } Me.prototype._tmp = function () { var a = new n(null); return a.words = new Array(Math.ceil(this.n / 13)), a }, Me.prototype.ireduce = function (a) { var s = a, d; do this.split(s, this.tmp), s = this.imulK(s), s = s.iadd(this.tmp), d = s.bitLength(); while (d > this.n); var v = d < this.n ? -1 : s.ucmp(this.p); return v === 0 ? (s.words[0] = 0, s.length = 1) : v > 0 ? s.isub(this.p) : s.strip !== void 0 ? s.strip() : s._strip(), s }, Me.prototype.split = function (a, s) { a.iushrn(this.n, 0, s) }, Me.prototype.imulK = function (a) { return a.imul(this.k) }; function De() { Me.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f") } i(De, Me), De.prototype.split = function (a, s) { for (var d = 4194303, v = Math.min(a.length, 9), p = 0; p < v; p++)s.words[p] = a.words[p]; if (s.length = v, a.length <= 9) { a.words[0] = 0, a.length = 1; return } var u = a.words[9]; for (s.words[s.length++] = u & d, p = 10; p < a.length; p++) { var m = a.words[p] | 0; a.words[p - 10] = (m & d) << 4 | u >>> 22, u = m } u >>>= 22, a.words[p - 10] = u, u === 0 && a.length > 10 ? a.length -= 10 : a.length -= 9 }, De.prototype.imulK = function (a) { a.words[a.length] = 0, a.words[a.length + 1] = 0, a.length += 2; for (var s = 0, d = 0; d < a.length; d++) { var v = a.words[d] | 0; s += v * 977, a.words[d] = s & 67108863, s = v * 64 + (s / 67108864 | 0) } return a.words[a.length - 1] === 0 && (a.length--, a.words[a.length - 1] === 0 && a.length--), a }; function Ie() { Me.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001") } i(Ie, Me); function je() { Me.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff") } i(je, Me); function S() { Me.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed") } i(S, Me), S.prototype.imulK = function (a) { for (var s = 0, d = 0; d < a.length; d++) { var v = (a.words[d] | 0) * 19 + s, p = v & 67108863; v >>>= 26, a.words[d] = p, s = v } return s !== 0 && (a.words[a.length++] = s), a }, n._prime = function (a) { if (Le[a]) return Le[a]; var s; if (a === "k256") s = new De; else if (a === "p224") s = new Ie; else if (a === "p192") s = new je; else if (a === "p25519") s = new S; else throw new Error("Unknown prime " + a); return Le[a] = s, s }; function b(l) { if (typeof l == "string") { var a = n._prime(l); this.m = a.p, this.prime = a } else r(l.gtn(1), "modulus must be greater than 1"), this.m = l, this.prime = null } b.prototype._verify1 = function (a) { r(a.negative === 0, "red works only with positives"), r(a.red, "red works only with red numbers") }, b.prototype._verify2 = function (a, s) { r((a.negative | s.negative) == 0, "red works only with positives"), r(a.red && a.red === s.red, "red works only with red numbers") }, b.prototype.imod = function (a) { return this.prime ? this.prime.ireduce(a)._forceRed(this) : (x(a, a.umod(this.m)._forceRed(this)), a) }, b.prototype.neg = function (a) { return a.isZero() ? a.clone() : this.m.sub(a)._forceRed(this) }, b.prototype.add = function (a, s) { this._verify2(a, s); var d = a.add(s); return d.cmp(this.m) >= 0 && d.isub(this.m), d._forceRed(this) }, b.prototype.iadd = function (a, s) { this._verify2(a, s); var d = a.iadd(s); return d.cmp(this.m) >= 0 && d.isub(this.m), d }, b.prototype.sub = function (a, s) { this._verify2(a, s); var d = a.sub(s); return d.cmpn(0) < 0 && d.iadd(this.m), d._forceRed(this) }, b.prototype.isub = function (a, s) { this._verify2(a, s); var d = a.isub(s); return d.cmpn(0) < 0 && d.iadd(this.m), d }, b.prototype.shl = function (a, s) { return this._verify1(a), this.imod(a.ushln(s)) }, b.prototype.imul = function (a, s) { return this._verify2(a, s), this.imod(a.imul(s)) }, b.prototype.mul = function (a, s) { return this._verify2(a, s), this.imod(a.mul(s)) }, b.prototype.isqr = function (a) { return this.imul(a, a.clone()) }, b.prototype.sqr = function (a) { return this.mul(a, a) }, b.prototype.sqrt = function (a) { if (a.isZero()) return a.clone(); var s = this.m.andln(3); if (r(s % 2 == 1), s === 3) { var d = this.m.add(new n(1)).iushrn(2); return this.pow(a, d) } for (var v = this.m.subn(1), p = 0; !v.isZero() && v.andln(1) === 0;)p++, v.iushrn(1); r(!v.isZero()); var u = new n(1).toRed(this), m = u.redNeg(), g = this.m.subn(1).iushrn(1), o = this.m.bitLength(); for (o = new n(2 * o * o).toRed(this); this.pow(o, g).cmp(m) !== 0;)o.redIAdd(m); for (var w = this.pow(o, v), R = this.pow(a, v.addn(1).iushrn(1)), k = this.pow(a, v), q = p; k.cmp(u) !== 0;) { for (var O = k, D = 0; O.cmp(u) !== 0; D++)O = O.redSqr(); r(D < q); var U = this.pow(w, new n(1).iushln(q - D - 1)); R = R.redMul(U), w = U.redSqr(), k = k.redMul(w), q = D } return R }, b.prototype.invm = function (a) { var s = a._invmp(this.m); return s.negative !== 0 ? (s.negative = 0, this.imod(s).redNeg()) : this.imod(s) }, b.prototype.pow = function (a, s) { if (s.isZero()) return new n(1).toRed(this); if (s.cmpn(1) === 0) return a.clone(); var d = 4, v = new Array(1 << d); v[0] = new n(1).toRed(this), v[1] = a; for (var p = 2; p < v.length; p++)v[p] = this.mul(v[p - 1], a); var u = v[0], m = 0, g = 0, o = s.bitLength() % 26; for (o === 0 && (o = 26), p = s.length - 1; p >= 0; p--) { for (var w = s.words[p], R = o - 1; R >= 0; R--) { var k = w >> R & 1; if (u !== v[0] && (u = this.sqr(u)), k === 0 && m === 0) { g = 0; continue } m <<= 1, m |= k, g++, !(g !== d && (p !== 0 || R !== 0)) && (u = this.mul(u, v[m]), g = 0, m = 0) } o = 26 } return u }, b.prototype.convertTo = function (a) { var s = a.umod(this.m); return s === a ? s.clone() : s }, b.prototype.convertFrom = function (a) { var s = a.clone(); return s.red = null, s }, n.mont = function (a) { return new _(a) }; function _(l) { b.call(this, l), this.shift = this.m.bitLength(), this.shift % 26 != 0 && (this.shift += 26 - this.shift % 26), this.r = new n(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv) } i(_, b), _.prototype.convertTo = function (a) { return this.imod(a.ushln(this.shift)) }, _.prototype.convertFrom = function (a) { var s = this.imod(a.mul(this.rinv)); return s.red = null, s }, _.prototype.imul = function (a, s) { if (a.isZero() || s.isZero()) return a.words[0] = 0, a.length = 1, a; var d = a.imul(s), v = d.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), p = d.isub(v).iushrn(this.shift), u = p; return p.cmp(this.m) >= 0 ? u = p.isub(this.m) : p.cmpn(0) < 0 && (u = p.iadd(this.m)), u._forceRed(this) }, _.prototype.mul = function (a, s) { if (a.isZero() || s.isZero()) return new n(0)._forceRed(this); var d = a.mul(s), v = d.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), p = d.isub(v).iushrn(this.shift), u = p; return p.cmp(this.m) >= 0 ? u = p.isub(this.m) : p.cmpn(0) < 0 && (u = p.iadd(this.m)), u._forceRed(this) }, _.prototype.invm = function (a) { var s = this.imod(a._invmp(this.m).mul(this.r2)); return s._forceRed(this) } })(typeof bu == "undefined" || bu, hb) }); var _o = I((rB, lb) => { var pa = ub(), d9 = an(); function l9(t) { var e = cb(t), r = e.toRed(pa.mont(t.modulus)).redPow(new pa(t.publicExponent)).fromRed(); return { blinder: r, unblinder: e.invm(t.modulus) } } function cb(t) { var e = t.modulus.byteLength(), r; do r = new pa(d9(e)); while (r.cmp(t.modulus) >= 0 || !r.umod(t.prime1) || !r.umod(t.prime2)); return r } function db(t, e) { var r = l9(e), i = e.modulus.byteLength(), n = new pa(t).mul(r.blinder).umod(e.modulus), f = n.toRed(pa.mont(e.prime1)), h = n.toRed(pa.mont(e.prime2)), c = e.coefficient, y = e.prime1, x = e.prime2, M = f.redPow(e.exponent1).fromRed(), E = h.redPow(e.exponent2).fromRed(), A = M.isub(E).imul(c).umod(y).imul(x); return E.iadd(A).imul(r.unblinder).umod(e.modulus).toArrayLike(Buffer, "be", i) } db.getr = cb; lb.exports = db }); var mu = I((pb, yu) => { (function (t, e) { "use strict"; function r(l, a) { if (!l) throw new Error(a || "Assertion failed") } function i(l, a) { l.super_ = a; var s = function () { }; s.prototype = a.prototype, l.prototype = new s, l.prototype.constructor = l } function n(l, a, s) { if (n.isBN(l)) return l; this.negative = 0, this.words = null, this.length = 0, this.red = null, l !== null && ((a === "le" || a === "be") && (s = a, a = 10), this._init(l || 0, a || 10, s || "be")) } typeof t == "object" ? t.exports = n : e.BN = n, n.BN = n, n.wordSize = 26; var f; try { typeof window != "undefined" && typeof window.Buffer != "undefined" ? f = window.Buffer : f = ct().Buffer } catch (l) { } n.isBN = function (a) { return a instanceof n ? !0 : a !== null && typeof a == "object" && a.constructor.wordSize === n.wordSize && Array.isArray(a.words) }, n.max = function (a, s) { return a.cmp(s) > 0 ? a : s }, n.min = function (a, s) { return a.cmp(s) < 0 ? a : s }, n.prototype._init = function (a, s, d) { if (typeof a == "number") return this._initNumber(a, s, d); if (typeof a == "object") return this._initArray(a, s, d); s === "hex" && (s = 16), r(s === (s | 0) && s >= 2 && s <= 36), a = a.toString().replace(/\s+/g, ""); var v = 0; a[0] === "-" && (v++, this.negative = 1), v < a.length && (s === 16 ? this._parseHex(a, v, d) : (this._parseBase(a, s, v), d === "le" && this._initArray(this.toArray(), s, d))) }, n.prototype._initNumber = function (a, s, d) { a < 0 && (this.negative = 1, a = -a), a < 67108864 ? (this.words = [a & 67108863], this.length = 1) : a < 4503599627370496 ? (this.words = [a & 67108863, a / 67108864 & 67108863], this.length = 2) : (r(a < 9007199254740992), this.words = [a & 67108863, a / 67108864 & 67108863, 1], this.length = 3), d === "le" && this._initArray(this.toArray(), s, d) }, n.prototype._initArray = function (a, s, d) { if (r(typeof a.length == "number"), a.length <= 0) return this.words = [0], this.length = 1, this; this.length = Math.ceil(a.length / 3), this.words = new Array(this.length); for (var v = 0; v < this.length; v++)this.words[v] = 0; var p, u, m = 0; if (d === "be") for (v = a.length - 1, p = 0; v >= 0; v -= 3)u = a[v] | a[v - 1] << 8 | a[v - 2] << 16, this.words[p] |= u << m & 67108863, this.words[p + 1] = u >>> 26 - m & 67108863, m += 24, m >= 26 && (m -= 26, p++); else if (d === "le") for (v = 0, p = 0; v < a.length; v += 3)u = a[v] | a[v + 1] << 8 | a[v + 2] << 16, this.words[p] |= u << m & 67108863, this.words[p + 1] = u >>> 26 - m & 67108863, m += 24, m >= 26 && (m -= 26, p++); return this._strip() }; function h(l, a) { var s = l.charCodeAt(a); if (s >= 48 && s <= 57) return s - 48; if (s >= 65 && s <= 70) return s - 55; if (s >= 97 && s <= 102) return s - 87; r(!1, "Invalid character in " + l) } function c(l, a, s) { var d = h(l, s); return s - 1 >= a && (d |= h(l, s - 1) << 4), d } n.prototype._parseHex = function (a, s, d) { this.length = Math.ceil((a.length - s) / 6), this.words = new Array(this.length); for (var v = 0; v < this.length; v++)this.words[v] = 0; var p = 0, u = 0, m; if (d === "be") for (v = a.length - 1; v >= s; v -= 2)m = c(a, s, v) << p, this.words[u] |= m & 67108863, p >= 18 ? (p -= 18, u += 1, this.words[u] |= m >>> 26) : p += 8; else { var g = a.length - s; for (v = g % 2 == 0 ? s + 1 : s; v < a.length; v += 2)m = c(a, s, v) << p, this.words[u] |= m & 67108863, p >= 18 ? (p -= 18, u += 1, this.words[u] |= m >>> 26) : p += 8 } this._strip() }; function y(l, a, s, d) { for (var v = 0, p = 0, u = Math.min(l.length, s), m = a; m < u; m++) { var g = l.charCodeAt(m) - 48; v *= d, g >= 49 ? p = g - 49 + 10 : g >= 17 ? p = g - 17 + 10 : p = g, r(g >= 0 && p < d, "Invalid character"), v += p } return v } n.prototype._parseBase = function (a, s, d) { this.words = [0], this.length = 1; for (var v = 0, p = 1; p <= 67108863; p *= s)v++; v--, p = p / s | 0; for (var u = a.length - d, m = u % v, g = Math.min(u, u - m) + d, o = 0, w = d; w < g; w += v)o = y(a, w, w + v, s), this.imuln(p), this.words[0] + o < 67108864 ? this.words[0] += o : this._iaddn(o); if (m !== 0) { var R = 1; for (o = y(a, w, a.length, s), w = 0; w < m; w++)R *= s; this.imuln(R), this.words[0] + o < 67108864 ? this.words[0] += o : this._iaddn(o) } this._strip() }, n.prototype.copy = function (a) { a.words = new Array(this.length); for (var s = 0; s < this.length; s++)a.words[s] = this.words[s]; a.length = this.length, a.negative = this.negative, a.red = this.red }; function x(l, a) { l.words = a.words, l.length = a.length, l.negative = a.negative, l.red = a.red } if (n.prototype._move = function (a) { x(a, this) }, n.prototype.clone = function () { var a = new n(null); return this.copy(a), a }, n.prototype._expand = function (a) { for (; this.length < a;)this.words[this.length++] = 0; return this }, n.prototype._strip = function () { for (; this.length > 1 && this.words[this.length - 1] === 0;)this.length--; return this._normSign() }, n.prototype._normSign = function () { return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this }, typeof Symbol != "undefined" && typeof Symbol.for == "function") try { n.prototype[Symbol.for("nodejs.util.inspect.custom")] = M } catch (l) { n.prototype.inspect = M } else n.prototype.inspect = M; function M() { return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">" } var E = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], A = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], B = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176]; n.prototype.toString = function (a, s) { a = a || 10, s = s | 0 || 1; var d; if (a === 16 || a === "hex") { d = ""; for (var v = 0, p = 0, u = 0; u < this.length; u++) { var m = this.words[u], g = ((m << v | p) & 16777215).toString(16); p = m >>> 24 - v & 16777215, p !== 0 || u !== this.length - 1 ? d = E[6 - g.length] + g + d : d = g + d, v += 2, v >= 26 && (v -= 26, u--) } for (p !== 0 && (d = p.toString(16) + d); d.length % s != 0;)d = "0" + d; return this.negative !== 0 && (d = "-" + d), d } if (a === (a | 0) && a >= 2 && a <= 36) { var o = A[a], w = B[a]; d = ""; var R = this.clone(); for (R.negative = 0; !R.isZero();) { var k = R.modrn(w).toString(a); R = R.idivn(w), R.isZero() ? d = k + d : d = E[o - k.length] + k + d } for (this.isZero() && (d = "0" + d); d.length % s != 0;)d = "0" + d; return this.negative !== 0 && (d = "-" + d), d } r(!1, "Base should be between 2 and 36") }, n.prototype.toNumber = function () { var a = this.words[0]; return this.length === 2 ? a += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? a += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && r(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -a : a }, n.prototype.toJSON = function () { return this.toString(16, 2) }, f && (n.prototype.toBuffer = function (a, s) { return this.toArrayLike(f, a, s) }), n.prototype.toArray = function (a, s) { return this.toArrayLike(Array, a, s) }; var T = function (a, s) { return a.allocUnsafe ? a.allocUnsafe(s) : new a(s) }; n.prototype.toArrayLike = function (a, s, d) { this._strip(); var v = this.byteLength(), p = d || Math.max(1, v); r(v <= p, "byte array longer than desired length"), r(p > 0, "Requested array length <= 0"); var u = T(a, p), m = s === "le" ? "LE" : "BE"; return this["_toArrayLike" + m](u, v), u }, n.prototype._toArrayLikeLE = function (a, s) { for (var d = 0, v = 0, p = 0, u = 0; p < this.length; p++) { var m = this.words[p] << u | v; a[d++] = m & 255, d < a.length && (a[d++] = m >> 8 & 255), d < a.length && (a[d++] = m >> 16 & 255), u === 6 ? (d < a.length && (a[d++] = m >> 24 & 255), v = 0, u = 0) : (v = m >>> 24, u += 2) } if (d < a.length) for (a[d++] = v; d < a.length;)a[d++] = 0 }, n.prototype._toArrayLikeBE = function (a, s) { for (var d = a.length - 1, v = 0, p = 0, u = 0; p < this.length; p++) { var m = this.words[p] << u | v; a[d--] = m & 255, d >= 0 && (a[d--] = m >> 8 & 255), d >= 0 && (a[d--] = m >> 16 & 255), u === 6 ? (d >= 0 && (a[d--] = m >> 24 & 255), v = 0, u = 0) : (v = m >>> 24, u += 2) } if (d >= 0) for (a[d--] = v; d >= 0;)a[d--] = 0 }, Math.clz32 ? n.prototype._countBits = function (a) { return 32 - Math.clz32(a) } : n.prototype._countBits = function (a) { var s = a, d = 0; return s >= 4096 && (d += 13, s >>>= 13), s >= 64 && (d += 7, s >>>= 7), s >= 8 && (d += 4, s >>>= 4), s >= 2 && (d += 2, s >>>= 2), d + s }, n.prototype._zeroBits = function (a) { if (a === 0) return 26; var s = a, d = 0; return (s & 8191) == 0 && (d += 13, s >>>= 13), (s & 127) == 0 && (d += 7, s >>>= 7), (s & 15) == 0 && (d += 4, s >>>= 4), (s & 3) == 0 && (d += 2, s >>>= 2), (s & 1) == 0 && d++, d }, n.prototype.bitLength = function () { var a = this.words[this.length - 1], s = this._countBits(a); return (this.length - 1) * 26 + s }; function C(l) { for (var a = new Array(l.bitLength()), s = 0; s < a.length; s++) { var d = s / 26 | 0, v = s % 26; a[s] = l.words[d] >>> v & 1 } return a } n.prototype.zeroBits = function () { if (this.isZero()) return 0; for (var a = 0, s = 0; s < this.length; s++) { var d = this._zeroBits(this.words[s]); if (a += d, d !== 26) break } return a }, n.prototype.byteLength = function () { return Math.ceil(this.bitLength() / 8) }, n.prototype.toTwos = function (a) { return this.negative !== 0 ? this.abs().inotn(a).iaddn(1) : this.clone() }, n.prototype.fromTwos = function (a) { return this.testn(a - 1) ? this.notn(a).iaddn(1).ineg() : this.clone() }, n.prototype.isNeg = function () { return this.negative !== 0 }, n.prototype.neg = function () { return this.clone().ineg() }, n.prototype.ineg = function () { return this.isZero() || (this.negative ^= 1), this }, n.prototype.iuor = function (a) { for (; this.length < a.length;)this.words[this.length++] = 0; for (var s = 0; s < a.length; s++)this.words[s] = this.words[s] | a.words[s]; return this._strip() }, n.prototype.ior = function (a) { return r((this.negative | a.negative) == 0), this.iuor(a) }, n.prototype.or = function (a) { return this.length > a.length ? this.clone().ior(a) : a.clone().ior(this) }, n.prototype.uor = function (a) { return this.length > a.length ? this.clone().iuor(a) : a.clone().iuor(this) }, n.prototype.iuand = function (a) { var s; this.length > a.length ? s = a : s = this; for (var d = 0; d < s.length; d++)this.words[d] = this.words[d] & a.words[d]; return this.length = s.length, this._strip() }, n.prototype.iand = function (a) { return r((this.negative | a.negative) == 0), this.iuand(a) }, n.prototype.and = function (a) { return this.length > a.length ? this.clone().iand(a) : a.clone().iand(this) }, n.prototype.uand = function (a) { return this.length > a.length ? this.clone().iuand(a) : a.clone().iuand(this) }, n.prototype.iuxor = function (a) { var s, d; this.length > a.length ? (s = this, d = a) : (s = a, d = this); for (var v = 0; v < d.length; v++)this.words[v] = s.words[v] ^ d.words[v]; if (this !== s) for (; v < s.length; v++)this.words[v] = s.words[v]; return this.length = s.length, this._strip() }, n.prototype.ixor = function (a) { return r((this.negative | a.negative) == 0), this.iuxor(a) }, n.prototype.xor = function (a) { return this.length > a.length ? this.clone().ixor(a) : a.clone().ixor(this) }, n.prototype.uxor = function (a) { return this.length > a.length ? this.clone().iuxor(a) : a.clone().iuxor(this) }, n.prototype.inotn = function (a) { r(typeof a == "number" && a >= 0); var s = Math.ceil(a / 26) | 0, d = a % 26; this._expand(s), d > 0 && s--; for (var v = 0; v < s; v++)this.words[v] = ~this.words[v] & 67108863; return d > 0 && (this.words[v] = ~this.words[v] & 67108863 >> 26 - d), this._strip() }, n.prototype.notn = function (a) { return this.clone().inotn(a) }, n.prototype.setn = function (a, s) { r(typeof a == "number" && a >= 0); var d = a / 26 | 0, v = a % 26; return this._expand(d + 1), s ? this.words[d] = this.words[d] | 1 << v : this.words[d] = this.words[d] & ~(1 << v), this._strip() }, n.prototype.iadd = function (a) { var s; if (this.negative !== 0 && a.negative === 0) return this.negative = 0, s = this.isub(a), this.negative ^= 1, this._normSign(); if (this.negative === 0 && a.negative !== 0) return a.negative = 0, s = this.isub(a), a.negative = 1, s._normSign(); var d, v; this.length > a.length ? (d = this, v = a) : (d = a, v = this); for (var p = 0, u = 0; u < v.length; u++)s = (d.words[u] | 0) + (v.words[u] | 0) + p, this.words[u] = s & 67108863, p = s >>> 26; for (; p !== 0 && u < d.length; u++)s = (d.words[u] | 0) + p, this.words[u] = s & 67108863, p = s >>> 26; if (this.length = d.length, p !== 0) this.words[this.length] = p, this.length++; else if (d !== this) for (; u < d.length; u++)this.words[u] = d.words[u]; return this }, n.prototype.add = function (a) { var s; return a.negative !== 0 && this.negative === 0 ? (a.negative = 0, s = this.sub(a), a.negative ^= 1, s) : a.negative === 0 && this.negative !== 0 ? (this.negative = 0, s = a.sub(this), this.negative = 1, s) : this.length > a.length ? this.clone().iadd(a) : a.clone().iadd(this) }, n.prototype.isub = function (a) { if (a.negative !== 0) { a.negative = 0; var s = this.iadd(a); return a.negative = 1, s._normSign() } else if (this.negative !== 0) return this.negative = 0, this.iadd(a), this.negative = 1, this._normSign(); var d = this.cmp(a); if (d === 0) return this.negative = 0, this.length = 1, this.words[0] = 0, this; var v, p; d > 0 ? (v = this, p = a) : (v = a, p = this); for (var u = 0, m = 0; m < p.length; m++)s = (v.words[m] | 0) - (p.words[m] | 0) + u, u = s >> 26, this.words[m] = s & 67108863; for (; u !== 0 && m < v.length; m++)s = (v.words[m] | 0) + u, u = s >> 26, this.words[m] = s & 67108863; if (u === 0 && m < v.length && v !== this) for (; m < v.length; m++)this.words[m] = v.words[m]; return this.length = Math.max(this.length, m), v !== this && (this.negative = 1), this._strip() }, n.prototype.sub = function (a) { return this.clone().isub(a) }; function H(l, a, s) { s.negative = a.negative ^ l.negative; var d = l.length + a.length | 0; s.length = d, d = d - 1 | 0; var v = l.words[0] | 0, p = a.words[0] | 0, u = v * p, m = u & 67108863, g = u / 67108864 | 0; s.words[0] = m; for (var o = 1; o < d; o++) { for (var w = g >>> 26, R = g & 67108863, k = Math.min(o, a.length - 1), q = Math.max(0, o - l.length + 1); q <= k; q++) { var O = o - q | 0; v = l.words[O] | 0, p = a.words[q] | 0, u = v * p + R, w += u / 67108864 | 0, R = u & 67108863 } s.words[o] = R | 0, g = w | 0 } return g !== 0 ? s.words[o] = g | 0 : s.length--, s._strip() } var F = function (a, s, d) { var v = a.words, p = s.words, u = d.words, m = 0, g, o, w, R = v[0] | 0, k = R & 8191, q = R >>> 13, O = v[1] | 0, D = O & 8191, U = O >>> 13, Qe = v[2] | 0, N = Qe & 8191, L = Qe >>> 13, vi = v[3] | 0, j = vi & 8191, z = vi >>> 13, bi = v[4] | 0, W = bi & 8191, K = bi >>> 13, yi = v[5] | 0, V = yi & 8191, G = yi >>> 13, mi = v[6] | 0, $ = mi & 8191, X = mi >>> 13, gi = v[7] | 0, Y = gi & 8191, Z = gi >>> 13, wi = v[8] | 0, J = wi & 8191, Q = wi >>> 13, _i = v[9] | 0, ee = _i & 8191, te = _i >>> 13, xi = p[0] | 0, re = xi & 8191, ie = xi >>> 13, Mi = p[1] | 0, ne = Mi & 8191, ae = Mi >>> 13, Si = p[2] | 0, fe = Si & 8191, se = Si >>> 13, Ei = p[3] | 0, oe = Ei & 8191, he = Ei >>> 13, Ai = p[4] | 0, ue = Ai & 8191, ce = Ai >>> 13, Bi = p[5] | 0, de = Bi & 8191, le = Bi >>> 13, Ii = p[6] | 0, pe = Ii & 8191, ve = Ii >>> 13, Ri = p[7] | 0, be = Ri & 8191, ye = Ri >>> 13, Ti = p[8] | 0, me = Ti & 8191, ge = Ti >>> 13, Vr = p[9] | 0, Se = Vr & 8191, Ee = Vr >>> 13; d.negative = a.negative ^ s.negative, d.length = 19, g = Math.imul(k, re), o = Math.imul(k, ie), o = o + Math.imul(q, re) | 0, w = Math.imul(q, ie); var Qt = (m + g | 0) + ((o & 8191) << 13) | 0; m = (w + (o >>> 13) | 0) + (Qt >>> 26) | 0, Qt &= 67108863, g = Math.imul(D, re), o = Math.imul(D, ie), o = o + Math.imul(U, re) | 0, w = Math.imul(U, ie), g = g + Math.imul(k, ne) | 0, o = o + Math.imul(k, ae) | 0, o = o + Math.imul(q, ne) | 0, w = w + Math.imul(q, ae) | 0; var er = (m + g | 0) + ((o & 8191) << 13) | 0; m = (w + (o >>> 13) | 0) + (er >>> 26) | 0, er &= 67108863, g = Math.imul(N, re), o = Math.imul(N, ie), o = o + Math.imul(L, re) | 0, w = Math.imul(L, ie), g = g + Math.imul(D, ne) | 0, o = o + Math.imul(D, ae) | 0, o = o + Math.imul(U, ne) | 0, w = w + Math.imul(U, ae) | 0, g = g + Math.imul(k, fe) | 0, o = o + Math.imul(k, se) | 0, o = o + Math.imul(q, fe) | 0, w = w + Math.imul(q, se) | 0; var tr = (m + g | 0) + ((o & 8191) << 13) | 0; m = (w + (o >>> 13) | 0) + (tr >>> 26) | 0, tr &= 67108863, g = Math.imul(j, re), o = Math.imul(j, ie), o = o + Math.imul(z, re) | 0, w = Math.imul(z, ie), g = g + Math.imul(N, ne) | 0, o = o + Math.imul(N, ae) | 0, o = o + Math.imul(L, ne) | 0, w = w + Math.imul(L, ae) | 0, g = g + Math.imul(D, fe) | 0, o = o + Math.imul(D, se) | 0, o = o + Math.imul(U, fe) | 0, w = w + Math.imul(U, se) | 0, g = g + Math.imul(k, oe) | 0, o = o + Math.imul(k, he) | 0, o = o + Math.imul(q, oe) | 0, w = w + Math.imul(q, he) | 0; var rr = (m + g | 0) + ((o & 8191) << 13) | 0; m = (w + (o >>> 13) | 0) + (rr >>> 26) | 0, rr &= 67108863, g = Math.imul(W, re), o = Math.imul(W, ie), o = o + Math.imul(K, re) | 0, w = Math.imul(K, ie), g = g + Math.imul(j, ne) | 0, o = o + Math.imul(j, ae) | 0, o = o + Math.imul(z, ne) | 0, w = w + Math.imul(z, ae) | 0, g = g + Math.imul(N, fe) | 0, o = o + Math.imul(N, se) | 0, o = o + Math.imul(L, fe) | 0, w = w + Math.imul(L, se) | 0, g = g + Math.imul(D, oe) | 0, o = o + Math.imul(D, he) | 0, o = o + Math.imul(U, oe) | 0, w = w + Math.imul(U, he) | 0, g = g + Math.imul(k, ue) | 0, o = o + Math.imul(k, ce) | 0, o = o + Math.imul(q, ue) | 0, w = w + Math.imul(q, ce) | 0; var ir = (m + g | 0) + ((o & 8191) << 13) | 0; m = (w + (o >>> 13) | 0) + (ir >>> 26) | 0, ir &= 67108863, g = Math.imul(V, re), o = Math.imul(V, ie), o = o + Math.imul(G, re) | 0, w = Math.imul(G, ie), g = g + Math.imul(W, ne) | 0, o = o + Math.imul(W, ae) | 0, o = o + Math.imul(K, ne) | 0, w = w + Math.imul(K, ae) | 0, g = g + Math.imul(j, fe) | 0, o = o + Math.imul(j, se) | 0, o = o + Math.imul(z, fe) | 0, w = w + Math.imul(z, se) | 0, g = g + Math.imul(N, oe) | 0, o = o + Math.imul(N, he) | 0, o = o + Math.imul(L, oe) | 0, w = w + Math.imul(L, he) | 0, g = g + Math.imul(D, ue) | 0, o = o + Math.imul(D, ce) | 0, o = o + Math.imul(U, ue) | 0, w = w + Math.imul(U, ce) | 0, g = g + Math.imul(k, de) | 0, o = o + Math.imul(k, le) | 0, o = o + Math.imul(q, de) | 0, w = w + Math.imul(q, le) | 0; var nr = (m + g | 0) + ((o & 8191) << 13) | 0; m = (w + (o >>> 13) | 0) + (nr >>> 26) | 0, nr &= 67108863, g = Math.imul($, re), o = Math.imul($, ie), o = o + Math.imul(X, re) | 0, w = Math.imul(X, ie), g = g + Math.imul(V, ne) | 0, o = o + Math.imul(V, ae) | 0, o = o + Math.imul(G, ne) | 0, w = w + Math.imul(G, ae) | 0, g = g + Math.imul(W, fe) | 0, o = o + Math.imul(W, se) | 0, o = o + Math.imul(K, fe) | 0, w = w + Math.imul(K, se) | 0, g = g + Math.imul(j, oe) | 0, o = o + Math.imul(j, he) | 0, o = o + Math.imul(z, oe) | 0, w = w + Math.imul(z, he) | 0, g = g + Math.imul(N, ue) | 0, o = o + Math.imul(N, ce) | 0, o = o + Math.imul(L, ue) | 0, w = w + Math.imul(L, ce) | 0, g = g + Math.imul(D, de) | 0, o = o + Math.imul(D, le) | 0, o = o + Math.imul(U, de) | 0, w = w + Math.imul(U, le) | 0, g = g + Math.imul(k, pe) | 0, o = o + Math.imul(k, ve) | 0, o = o + Math.imul(q, pe) | 0, w = w + Math.imul(q, ve) | 0; var ar = (m + g | 0) + ((o & 8191) << 13) | 0; m = (w + (o >>> 13) | 0) + (ar >>> 26) | 0, ar &= 67108863, g = Math.imul(Y, re), o = Math.imul(Y, ie), o = o + Math.imul(Z, re) | 0, w = Math.imul(Z, ie), g = g + Math.imul($, ne) | 0, o = o + Math.imul($, ae) | 0, o = o + Math.imul(X, ne) | 0, w = w + Math.imul(X, ae) | 0, g = g + Math.imul(V, fe) | 0, o = o + Math.imul(V, se) | 0, o = o + Math.imul(G, fe) | 0, w = w + Math.imul(G, se) | 0, g = g + Math.imul(W, oe) | 0, o = o + Math.imul(W, he) | 0, o = o + Math.imul(K, oe) | 0, w = w + Math.imul(K, he) | 0, g = g + Math.imul(j, ue) | 0, o = o + Math.imul(j, ce) | 0, o = o + Math.imul(z, ue) | 0, w = w + Math.imul(z, ce) | 0, g = g + Math.imul(N, de) | 0, o = o + Math.imul(N, le) | 0, o = o + Math.imul(L, de) | 0, w = w + Math.imul(L, le) | 0, g = g + Math.imul(D, pe) | 0, o = o + Math.imul(D, ve) | 0, o = o + Math.imul(U, pe) | 0, w = w + Math.imul(U, ve) | 0, g = g + Math.imul(k, be) | 0, o = o + Math.imul(k, ye) | 0, o = o + Math.imul(q, be) | 0, w = w + Math.imul(q, ye) | 0; var fr = (m + g | 0) + ((o & 8191) << 13) | 0; m = (w + (o >>> 13) | 0) + (fr >>> 26) | 0, fr &= 67108863, g = Math.imul(J, re), o = Math.imul(J, ie), o = o + Math.imul(Q, re) | 0, w = Math.imul(Q, ie), g = g + Math.imul(Y, ne) | 0, o = o + Math.imul(Y, ae) | 0, o = o + Math.imul(Z, ne) | 0, w = w + Math.imul(Z, ae) | 0, g = g + Math.imul($, fe) | 0, o = o + Math.imul($, se) | 0, o = o + Math.imul(X, fe) | 0, w = w + Math.imul(X, se) | 0, g = g + Math.imul(V, oe) | 0, o = o + Math.imul(V, he) | 0, o = o + Math.imul(G, oe) | 0, w = w + Math.imul(G, he) | 0, g = g + Math.imul(W, ue) | 0, o = o + Math.imul(W, ce) | 0, o = o + Math.imul(K, ue) | 0, w = w + Math.imul(K, ce) | 0, g = g + Math.imul(j, de) | 0, o = o + Math.imul(j, le) | 0, o = o + Math.imul(z, de) | 0, w = w + Math.imul(z, le) | 0, g = g + Math.imul(N, pe) | 0, o = o + Math.imul(N, ve) | 0, o = o + Math.imul(L, pe) | 0, w = w + Math.imul(L, ve) | 0, g = g + Math.imul(D, be) | 0, o = o + Math.imul(D, ye) | 0, o = o + Math.imul(U, be) | 0, w = w + Math.imul(U, ye) | 0, g = g + Math.imul(k, me) | 0, o = o + Math.imul(k, ge) | 0, o = o + Math.imul(q, me) | 0, w = w + Math.imul(q, ge) | 0; var sr = (m + g | 0) + ((o & 8191) << 13) | 0; m = (w + (o >>> 13) | 0) + (sr >>> 26) | 0, sr &= 67108863, g = Math.imul(ee, re), o = Math.imul(ee, ie), o = o + Math.imul(te, re) | 0, w = Math.imul(te, ie), g = g + Math.imul(J, ne) | 0, o = o + Math.imul(J, ae) | 0, o = o + Math.imul(Q, ne) | 0, w = w + Math.imul(Q, ae) | 0, g = g + Math.imul(Y, fe) | 0, o = o + Math.imul(Y, se) | 0, o = o + Math.imul(Z, fe) | 0, w = w + Math.imul(Z, se) | 0, g = g + Math.imul($, oe) | 0, o = o + Math.imul($, he) | 0, o = o + Math.imul(X, oe) | 0, w = w + Math.imul(X, he) | 0, g = g + Math.imul(V, ue) | 0, o = o + Math.imul(V, ce) | 0, o = o + Math.imul(G, ue) | 0, w = w + Math.imul(G, ce) | 0, g = g + Math.imul(W, de) | 0, o = o + Math.imul(W, le) | 0, o = o + Math.imul(K, de) | 0, w = w + Math.imul(K, le) | 0, g = g + Math.imul(j, pe) | 0, o = o + Math.imul(j, ve) | 0, o = o + Math.imul(z, pe) | 0, w = w + Math.imul(z, ve) | 0, g = g + Math.imul(N, be) | 0, o = o + Math.imul(N, ye) | 0, o = o + Math.imul(L, be) | 0, w = w + Math.imul(L, ye) | 0, g = g + Math.imul(D, me) | 0, o = o + Math.imul(D, ge) | 0, o = o + Math.imul(U, me) | 0, w = w + Math.imul(U, ge) | 0, g = g + Math.imul(k, Se) | 0, o = o + Math.imul(k, Ee) | 0, o = o + Math.imul(q, Se) | 0, w = w + Math.imul(q, Ee) | 0; var or = (m + g | 0) + ((o & 8191) << 13) | 0; m = (w + (o >>> 13) | 0) + (or >>> 26) | 0, or &= 67108863, g = Math.imul(ee, ne), o = Math.imul(ee, ae), o = o + Math.imul(te, ne) | 0, w = Math.imul(te, ae), g = g + Math.imul(J, fe) | 0, o = o + Math.imul(J, se) | 0, o = o + Math.imul(Q, fe) | 0, w = w + Math.imul(Q, se) | 0, g = g + Math.imul(Y, oe) | 0, o = o + Math.imul(Y, he) | 0, o = o + Math.imul(Z, oe) | 0, w = w + Math.imul(Z, he) | 0, g = g + Math.imul($, ue) | 0, o = o + Math.imul($, ce) | 0, o = o + Math.imul(X, ue) | 0, w = w + Math.imul(X, ce) | 0, g = g + Math.imul(V, de) | 0, o = o + Math.imul(V, le) | 0, o = o + Math.imul(G, de) | 0, w = w + Math.imul(G, le) | 0, g = g + Math.imul(W, pe) | 0, o = o + Math.imul(W, ve) | 0, o = o + Math.imul(K, pe) | 0, w = w + Math.imul(K, ve) | 0, g = g + Math.imul(j, be) | 0, o = o + Math.imul(j, ye) | 0, o = o + Math.imul(z, be) | 0, w = w + Math.imul(z, ye) | 0, g = g + Math.imul(N, me) | 0, o = o + Math.imul(N, ge) | 0, o = o + Math.imul(L, me) | 0, w = w + Math.imul(L, ge) | 0, g = g + Math.imul(D, Se) | 0, o = o + Math.imul(D, Ee) | 0, o = o + Math.imul(U, Se) | 0, w = w + Math.imul(U, Ee) | 0; var hr = (m + g | 0) + ((o & 8191) << 13) | 0; m = (w + (o >>> 13) | 0) + (hr >>> 26) | 0, hr &= 67108863, g = Math.imul(ee, fe), o = Math.imul(ee, se), o = o + Math.imul(te, fe) | 0, w = Math.imul(te, se), g = g + Math.imul(J, oe) | 0, o = o + Math.imul(J, he) | 0, o = o + Math.imul(Q, oe) | 0, w = w + Math.imul(Q, he) | 0, g = g + Math.imul(Y, ue) | 0, o = o + Math.imul(Y, ce) | 0, o = o + Math.imul(Z, ue) | 0, w = w + Math.imul(Z, ce) | 0, g = g + Math.imul($, de) | 0, o = o + Math.imul($, le) | 0, o = o + Math.imul(X, de) | 0, w = w + Math.imul(X, le) | 0, g = g + Math.imul(V, pe) | 0, o = o + Math.imul(V, ve) | 0, o = o + Math.imul(G, pe) | 0, w = w + Math.imul(G, ve) | 0, g = g + Math.imul(W, be) | 0, o = o + Math.imul(W, ye) | 0, o = o + Math.imul(K, be) | 0, w = w + Math.imul(K, ye) | 0, g = g + Math.imul(j, me) | 0, o = o + Math.imul(j, ge) | 0, o = o + Math.imul(z, me) | 0, w = w + Math.imul(z, ge) | 0, g = g + Math.imul(N, Se) | 0, o = o + Math.imul(N, Ee) | 0, o = o + Math.imul(L, Se) | 0, w = w + Math.imul(L, Ee) | 0; var ur = (m + g | 0) + ((o & 8191) << 13) | 0; m = (w + (o >>> 13) | 0) + (ur >>> 26) | 0, ur &= 67108863, g = Math.imul(ee, oe), o = Math.imul(ee, he), o = o + Math.imul(te, oe) | 0, w = Math.imul(te, he), g = g + Math.imul(J, ue) | 0, o = o + Math.imul(J, ce) | 0, o = o + Math.imul(Q, ue) | 0, w = w + Math.imul(Q, ce) | 0, g = g + Math.imul(Y, de) | 0, o = o + Math.imul(Y, le) | 0, o = o + Math.imul(Z, de) | 0, w = w + Math.imul(Z, le) | 0, g = g + Math.imul($, pe) | 0, o = o + Math.imul($, ve) | 0, o = o + Math.imul(X, pe) | 0, w = w + Math.imul(X, ve) | 0, g = g + Math.imul(V, be) | 0, o = o + Math.imul(V, ye) | 0, o = o + Math.imul(G, be) | 0, w = w + Math.imul(G, ye) | 0, g = g + Math.imul(W, me) | 0, o = o + Math.imul(W, ge) | 0, o = o + Math.imul(K, me) | 0, w = w + Math.imul(K, ge) | 0, g = g + Math.imul(j, Se) | 0, o = o + Math.imul(j, Ee) | 0, o = o + Math.imul(z, Se) | 0, w = w + Math.imul(z, Ee) | 0; var cr = (m + g | 0) + ((o & 8191) << 13) | 0; m = (w + (o >>> 13) | 0) + (cr >>> 26) | 0, cr &= 67108863, g = Math.imul(ee, ue), o = Math.imul(ee, ce), o = o + Math.imul(te, ue) | 0, w = Math.imul(te, ce), g = g + Math.imul(J, de) | 0, o = o + Math.imul(J, le) | 0, o = o + Math.imul(Q, de) | 0, w = w + Math.imul(Q, le) | 0, g = g + Math.imul(Y, pe) | 0, o = o + Math.imul(Y, ve) | 0, o = o + Math.imul(Z, pe) | 0, w = w + Math.imul(Z, ve) | 0, g = g + Math.imul($, be) | 0, o = o + Math.imul($, ye) | 0, o = o + Math.imul(X, be) | 0, w = w + Math.imul(X, ye) | 0, g = g + Math.imul(V, me) | 0, o = o + Math.imul(V, ge) | 0, o = o + Math.imul(G, me) | 0, w = w + Math.imul(G, ge) | 0, g = g + Math.imul(W, Se) | 0, o = o + Math.imul(W, Ee) | 0, o = o + Math.imul(K, Se) | 0, w = w + Math.imul(K, Ee) | 0; var dr = (m + g | 0) + ((o & 8191) << 13) | 0; m = (w + (o >>> 13) | 0) + (dr >>> 26) | 0, dr &= 67108863, g = Math.imul(ee, de), o = Math.imul(ee, le), o = o + Math.imul(te, de) | 0, w = Math.imul(te, le), g = g + Math.imul(J, pe) | 0, o = o + Math.imul(J, ve) | 0, o = o + Math.imul(Q, pe) | 0, w = w + Math.imul(Q, ve) | 0, g = g + Math.imul(Y, be) | 0, o = o + Math.imul(Y, ye) | 0, o = o + Math.imul(Z, be) | 0, w = w + Math.imul(Z, ye) | 0, g = g + Math.imul($, me) | 0, o = o + Math.imul($, ge) | 0, o = o + Math.imul(X, me) | 0, w = w + Math.imul(X, ge) | 0, g = g + Math.imul(V, Se) | 0, o = o + Math.imul(V, Ee) | 0, o = o + Math.imul(G, Se) | 0, w = w + Math.imul(G, Ee) | 0; var lr = (m + g | 0) + ((o & 8191) << 13) | 0; m = (w + (o >>> 13) | 0) + (lr >>> 26) | 0, lr &= 67108863, g = Math.imul(ee, pe), o = Math.imul(ee, ve), o = o + Math.imul(te, pe) | 0, w = Math.imul(te, ve), g = g + Math.imul(J, be) | 0, o = o + Math.imul(J, ye) | 0, o = o + Math.imul(Q, be) | 0, w = w + Math.imul(Q, ye) | 0, g = g + Math.imul(Y, me) | 0, o = o + Math.imul(Y, ge) | 0, o = o + Math.imul(Z, me) | 0, w = w + Math.imul(Z, ge) | 0, g = g + Math.imul($, Se) | 0, o = o + Math.imul($, Ee) | 0, o = o + Math.imul(X, Se) | 0, w = w + Math.imul(X, Ee) | 0; var pr = (m + g | 0) + ((o & 8191) << 13) | 0; m = (w + (o >>> 13) | 0) + (pr >>> 26) | 0, pr &= 67108863, g = Math.imul(ee, be), o = Math.imul(ee, ye), o = o + Math.imul(te, be) | 0, w = Math.imul(te, ye), g = g + Math.imul(J, me) | 0, o = o + Math.imul(J, ge) | 0, o = o + Math.imul(Q, me) | 0, w = w + Math.imul(Q, ge) | 0, g = g + Math.imul(Y, Se) | 0, o = o + Math.imul(Y, Ee) | 0, o = o + Math.imul(Z, Se) | 0, w = w + Math.imul(Z, Ee) | 0; var Ji = (m + g | 0) + ((o & 8191) << 13) | 0; m = (w + (o >>> 13) | 0) + (Ji >>> 26) | 0, Ji &= 67108863, g = Math.imul(ee, me), o = Math.imul(ee, ge), o = o + Math.imul(te, me) | 0, w = Math.imul(te, ge), g = g + Math.imul(J, Se) | 0, o = o + Math.imul(J, Ee) | 0, o = o + Math.imul(Q, Se) | 0, w = w + Math.imul(Q, Ee) | 0; var Qi = (m + g | 0) + ((o & 8191) << 13) | 0; m = (w + (o >>> 13) | 0) + (Qi >>> 26) | 0, Qi &= 67108863, g = Math.imul(ee, Se), o = Math.imul(ee, Ee), o = o + Math.imul(te, Se) | 0, w = Math.imul(te, Ee); var en = (m + g | 0) + ((o & 8191) << 13) | 0; return m = (w + (o >>> 13) | 0) + (en >>> 26) | 0, en &= 67108863, u[0] = Qt, u[1] = er, u[2] = tr, u[3] = rr, u[4] = ir, u[5] = nr, u[6] = ar, u[7] = fr, u[8] = sr, u[9] = or, u[10] = hr, u[11] = ur, u[12] = cr, u[13] = dr, u[14] = lr, u[15] = pr, u[16] = Ji, u[17] = Qi, u[18] = en, m !== 0 && (u[19] = m, d.length++), d }; Math.imul || (F = H); function we(l, a, s) { s.negative = a.negative ^ l.negative, s.length = l.length + a.length; for (var d = 0, v = 0, p = 0; p < s.length - 1; p++) { var u = v; v = 0; for (var m = d & 67108863, g = Math.min(p, a.length - 1), o = Math.max(0, p - l.length + 1); o <= g; o++) { var w = p - o, R = l.words[w] | 0, k = a.words[o] | 0, q = R * k, O = q & 67108863; u = u + (q / 67108864 | 0) | 0, O = O + m | 0, m = O & 67108863, u = u + (O >>> 26) | 0, v += u >>> 26, u &= 67108863 } s.words[p] = m, d = u, u = v } return d !== 0 ? s.words[p] = d : s.length--, s._strip() } function Be(l, a, s) { return we(l, a, s) } n.prototype.mulTo = function (a, s) { var d, v = this.length + a.length; return this.length === 10 && a.length === 10 ? d = F(this, a, s) : v < 63 ? d = H(this, a, s) : v < 1024 ? d = we(this, a, s) : d = Be(this, a, s), d }; function xe(l, a) { this.x = l, this.y = a } xe.prototype.makeRBT = function (a) { for (var s = new Array(a), d = n.prototype._countBits(a) - 1, v = 0; v < a; v++)s[v] = this.revBin(v, d, a); return s }, xe.prototype.revBin = function (a, s, d) { if (a === 0 || a === d - 1) return a; for (var v = 0, p = 0; p < s; p++)v |= (a & 1) << s - p - 1, a >>= 1; return v }, xe.prototype.permute = function (a, s, d, v, p, u) { for (var m = 0; m < u; m++)v[m] = s[a[m]], p[m] = d[a[m]] }, xe.prototype.transform = function (a, s, d, v, p, u) { this.permute(u, a, s, d, v, p); for (var m = 1; m < p; m <<= 1)for (var g = m << 1, o = Math.cos(2 * Math.PI / g), w = Math.sin(2 * Math.PI / g), R = 0; R < p; R += g)for (var k = o, q = w, O = 0; O < m; O++) { var D = d[R + O], U = v[R + O], Qe = d[R + O + m], N = v[R + O + m], L = k * Qe - q * N; N = k * N + q * Qe, Qe = L, d[R + O] = D + Qe, v[R + O] = U + N, d[R + O + m] = D - Qe, v[R + O + m] = U - N, O !== g && (L = o * k - w * q, q = o * q + w * k, k = L) } }, xe.prototype.guessLen13b = function (a, s) { var d = Math.max(s, a) | 1, v = d & 1, p = 0; for (d = d / 2 | 0; d; d = d >>> 1)p++; return 1 << p + 1 + v }, xe.prototype.conjugate = function (a, s, d) { if (!(d <= 1)) for (var v = 0; v < d / 2; v++) { var p = a[v]; a[v] = a[d - v - 1], a[d - v - 1] = p, p = s[v], s[v] = -s[d - v - 1], s[d - v - 1] = -p } }, xe.prototype.normalize13b = function (a, s) { for (var d = 0, v = 0; v < s / 2; v++) { var p = Math.round(a[2 * v + 1] / s) * 8192 + Math.round(a[2 * v] / s) + d; a[v] = p & 67108863, p < 67108864 ? d = 0 : d = p / 67108864 | 0 } return a }, xe.prototype.convert13b = function (a, s, d, v) { for (var p = 0, u = 0; u < s; u++)p = p + (a[u] | 0), d[2 * u] = p & 8191, p = p >>> 13, d[2 * u + 1] = p & 8191, p = p >>> 13; for (u = 2 * s; u < v; ++u)d[u] = 0; r(p === 0), r((p & ~8191) == 0) }, xe.prototype.stub = function (a) { for (var s = new Array(a), d = 0; d < a; d++)s[d] = 0; return s }, xe.prototype.mulp = function (a, s, d) { var v = 2 * this.guessLen13b(a.length, s.length), p = this.makeRBT(v), u = this.stub(v), m = new Array(v), g = new Array(v), o = new Array(v), w = new Array(v), R = new Array(v), k = new Array(v), q = d.words; q.length = v, this.convert13b(a.words, a.length, m, v), this.convert13b(s.words, s.length, w, v), this.transform(m, u, g, o, v, p), this.transform(w, u, R, k, v, p); for (var O = 0; O < v; O++) { var D = g[O] * R[O] - o[O] * k[O]; o[O] = g[O] * k[O] + o[O] * R[O], g[O] = D } return this.conjugate(g, o, v), this.transform(g, o, q, u, v, p), this.conjugate(q, u, v), this.normalize13b(q, v), d.negative = a.negative ^ s.negative, d.length = a.length + s.length, d._strip() }, n.prototype.mul = function (a) { var s = new n(null); return s.words = new Array(this.length + a.length), this.mulTo(a, s) }, n.prototype.mulf = function (a) { var s = new n(null); return s.words = new Array(this.length + a.length), Be(this, a, s) }, n.prototype.imul = function (a) { return this.clone().mulTo(a, this) }, n.prototype.imuln = function (a) { var s = a < 0; s && (a = -a), r(typeof a == "number"), r(a < 67108864); for (var d = 0, v = 0; v < this.length; v++) { var p = (this.words[v] | 0) * a, u = (p & 67108863) + (d & 67108863); d >>= 26, d += p / 67108864 | 0, d += u >>> 26, this.words[v] = u & 67108863 } return d !== 0 && (this.words[v] = d, this.length++), s ? this.ineg() : this }, n.prototype.muln = function (a) { return this.clone().imuln(a) }, n.prototype.sqr = function () { return this.mul(this) }, n.prototype.isqr = function () { return this.imul(this.clone()) }, n.prototype.pow = function (a) { var s = C(a); if (s.length === 0) return new n(1); for (var d = this, v = 0; v < s.length && s[v] === 0; v++, d = d.sqr()); if (++v < s.length) for (var p = d.sqr(); v < s.length; v++, p = p.sqr())s[v] !== 0 && (d = d.mul(p)); return d }, n.prototype.iushln = function (a) { r(typeof a == "number" && a >= 0); var s = a % 26, d = (a - s) / 26, v = 67108863 >>> 26 - s << 26 - s, p; if (s !== 0) { var u = 0; for (p = 0; p < this.length; p++) { var m = this.words[p] & v, g = (this.words[p] | 0) - m << s; this.words[p] = g | u, u = m >>> 26 - s } u && (this.words[p] = u, this.length++) } if (d !== 0) { for (p = this.length - 1; p >= 0; p--)this.words[p + d] = this.words[p]; for (p = 0; p < d; p++)this.words[p] = 0; this.length += d } return this._strip() }, n.prototype.ishln = function (a) { return r(this.negative === 0), this.iushln(a) }, n.prototype.iushrn = function (a, s, d) { r(typeof a == "number" && a >= 0); var v; s ? v = (s - s % 26) / 26 : v = 0; var p = a % 26, u = Math.min((a - p) / 26, this.length), m = 67108863 ^ 67108863 >>> p << p, g = d; if (v -= u, v = Math.max(0, v), g) { for (var o = 0; o < u; o++)g.words[o] = this.words[o]; g.length = u } if (u !== 0) if (this.length > u) for (this.length -= u, o = 0; o < this.length; o++)this.words[o] = this.words[o + u]; else this.words[0] = 0, this.length = 1; var w = 0; for (o = this.length - 1; o >= 0 && (w !== 0 || o >= v); o--) { var R = this.words[o] | 0; this.words[o] = w << 26 - p | R >>> p, w = R & m } return g && w !== 0 && (g.words[g.length++] = w), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip() }, n.prototype.ishrn = function (a, s, d) { return r(this.negative === 0), this.iushrn(a, s, d) }, n.prototype.shln = function (a) { return this.clone().ishln(a) }, n.prototype.ushln = function (a) { return this.clone().iushln(a) }, n.prototype.shrn = function (a) { return this.clone().ishrn(a) }, n.prototype.ushrn = function (a) { return this.clone().iushrn(a) }, n.prototype.testn = function (a) { r(typeof a == "number" && a >= 0); var s = a % 26, d = (a - s) / 26, v = 1 << s; if (this.length <= d) return !1; var p = this.words[d]; return !!(p & v) }, n.prototype.imaskn = function (a) { r(typeof a == "number" && a >= 0); var s = a % 26, d = (a - s) / 26; if (r(this.negative === 0, "imaskn works only with positive numbers"), this.length <= d) return this; if (s !== 0 && d++, this.length = Math.min(d, this.length), s !== 0) { var v = 67108863 ^ 67108863 >>> s << s; this.words[this.length - 1] &= v } return this._strip() }, n.prototype.maskn = function (a) { return this.clone().imaskn(a) }, n.prototype.iaddn = function (a) { return r(typeof a == "number"), r(a < 67108864), a < 0 ? this.isubn(-a) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= a ? (this.words[0] = a - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(a), this.negative = 1, this) : this._iaddn(a) }, n.prototype._iaddn = function (a) { this.words[0] += a; for (var s = 0; s < this.length && this.words[s] >= 67108864; s++)this.words[s] -= 67108864, s === this.length - 1 ? this.words[s + 1] = 1 : this.words[s + 1]++; return this.length = Math.max(this.length, s + 1), this }, n.prototype.isubn = function (a) { if (r(typeof a == "number"), r(a < 67108864), a < 0) return this.iaddn(-a); if (this.negative !== 0) return this.negative = 0, this.iaddn(a), this.negative = 1, this; if (this.words[0] -= a, this.length === 1 && this.words[0] < 0) this.words[0] = -this.words[0], this.negative = 1; else for (var s = 0; s < this.length && this.words[s] < 0; s++)this.words[s] += 67108864, this.words[s + 1] -= 1; return this._strip() }, n.prototype.addn = function (a) { return this.clone().iaddn(a) }, n.prototype.subn = function (a) { return this.clone().isubn(a) }, n.prototype.iabs = function () { return this.negative = 0, this }, n.prototype.abs = function () { return this.clone().iabs() }, n.prototype._ishlnsubmul = function (a, s, d) { var v = a.length + d, p; this._expand(v); var u, m = 0; for (p = 0; p < a.length; p++) { u = (this.words[p + d] | 0) + m; var g = (a.words[p] | 0) * s; u -= g & 67108863, m = (u >> 26) - (g / 67108864 | 0), this.words[p + d] = u & 67108863 } for (; p < this.length - d; p++)u = (this.words[p + d] | 0) + m, m = u >> 26, this.words[p + d] = u & 67108863; if (m === 0) return this._strip(); for (r(m === -1), m = 0, p = 0; p < this.length; p++)u = -(this.words[p] | 0) + m, m = u >> 26, this.words[p] = u & 67108863; return this.negative = 1, this._strip() }, n.prototype._wordDiv = function (a, s) { var d = this.length - a.length, v = this.clone(), p = a, u = p.words[p.length - 1] | 0, m = this._countBits(u); d = 26 - m, d !== 0 && (p = p.ushln(d), v.iushln(d), u = p.words[p.length - 1] | 0); var g = v.length - p.length, o; if (s !== "mod") { o = new n(null), o.length = g + 1, o.words = new Array(o.length); for (var w = 0; w < o.length; w++)o.words[w] = 0 } var R = v.clone()._ishlnsubmul(p, 1, g); R.negative === 0 && (v = R, o && (o.words[g] = 1)); for (var k = g - 1; k >= 0; k--) { var q = (v.words[p.length + k] | 0) * 67108864 + (v.words[p.length + k - 1] | 0); for (q = Math.min(q / u | 0, 67108863), v._ishlnsubmul(p, q, k); v.negative !== 0;)q--, v.negative = 0, v._ishlnsubmul(p, 1, k), v.isZero() || (v.negative ^= 1); o && (o.words[k] = q) } return o && o._strip(), v._strip(), s !== "div" && d !== 0 && v.iushrn(d), { div: o || null, mod: v } }, n.prototype.divmod = function (a, s, d) { if (r(!a.isZero()), this.isZero()) return { div: new n(0), mod: new n(0) }; var v, p, u; return this.negative !== 0 && a.negative === 0 ? (u = this.neg().divmod(a, s), s !== "mod" && (v = u.div.neg()), s !== "div" && (p = u.mod.neg(), d && p.negative !== 0 && p.iadd(a)), { div: v, mod: p }) : this.negative === 0 && a.negative !== 0 ? (u = this.divmod(a.neg(), s), s !== "mod" && (v = u.div.neg()), { div: v, mod: u.mod }) : (this.negative & a.negative) != 0 ? (u = this.neg().divmod(a.neg(), s), s !== "div" && (p = u.mod.neg(), d && p.negative !== 0 && p.isub(a)), { div: u.div, mod: p }) : a.length > this.length || this.cmp(a) < 0 ? { div: new n(0), mod: this } : a.length === 1 ? s === "div" ? { div: this.divn(a.words[0]), mod: null } : s === "mod" ? { div: null, mod: new n(this.modrn(a.words[0])) } : { div: this.divn(a.words[0]), mod: new n(this.modrn(a.words[0])) } : this._wordDiv(a, s) }, n.prototype.div = function (a) { return this.divmod(a, "div", !1).div }, n.prototype.mod = function (a) { return this.divmod(a, "mod", !1).mod }, n.prototype.umod = function (a) { return this.divmod(a, "mod", !0).mod }, n.prototype.divRound = function (a) { var s = this.divmod(a); if (s.mod.isZero()) return s.div; var d = s.div.negative !== 0 ? s.mod.isub(a) : s.mod, v = a.ushrn(1), p = a.andln(1), u = d.cmp(v); return u < 0 || p === 1 && u === 0 ? s.div : s.div.negative !== 0 ? s.div.isubn(1) : s.div.iaddn(1) }, n.prototype.modrn = function (a) { var s = a < 0; s && (a = -a), r(a <= 67108863); for (var d = (1 << 26) % a, v = 0, p = this.length - 1; p >= 0; p--)v = (d * v + (this.words[p] | 0)) % a; return s ? -v : v }, n.prototype.modn = function (a) { return this.modrn(a) }, n.prototype.idivn = function (a) { var s = a < 0; s && (a = -a), r(a <= 67108863); for (var d = 0, v = this.length - 1; v >= 0; v--) { var p = (this.words[v] | 0) + d * 67108864; this.words[v] = p / a | 0, d = p % a } return this._strip(), s ? this.ineg() : this }, n.prototype.divn = function (a) { return this.clone().idivn(a) }, n.prototype.egcd = function (a) { r(a.negative === 0), r(!a.isZero()); var s = this, d = a.clone(); s.negative !== 0 ? s = s.umod(a) : s = s.clone(); for (var v = new n(1), p = new n(0), u = new n(0), m = new n(1), g = 0; s.isEven() && d.isEven();)s.iushrn(1), d.iushrn(1), ++g; for (var o = d.clone(), w = s.clone(); !s.isZero();) { for (var R = 0, k = 1; (s.words[0] & k) == 0 && R < 26; ++R, k <<= 1); if (R > 0) for (s.iushrn(R); R-- > 0;)(v.isOdd() || p.isOdd()) && (v.iadd(o), p.isub(w)), v.iushrn(1), p.iushrn(1); for (var q = 0, O = 1; (d.words[0] & O) == 0 && q < 26; ++q, O <<= 1); if (q > 0) for (d.iushrn(q); q-- > 0;)(u.isOdd() || m.isOdd()) && (u.iadd(o), m.isub(w)), u.iushrn(1), m.iushrn(1); s.cmp(d) >= 0 ? (s.isub(d), v.isub(u), p.isub(m)) : (d.isub(s), u.isub(v), m.isub(p)) } return { a: u, b: m, gcd: d.iushln(g) } }, n.prototype._invmp = function (a) { r(a.negative === 0), r(!a.isZero()); var s = this, d = a.clone(); s.negative !== 0 ? s = s.umod(a) : s = s.clone(); for (var v = new n(1), p = new n(0), u = d.clone(); s.cmpn(1) > 0 && d.cmpn(1) > 0;) { for (var m = 0, g = 1; (s.words[0] & g) == 0 && m < 26; ++m, g <<= 1); if (m > 0) for (s.iushrn(m); m-- > 0;)v.isOdd() && v.iadd(u), v.iushrn(1); for (var o = 0, w = 1; (d.words[0] & w) == 0 && o < 26; ++o, w <<= 1); if (o > 0) for (d.iushrn(o); o-- > 0;)p.isOdd() && p.iadd(u), p.iushrn(1); s.cmp(d) >= 0 ? (s.isub(d), v.isub(p)) : (d.isub(s), p.isub(v)) } var R; return s.cmpn(1) === 0 ? R = v : R = p, R.cmpn(0) < 0 && R.iadd(a), R }, n.prototype.gcd = function (a) { if (this.isZero()) return a.abs(); if (a.isZero()) return this.abs(); var s = this.clone(), d = a.clone(); s.negative = 0, d.negative = 0; for (var v = 0; s.isEven() && d.isEven(); v++)s.iushrn(1), d.iushrn(1); do { for (; s.isEven();)s.iushrn(1); for (; d.isEven();)d.iushrn(1); var p = s.cmp(d); if (p < 0) { var u = s; s = d, d = u } else if (p === 0 || d.cmpn(1) === 0) break; s.isub(d) } while (!0); return d.iushln(v) }, n.prototype.invm = function (a) { return this.egcd(a).a.umod(a) }, n.prototype.isEven = function () { return (this.words[0] & 1) == 0 }, n.prototype.isOdd = function () { return (this.words[0] & 1) == 1 }, n.prototype.andln = function (a) { return this.words[0] & a }, n.prototype.bincn = function (a) { r(typeof a == "number"); var s = a % 26, d = (a - s) / 26, v = 1 << s; if (this.length <= d) return this._expand(d + 1), this.words[d] |= v, this; for (var p = v, u = d; p !== 0 && u < this.length; u++) { var m = this.words[u] | 0; m += p, p = m >>> 26, m &= 67108863, this.words[u] = m } return p !== 0 && (this.words[u] = p, this.length++), this }, n.prototype.isZero = function () { return this.length === 1 && this.words[0] === 0 }, n.prototype.cmpn = function (a) { var s = a < 0; if (this.negative !== 0 && !s) return -1; if (this.negative === 0 && s) return 1; this._strip(); var d; if (this.length > 1) d = 1; else { s && (a = -a), r(a <= 67108863, "Number is too big"); var v = this.words[0] | 0; d = v === a ? 0 : v < a ? -1 : 1 } return this.negative !== 0 ? -d | 0 : d }, n.prototype.cmp = function (a) { if (this.negative !== 0 && a.negative === 0) return -1; if (this.negative === 0 && a.negative !== 0) return 1; var s = this.ucmp(a); return this.negative !== 0 ? -s | 0 : s }, n.prototype.ucmp = function (a) { if (this.length > a.length) return 1; if (this.length < a.length) return -1; for (var s = 0, d = this.length - 1; d >= 0; d--) { var v = this.words[d] | 0, p = a.words[d] | 0; if (v !== p) { v < p ? s = -1 : v > p && (s = 1); break } } return s }, n.prototype.gtn = function (a) { return this.cmpn(a) === 1 }, n.prototype.gt = function (a) { return this.cmp(a) === 1 }, n.prototype.gten = function (a) { return this.cmpn(a) >= 0 }, n.prototype.gte = function (a) { return this.cmp(a) >= 0 }, n.prototype.ltn = function (a) { return this.cmpn(a) === -1 }, n.prototype.lt = function (a) { return this.cmp(a) === -1 }, n.prototype.lten = function (a) { return this.cmpn(a) <= 0 }, n.prototype.lte = function (a) { return this.cmp(a) <= 0 }, n.prototype.eqn = function (a) { return this.cmpn(a) === 0 }, n.prototype.eq = function (a) { return this.cmp(a) === 0 }, n.red = function (a) { return new b(a) }, n.prototype.toRed = function (a) { return r(!this.red, "Already a number in reduction context"), r(this.negative === 0, "red works only with positives"), a.convertTo(this)._forceRed(a) }, n.prototype.fromRed = function () { return r(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this) }, n.prototype._forceRed = function (a) { return this.red = a, this }, n.prototype.forceRed = function (a) { return r(!this.red, "Already a number in reduction context"), this._forceRed(a) }, n.prototype.redAdd = function (a) { return r(this.red, "redAdd works only with red numbers"), this.red.add(this, a) }, n.prototype.redIAdd = function (a) { return r(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, a) }, n.prototype.redSub = function (a) { return r(this.red, "redSub works only with red numbers"), this.red.sub(this, a) }, n.prototype.redISub = function (a) { return r(this.red, "redISub works only with red numbers"), this.red.isub(this, a) }, n.prototype.redShl = function (a) { return r(this.red, "redShl works only with red numbers"), this.red.shl(this, a) }, n.prototype.redMul = function (a) { return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, a), this.red.mul(this, a) }, n.prototype.redIMul = function (a) { return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, a), this.red.imul(this, a) }, n.prototype.redSqr = function () { return r(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this) }, n.prototype.redISqr = function () { return r(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this) }, n.prototype.redSqrt = function () { return r(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this) }, n.prototype.redInvm = function () { return r(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this) }, n.prototype.redNeg = function () { return r(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this) }, n.prototype.redPow = function (a) { return r(this.red && !a.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, a) }; var Le = { k256: null, p224: null, p192: null, p25519: null }; function Me(l, a) { this.name = l, this.p = new n(a, 16), this.n = this.p.bitLength(), this.k = new n(1).iushln(this.n).isub(this.p), this.tmp = this._tmp() } Me.prototype._tmp = function () { var a = new n(null); return a.words = new Array(Math.ceil(this.n / 13)), a }, Me.prototype.ireduce = function (a) { var s = a, d; do this.split(s, this.tmp), s = this.imulK(s), s = s.iadd(this.tmp), d = s.bitLength(); while (d > this.n); var v = d < this.n ? -1 : s.ucmp(this.p); return v === 0 ? (s.words[0] = 0, s.length = 1) : v > 0 ? s.isub(this.p) : s.strip !== void 0 ? s.strip() : s._strip(), s }, Me.prototype.split = function (a, s) { a.iushrn(this.n, 0, s) }, Me.prototype.imulK = function (a) { return a.imul(this.k) }; function De() { Me.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f") } i(De, Me), De.prototype.split = function (a, s) { for (var d = 4194303, v = Math.min(a.length, 9), p = 0; p < v; p++)s.words[p] = a.words[p]; if (s.length = v, a.length <= 9) { a.words[0] = 0, a.length = 1; return } var u = a.words[9]; for (s.words[s.length++] = u & d, p = 10; p < a.length; p++) { var m = a.words[p] | 0; a.words[p - 10] = (m & d) << 4 | u >>> 22, u = m } u >>>= 22, a.words[p - 10] = u, u === 0 && a.length > 10 ? a.length -= 10 : a.length -= 9 }, De.prototype.imulK = function (a) { a.words[a.length] = 0, a.words[a.length + 1] = 0, a.length += 2; for (var s = 0, d = 0; d < a.length; d++) { var v = a.words[d] | 0; s += v * 977, a.words[d] = s & 67108863, s = v * 64 + (s / 67108864 | 0) } return a.words[a.length - 1] === 0 && (a.length--, a.words[a.length - 1] === 0 && a.length--), a }; function Ie() { Me.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001") } i(Ie, Me); function je() { Me.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff") } i(je, Me); function S() { Me.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed") } i(S, Me), S.prototype.imulK = function (a) { for (var s = 0, d = 0; d < a.length; d++) { var v = (a.words[d] | 0) * 19 + s, p = v & 67108863; v >>>= 26, a.words[d] = p, s = v } return s !== 0 && (a.words[a.length++] = s), a }, n._prime = function (a) { if (Le[a]) return Le[a]; var s; if (a === "k256") s = new De; else if (a === "p224") s = new Ie; else if (a === "p192") s = new je; else if (a === "p25519") s = new S; else throw new Error("Unknown prime " + a); return Le[a] = s, s }; function b(l) { if (typeof l == "string") { var a = n._prime(l); this.m = a.p, this.prime = a } else r(l.gtn(1), "modulus must be greater than 1"), this.m = l, this.prime = null } b.prototype._verify1 = function (a) { r(a.negative === 0, "red works only with positives"), r(a.red, "red works only with red numbers") }, b.prototype._verify2 = function (a, s) { r((a.negative | s.negative) == 0, "red works only with positives"), r(a.red && a.red === s.red, "red works only with red numbers") }, b.prototype.imod = function (a) { return this.prime ? this.prime.ireduce(a)._forceRed(this) : (x(a, a.umod(this.m)._forceRed(this)), a) }, b.prototype.neg = function (a) { return a.isZero() ? a.clone() : this.m.sub(a)._forceRed(this) }, b.prototype.add = function (a, s) { this._verify2(a, s); var d = a.add(s); return d.cmp(this.m) >= 0 && d.isub(this.m), d._forceRed(this) }, b.prototype.iadd = function (a, s) { this._verify2(a, s); var d = a.iadd(s); return d.cmp(this.m) >= 0 && d.isub(this.m), d }, b.prototype.sub = function (a, s) { this._verify2(a, s); var d = a.sub(s); return d.cmpn(0) < 0 && d.iadd(this.m), d._forceRed(this) }, b.prototype.isub = function (a, s) { this._verify2(a, s); var d = a.isub(s); return d.cmpn(0) < 0 && d.iadd(this.m), d }, b.prototype.shl = function (a, s) { return this._verify1(a), this.imod(a.ushln(s)) }, b.prototype.imul = function (a, s) { return this._verify2(a, s), this.imod(a.imul(s)) }, b.prototype.mul = function (a, s) { return this._verify2(a, s), this.imod(a.mul(s)) }, b.prototype.isqr = function (a) { return this.imul(a, a.clone()) }, b.prototype.sqr = function (a) { return this.mul(a, a) }, b.prototype.sqrt = function (a) { if (a.isZero()) return a.clone(); var s = this.m.andln(3); if (r(s % 2 == 1), s === 3) { var d = this.m.add(new n(1)).iushrn(2); return this.pow(a, d) } for (var v = this.m.subn(1), p = 0; !v.isZero() && v.andln(1) === 0;)p++, v.iushrn(1); r(!v.isZero()); var u = new n(1).toRed(this), m = u.redNeg(), g = this.m.subn(1).iushrn(1), o = this.m.bitLength(); for (o = new n(2 * o * o).toRed(this); this.pow(o, g).cmp(m) !== 0;)o.redIAdd(m); for (var w = this.pow(o, v), R = this.pow(a, v.addn(1).iushrn(1)), k = this.pow(a, v), q = p; k.cmp(u) !== 0;) { for (var O = k, D = 0; O.cmp(u) !== 0; D++)O = O.redSqr(); r(D < q); var U = this.pow(w, new n(1).iushln(q - D - 1)); R = R.redMul(U), w = U.redSqr(), k = k.redMul(w), q = D } return R }, b.prototype.invm = function (a) { var s = a._invmp(this.m); return s.negative !== 0 ? (s.negative = 0, this.imod(s).redNeg()) : this.imod(s) }, b.prototype.pow = function (a, s) { if (s.isZero()) return new n(1).toRed(this); if (s.cmpn(1) === 0) return a.clone(); var d = 4, v = new Array(1 << d); v[0] = new n(1).toRed(this), v[1] = a; for (var p = 2; p < v.length; p++)v[p] = this.mul(v[p - 1], a); var u = v[0], m = 0, g = 0, o = s.bitLength() % 26; for (o === 0 && (o = 26), p = s.length - 1; p >= 0; p--) { for (var w = s.words[p], R = o - 1; R >= 0; R--) { var k = w >> R & 1; if (u !== v[0] && (u = this.sqr(u)), k === 0 && m === 0) { g = 0; continue } m <<= 1, m |= k, g++, !(g !== d && (p !== 0 || R !== 0)) && (u = this.mul(u, v[m]), g = 0, m = 0) } o = 26 } return u }, b.prototype.convertTo = function (a) { var s = a.umod(this.m); return s === a ? s.clone() : s }, b.prototype.convertFrom = function (a) { var s = a.clone(); return s.red = null, s }, n.mont = function (a) { return new _(a) }; function _(l) { b.call(this, l), this.shift = this.m.bitLength(), this.shift % 26 != 0 && (this.shift += 26 - this.shift % 26), this.r = new n(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv) } i(_, b), _.prototype.convertTo = function (a) { return this.imod(a.ushln(this.shift)) }, _.prototype.convertFrom = function (a) { var s = this.imod(a.mul(this.rinv)); return s.red = null, s }, _.prototype.imul = function (a, s) { if (a.isZero() || s.isZero()) return a.words[0] = 0, a.length = 1, a; var d = a.imul(s), v = d.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), p = d.isub(v).iushrn(this.shift), u = p; return p.cmp(this.m) >= 0 ? u = p.isub(this.m) : p.cmpn(0) < 0 && (u = p.iadd(this.m)), u._forceRed(this) }, _.prototype.mul = function (a, s) { if (a.isZero() || s.isZero()) return new n(0)._forceRed(this); var d = a.mul(s), v = d.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), p = d.isub(v).iushrn(this.shift), u = p; return p.cmp(this.m) >= 0 ? u = p.isub(this.m) : p.cmpn(0) < 0 && (u = p.iadd(this.m)), u._forceRed(this) }, _.prototype.invm = function (a) { var s = this.imod(a._invmp(this.m).mul(this.r2)); return s._forceRed(this) } })(typeof yu == "undefined" || yu, pb) }); var Mo = I((iB, vb) => { "use strict"; var xo = ct(), va = xo.Buffer, Kt = {}, Vt; for (Vt in xo) !xo.hasOwnProperty(Vt) || Vt === "SlowBuffer" || Vt === "Buffer" || (Kt[Vt] = xo[Vt]); var ba = Kt.Buffer = {}; for (Vt in va) !va.hasOwnProperty(Vt) || Vt === "allocUnsafe" || Vt === "allocUnsafeSlow" || (ba[Vt] = va[Vt]); Kt.Buffer.prototype = va.prototype; (!ba.from || ba.from === Uint8Array.from) && (ba.from = function (t, e, r) { if (typeof t == "number") throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof t); if (t && typeof t.length == "undefined") throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof t); return va(t, e, r) }); ba.alloc || (ba.alloc = function (t, e, r) { if (typeof t != "number") throw new TypeError('The "size" argument must be of type number. Received type ' + typeof t); if (t < 0 || t >= 2 * (1 << 30)) throw new RangeError('The value "' + t + '" is invalid for option "size"'); var i = va(t); return !e || e.length === 0 ? i.fill(0) : typeof r == "string" ? i.fill(e, r) : i.fill(e), i }); if (!Kt.kStringMaxLength) try { Kt.kStringMaxLength = process.binding("buffer").kStringMaxLength } catch (t) { } Kt.constants || (Kt.constants = { MAX_LENGTH: Kt.kMaxLength }, Kt.kStringMaxLength && (Kt.constants.MAX_STRING_LENGTH = Kt.kStringMaxLength)); vb.exports = Kt }); var So = I(bb => { "use strict"; var p9 = Re(); function Gt(t) { this._reporterState = { obj: null, path: [], options: t || {}, errors: [] } } bb.Reporter = Gt; Gt.prototype.isError = function (e) { return e instanceof ya }; Gt.prototype.save = function () { let e = this._reporterState; return { obj: e.obj, pathLen: e.path.length } }; Gt.prototype.restore = function (e) { let r = this._reporterState; r.obj = e.obj, r.path = r.path.slice(0, e.pathLen) }; Gt.prototype.enterKey = function (e) { return this._reporterState.path.push(e) }; Gt.prototype.exitKey = function (e) { let r = this._reporterState; r.path = r.path.slice(0, e - 1) }; Gt.prototype.leaveKey = function (e, r, i) { let n = this._reporterState; this.exitKey(e), n.obj !== null && (n.obj[r] = i) }; Gt.prototype.path = function () { return this._reporterState.path.join("/") }; Gt.prototype.enterObject = function () { let e = this._reporterState, r = e.obj; return e.obj = {}, r }; Gt.prototype.leaveObject = function (e) { let r = this._reporterState, i = r.obj; return r.obj = e, i }; Gt.prototype.error = function (e) { let r, i = this._reporterState, n = e instanceof ya; if (n ? r = e : r = new ya(i.path.map(function (f) { return "[" + JSON.stringify(f) + "]" }).join(""), e.message || e, e.stack), !i.options.partial) throw r; return n || i.errors.push(r), r }; Gt.prototype.wrapResult = function (e) { let r = this._reporterState; return r.options.partial ? { result: this.isError(e) ? null : e, errors: r.errors } : e }; function ya(t, e) { this.path = t, this.rethrow(e) } p9(ya, Error); ya.prototype.rethrow = function (e) { if (this.message = e + " at: " + (this.path || "(shallow)"), Error.captureStackTrace && Error.captureStackTrace(this, ya), !this.stack) try { throw new Error(this.message) } catch (r) { this.stack = r.stack } return this } }); var wa = I(gu => { "use strict"; var v9 = Re(), Eo = So().Reporter, ma = Mo().Buffer; function $t(t, e) { if (Eo.call(this, e), !ma.isBuffer(t)) { this.error("Input not Buffer"); return } this.base = t, this.offset = 0, this.length = t.length } v9($t, Eo); gu.DecoderBuffer = $t; $t.isDecoderBuffer = function (e) { return e instanceof $t ? !0 : typeof e == "object" && ma.isBuffer(e.base) && e.constructor.name === "DecoderBuffer" && typeof e.offset == "number" && typeof e.length == "number" && typeof e.save == "function" && typeof e.restore == "function" && typeof e.isEmpty == "function" && typeof e.readUInt8 == "function" && typeof e.skip == "function" && typeof e.raw == "function" }; $t.prototype.save = function () { return { offset: this.offset, reporter: Eo.prototype.save.call(this) } }; $t.prototype.restore = function (e) { let r = new $t(this.base); return r.offset = e.offset, r.length = this.offset, this.offset = e.offset, Eo.prototype.restore.call(this, e.reporter), r }; $t.prototype.isEmpty = function () { return this.offset === this.length }; $t.prototype.readUInt8 = function (e) { return this.offset + 1 <= this.length ? this.base.readUInt8(this.offset++, !0) : this.error(e || "DecoderBuffer overrun") }; $t.prototype.skip = function (e, r) { if (!(this.offset + e <= this.length)) return this.error(r || "DecoderBuffer overrun"); let i = new $t(this.base); return i._reporterState = this._reporterState, i.offset = this.offset, i.length = this.offset + e, this.offset += e, i }; $t.prototype.raw = function (e) { return this.base.slice(e ? e.offset : this.offset, this.length) }; function ga(t, e) { if (Array.isArray(t)) this.length = 0, this.value = t.map(function (r) { return ga.isEncoderBuffer(r) || (r = new ga(r, e)), this.length += r.length, r }, this); else if (typeof t == "number") { if (!(0 <= t && t <= 255)) return e.error("non-byte EncoderBuffer value"); this.value = t, this.length = 1 } else if (typeof t == "string") this.value = t, this.length = ma.byteLength(t); else if (ma.isBuffer(t)) this.value = t, this.length = t.length; else return e.error("Unsupported type: " + typeof t) } gu.EncoderBuffer = ga; ga.isEncoderBuffer = function (e) { return e instanceof ga ? !0 : typeof e == "object" && e.constructor.name === "EncoderBuffer" && typeof e.length == "number" && typeof e.join == "function" }; ga.prototype.join = function (e, r) { return e || (e = ma.alloc(this.length)), r || (r = 0), this.length === 0 || (Array.isArray(this.value) ? this.value.forEach(function (i) { i.join(e, r), r += i.length }) : (typeof this.value == "number" ? e[r] = this.value : typeof this.value == "string" ? e.write(this.value, r) : ma.isBuffer(this.value) && this.value.copy(e, r), r += this.length)), e } }); var Ao = I((fB, mb) => { "use strict"; var b9 = So().Reporter, y9 = wa().EncoderBuffer, m9 = wa().DecoderBuffer, _t = Tt(), yb = ["seq", "seqof", "set", "setof", "objid", "bool", "gentime", "utctime", "null_", "enum", "int", "objDesc", "bitstr", "bmpstr", "charstr", "genstr", "graphstr", "ia5str", "iso646str", "numstr", "octstr", "printstr", "t61str", "unistr", "utf8str", "videostr"], g9 = ["key", "obj", "use", "optional", "explicit", "implicit", "def", "choice", "any", "contains"].concat(yb), w9 = ["_peekTag", "_decodeTag", "_use", "_decodeStr", "_decodeObjid", "_decodeTime", "_decodeNull", "_decodeInt", "_decodeBool", "_decodeList", "_encodeComposite", "_encodeStr", "_encodeObjid", "_encodeTime", "_encodeNull", "_encodeInt", "_encodeBool"]; function We(t, e, r) { let i = {}; this._baseState = i, i.name = r, i.enc = t, i.parent = e || null, i.children = null, i.tag = null, i.args = null, i.reverseArgs = null, i.choice = null, i.optional = !1, i.any = !1, i.obj = !1, i.use = null, i.useDecoder = null, i.key = null, i.default = null, i.explicit = null, i.implicit = null, i.contains = null, i.parent || (i.children = [], this._wrap()) } mb.exports = We; var _9 = ["enc", "parent", "children", "tag", "args", "reverseArgs", "choice", "optional", "any", "obj", "use", "alteredUse", "key", "default", "explicit", "implicit", "contains"]; We.prototype.clone = function () { let e = this._baseState, r = {}; _9.forEach(function (n) { r[n] = e[n] }); let i = new this.constructor(r.parent); return i._baseState = r, i }; We.prototype._wrap = function () { let e = this._baseState; g9.forEach(function (r) { this[r] = function () { let n = new this.constructor(this); return e.children.push(n), n[r].apply(n, arguments) } }, this) }; We.prototype._init = function (e) { let r = this._baseState; _t(r.parent === null), e.call(this), r.children = r.children.filter(function (i) { return i._baseState.parent === this }, this), _t.equal(r.children.length, 1, "Root node can have only one child") }; We.prototype._useArgs = function (e) { let r = this._baseState, i = e.filter(function (n) { return n instanceof this.constructor }, this); e = e.filter(function (n) { return !(n instanceof this.constructor) }, this), i.length !== 0 && (_t(r.children === null), r.children = i, i.forEach(function (n) { n._baseState.parent = this }, this)), e.length !== 0 && (_t(r.args === null), r.args = e, r.reverseArgs = e.map(function (n) { if (typeof n != "object" || n.constructor !== Object) return n; let f = {}; return Object.keys(n).forEach(function (h) { h == (h | 0) && (h |= 0); let c = n[h]; f[c] = h }), f })) }; w9.forEach(function (t) { We.prototype[t] = function () { let r = this._baseState; throw new Error(t + " not implemented for encoding: " + r.enc) } }); yb.forEach(function (t) { We.prototype[t] = function () { let r = this._baseState, i = Array.prototype.slice.call(arguments); return _t(r.tag === null), r.tag = t, this._useArgs(i), this } }); We.prototype.use = function (e) { _t(e); let r = this._baseState; return _t(r.use === null), r.use = e, this }; We.prototype.optional = function () { let e = this._baseState; return e.optional = !0, this }; We.prototype.def = function (e) { let r = this._baseState; return _t(r.default === null), r.default = e, r.optional = !0, this }; We.prototype.explicit = function (e) { let r = this._baseState; return _t(r.explicit === null && r.implicit === null), r.explicit = e, this }; We.prototype.implicit = function (e) { let r = this._baseState; return _t(r.explicit === null && r.implicit === null), r.implicit = e, this }; We.prototype.obj = function () { let e = this._baseState, r = Array.prototype.slice.call(arguments); return e.obj = !0, r.length !== 0 && this._useArgs(r), this }; We.prototype.key = function (e) { let r = this._baseState; return _t(r.key === null), r.key = e, this }; We.prototype.any = function () { let e = this._baseState; return e.any = !0, this }; We.prototype.choice = function (e) { let r = this._baseState; return _t(r.choice === null), r.choice = e, this._useArgs(Object.keys(e).map(function (i) { return e[i] })), this }; We.prototype.contains = function (e) { let r = this._baseState; return _t(r.use === null), r.contains = e, this }; We.prototype._decode = function (e, r) { let i = this._baseState; if (i.parent === null) return e.wrapResult(i.children[0]._decode(e, r)); let n = i.default, f = !0, h = null; if (i.key !== null && (h = e.enterKey(i.key)), i.optional) { let y = null; if (i.explicit !== null ? y = i.explicit : i.implicit !== null ? y = i.implicit : i.tag !== null && (y = i.tag), y === null && !i.any) { let x = e.save(); try { i.choice === null ? this._decodeGeneric(i.tag, e, r) : this._decodeChoice(e, r), f = !0 } catch (M) { f = !1 } e.restore(x) } else if (f = this._peekTag(e, y, i.any), e.isError(f)) return f } let c; if (i.obj && f && (c = e.enterObject()), f) { if (i.explicit !== null) { let x = this._decodeTag(e, i.explicit); if (e.isError(x)) return x; e = x } let y = e.offset; if (i.use === null && i.choice === null) { let x; i.any && (x = e.save()); let M = this._decodeTag(e, i.implicit !== null ? i.implicit : i.tag, i.any); if (e.isError(M)) return M; i.any ? n = e.raw(x) : e = M } if (r && r.track && i.tag !== null && r.track(e.path(), y, e.length, "tagged"), r && r.track && i.tag !== null && r.track(e.path(), e.offset, e.length, "content"), i.any || (i.choice === null ? n = this._decodeGeneric(i.tag, e, r) : n = this._decodeChoice(e, r)), e.isError(n)) return n; if (!i.any && i.choice === null && i.children !== null && i.children.forEach(function (M) { M._decode(e, r) }), i.contains && (i.tag === "octstr" || i.tag === "bitstr")) { let x = new m9(n); n = this._getUse(i.contains, e._reporterState.obj)._decode(x, r) } } return i.obj && f && (n = e.leaveObject(c)), i.key !== null && (n !== null || f === !0) ? e.leaveKey(h, i.key, n) : h !== null && e.exitKey(h), n }; We.prototype._decodeGeneric = function (e, r, i) { let n = this._baseState; return e === "seq" || e === "set" ? null : e === "seqof" || e === "setof" ? this._decodeList(r, e, n.args[0], i) : /str$/.test(e) ? this._decodeStr(r, e, i) : e === "objid" && n.args ? this._decodeObjid(r, n.args[0], n.args[1], i) : e === "objid" ? this._decodeObjid(r, null, null, i) : e === "gentime" || e === "utctime" ? this._decodeTime(r, e, i) : e === "null_" ? this._decodeNull(r, i) : e === "bool" ? this._decodeBool(r, i) : e === "objDesc" ? this._decodeStr(r, e, i) : e === "int" || e === "enum" ? this._decodeInt(r, n.args && n.args[0], i) : n.use !== null ? this._getUse(n.use, r._reporterState.obj)._decode(r, i) : r.error("unknown tag: " + e) }; We.prototype._getUse = function (e, r) { let i = this._baseState; return i.useDecoder = this._use(e, r), _t(i.useDecoder._baseState.parent === null), i.useDecoder = i.useDecoder._baseState.children[0], i.implicit !== i.useDecoder._baseState.implicit && (i.useDecoder = i.useDecoder.clone(), i.useDecoder._baseState.implicit = i.implicit), i.useDecoder }; We.prototype._decodeChoice = function (e, r) { let i = this._baseState, n = null, f = !1; return Object.keys(i.choice).some(function (h) { let c = e.save(), y = i.choice[h]; try { let x = y._decode(e, r); if (e.isError(x)) return !1; n = { type: h, value: x }, f = !0 } catch (x) { return e.restore(c), !1 } return !0 }, this), f ? n : e.error("Choice not matched") }; We.prototype._createEncoderBuffer = function (e) { return new y9(e, this.reporter) }; We.prototype._encode = function (e, r, i) { let n = this._baseState; if (n.default !== null && n.default === e) return; let f = this._encodeValue(e, r, i); if (f !== void 0 && !this._skipDefault(f, r, i)) return f }; We.prototype._encodeValue = function (e, r, i) { let n = this._baseState; if (n.parent === null) return n.children[0]._encode(e, r || new b9); let f = null; if (this.reporter = r, n.optional && e === void 0) if (n.default !== null) e = n.default; else return; let h = null, c = !1; if (n.any) f = this._createEncoderBuffer(e); else if (n.choice) f = this._encodeChoice(e, r); else if (n.contains) h = this._getUse(n.contains, i)._encode(e, r), c = !0; else if (n.children) h = n.children.map(function (y) { if (y._baseState.tag === "null_") return y._encode(null, r, e); if (y._baseState.key === null) return r.error("Child should have a key"); let x = r.enterKey(y._baseState.key); if (typeof e != "object") return r.error("Child expected, but input is not object"); let M = y._encode(e[y._baseState.key], r, e); return r.leaveKey(x), M }, this).filter(function (y) { return y }), h = this._createEncoderBuffer(h); else if (n.tag === "seqof" || n.tag === "setof") { if (!(n.args && n.args.length === 1)) return r.error("Too many args for : " + n.tag); if (!Array.isArray(e)) return r.error("seqof/setof, but data is not Array"); let y = this.clone(); y._baseState.implicit = null, h = this._createEncoderBuffer(e.map(function (x) { let M = this._baseState; return this._getUse(M.args[0], e)._encode(x, r) }, y)) } else n.use !== null ? f = this._getUse(n.use, i)._encode(e, r) : (h = this._encodePrimitive(n.tag, e), c = !0); if (!n.any && n.choice === null) { let y = n.implicit !== null ? n.implicit : n.tag, x = n.implicit === null ? "universal" : "context"; y === null ? n.use === null && r.error("Tag could be omitted only for .use()") : n.use === null && (f = this._encodeComposite(y, c, x, h)) } return n.explicit !== null && (f = this._encodeComposite(n.explicit, !1, "context", f)), f }; We.prototype._encodeChoice = function (e, r) { let i = this._baseState, n = i.choice[e.type]; return n || _t(!1, e.type + " not found in " + JSON.stringify(Object.keys(i.choice))), n._encode(e.value, r) }; We.prototype._encodePrimitive = function (e, r) { let i = this._baseState; if (/str$/.test(e)) return this._encodeStr(r, e); if (e === "objid" && i.args) return this._encodeObjid(r, i.reverseArgs[0], i.args[1]); if (e === "objid") return this._encodeObjid(r, null, null); if (e === "gentime" || e === "utctime") return this._encodeTime(r, e); if (e === "null_") return this._encodeNull(); if (e === "int" || e === "enum") return this._encodeInt(r, i.args && i.reverseArgs[0]); if (e === "bool") return this._encodeBool(r); if (e === "objDesc") return this._encodeStr(r, e); throw new Error("Unsupported tag: " + e) }; We.prototype._isNumstr = function (e) { return /^[0-9 ]*$/.test(e) }; We.prototype._isPrintstr = function (e) { return /^[A-Za-z0-9 '()+,-./:=?]*$/.test(e) } }); var Bo = I(En => { "use strict"; function gb(t) { let e = {}; return Object.keys(t).forEach(function (r) { (r | 0) == r && (r = r | 0); let i = t[r]; e[i] = r }), e } En.tagClass = { 0: "universal", 1: "application", 2: "context", 3: "private" }; En.tagClassByName = gb(En.tagClass); En.tag = { 0: "end", 1: "bool", 2: "int", 3: "bitstr", 4: "octstr", 5: "null_", 6: "objid", 7: "objDesc", 8: "external", 9: "real", 10: "enum", 11: "embed", 12: "utf8str", 13: "relativeOid", 16: "seq", 17: "set", 18: "numstr", 19: "printstr", 20: "t61str", 21: "videostr", 22: "ia5str", 23: "utctime", 24: "gentime", 25: "graphstr", 26: "iso646str", 27: "genstr", 28: "unistr", 29: "charstr", 30: "bmpstr" }; En.tagByName = gb(En.tag) }); var _u = I((oB, xb) => { "use strict"; var x9 = Re(), ni = Mo().Buffer, wb = Ao(), wu = Bo(); function _b(t) { this.enc = "der", this.name = t.name, this.entity = t, this.tree = new _r, this.tree._init(t.body) } xb.exports = _b; _b.prototype.encode = function (e, r) { return this.tree._encode(e, r).join() }; function _r(t) { wb.call(this, "der", t) } x9(_r, wb); _r.prototype._encodeComposite = function (e, r, i, n) { let f = M9(e, r, i, this.reporter); if (n.length < 128) { let y = ni.alloc(2); return y[0] = f, y[1] = n.length, this._createEncoderBuffer([y, n]) } let h = 1; for (let y = n.length; y >= 256; y >>= 8)h++; let c = ni.alloc(1 + 1 + h); c[0] = f, c[1] = 128 | h; for (let y = 1 + h, x = n.length; x > 0; y--, x >>= 8)c[y] = x & 255; return this._createEncoderBuffer([c, n]) }; _r.prototype._encodeStr = function (e, r) { if (r === "bitstr") return this._createEncoderBuffer([e.unused | 0, e.data]); if (r === "bmpstr") { let i = ni.alloc(e.length * 2); for (let n = 0; n < e.length; n++)i.writeUInt16BE(e.charCodeAt(n), n * 2); return this._createEncoderBuffer(i) } else return r === "numstr" ? this._isNumstr(e) ? this._createEncoderBuffer(e) : this.reporter.error("Encoding of string type: numstr supports only digits and space") : r === "printstr" ? this._isPrintstr(e) ? this._createEncoderBuffer(e) : this.reporter.error("Encoding of string type: printstr supports only latin upper and lower case letters, digits, space, apostrophe, left and rigth parenthesis, plus sign, comma, hyphen, dot, slash, colon, equal sign, question mark") : /str$/.test(r) ? this._createEncoderBuffer(e) : r === "objDesc" ? this._createEncoderBuffer(e) : this.reporter.error("Encoding of string type: " + r + " unsupported") }; _r.prototype._encodeObjid = function (e, r, i) { if (typeof e == "string") { if (!r) return this.reporter.error("string objid given, but no values map found"); if (!r.hasOwnProperty(e)) return this.reporter.error("objid not found in values map"); e = r[e].split(/[\s.]+/g); for (let c = 0; c < e.length; c++)e[c] |= 0 } else if (Array.isArray(e)) { e = e.slice(); for (let c = 0; c < e.length; c++)e[c] |= 0 } if (!Array.isArray(e)) return this.reporter.error("objid() should be either array or string, got: " + JSON.stringify(e)); if (!i) { if (e[1] >= 40) return this.reporter.error("Second objid identifier OOB"); e.splice(0, 2, e[0] * 40 + e[1]) } let n = 0; for (let c = 0; c < e.length; c++) { let y = e[c]; for (n++; y >= 128; y >>= 7)n++ } let f = ni.alloc(n), h = f.length - 1; for (let c = e.length - 1; c >= 0; c--) { let y = e[c]; for (f[h--] = y & 127; (y >>= 7) > 0;)f[h--] = 128 | y & 127 } return this._createEncoderBuffer(f) }; function Xt(t) { return t < 10 ? "0" + t : t } _r.prototype._encodeTime = function (e, r) { let i, n = new Date(e); return r === "gentime" ? i = [Xt(n.getUTCFullYear()), Xt(n.getUTCMonth() + 1), Xt(n.getUTCDate()), Xt(n.getUTCHours()), Xt(n.getUTCMinutes()), Xt(n.getUTCSeconds()), "Z"].join("") : r === "utctime" ? i = [Xt(n.getUTCFullYear() % 100), Xt(n.getUTCMonth() + 1), Xt(n.getUTCDate()), Xt(n.getUTCHours()), Xt(n.getUTCMinutes()), Xt(n.getUTCSeconds()), "Z"].join("") : this.reporter.error("Encoding " + r + " time is not supported yet"), this._encodeStr(i, "octstr") }; _r.prototype._encodeNull = function () { return this._createEncoderBuffer("") }; _r.prototype._encodeInt = function (e, r) { if (typeof e == "string") { if (!r) return this.reporter.error("String int or enum given, but no values map"); if (!r.hasOwnProperty(e)) return this.reporter.error("Values map doesn't contain: " + JSON.stringify(e)); e = r[e] } if (typeof e != "number" && !ni.isBuffer(e)) { let f = e.toArray(); !e.sign && f[0] & 128 && f.unshift(0), e = ni.from(f) } if (ni.isBuffer(e)) { let f = e.length; e.length === 0 && f++; let h = ni.alloc(f); return e.copy(h), e.length === 0 && (h[0] = 0), this._createEncoderBuffer(h) } if (e < 128) return this._createEncoderBuffer(e); if (e < 256) return this._createEncoderBuffer([0, e]); let i = 1; for (let f = e; f >= 256; f >>= 8)i++; let n = new Array(i); for (let f = n.length - 1; f >= 0; f--)n[f] = e & 255, e >>= 8; return n[0] & 128 && n.unshift(0), this._createEncoderBuffer(ni.from(n)) }; _r.prototype._encodeBool = function (e) { return this._createEncoderBuffer(e ? 255 : 0) }; _r.prototype._use = function (e, r) { return typeof e == "function" && (e = e(r)), e._getEncoder("der").tree }; _r.prototype._skipDefault = function (e, r, i) { let n = this._baseState, f; if (n.default === null) return !1; let h = e.join(); if (n.defaultBuffer === void 0 && (n.defaultBuffer = this._encodeValue(n.default, r, i).join()), h.length !== n.defaultBuffer.length) return !1; for (f = 0; f < h.length; f++)if (h[f] !== n.defaultBuffer[f]) return !1; return !0 }; function M9(t, e, r, i) { let n; if (t === "seqof" ? t = "seq" : t === "setof" && (t = "set"), wu.tagByName.hasOwnProperty(t)) n = wu.tagByName[t]; else if (typeof t == "number" && (t | 0) === t) n = t; else return i.error("Unknown tag: " + t); return n >= 31 ? i.error("Multi-octet tag encoding unsupported") : (e || (n |= 32), n |= wu.tagClassByName[r || "universal"] << 6, n) } }); var Sb = I((hB, Mb) => {
          "use strict"; var S9 = Re(), xu = _u(); function Mu(t) { xu.call(this, t), this.enc = "pem" } S9(Mu, xu); Mb.exports = Mu; Mu.prototype.encode = function (e, r) {
            let n = xu.prototype.encode.call(this, e).toString("base64"), f = ["-----BEGIN " + r.label + "-----"]; for (let h = 0; h < n.length; h += 64)f.push(n.slice(h, h + 64)); return f.push("-----END " + r.label + "-----"), f.join(`
`)
          }
        }); var Su = I(Ab => { "use strict"; var Eb = Ab; Eb.der = _u(); Eb.pem = Sb() }); var Au = I((cB, kb) => { "use strict"; var E9 = Re(), A9 = rt(), Bb = wa().DecoderBuffer, Ib = Ao(), Rb = Bo(); function Tb(t) { this.enc = "der", this.name = t.name, this.entity = t, this.tree = new kt, this.tree._init(t.body) } kb.exports = Tb; Tb.prototype.decode = function (e, r) { return Bb.isDecoderBuffer(e) || (e = new Bb(e, r)), this.tree._decode(e, r) }; function kt(t) { Ib.call(this, "der", t) } E9(kt, Ib); kt.prototype._peekTag = function (e, r, i) { if (e.isEmpty()) return !1; let n = e.save(), f = Eu(e, 'Failed to peek tag: "' + r + '"'); return e.isError(f) ? f : (e.restore(n), f.tag === r || f.tagStr === r || f.tagStr + "of" === r || i) }; kt.prototype._decodeTag = function (e, r, i) { let n = Eu(e, 'Failed to decode tag of "' + r + '"'); if (e.isError(n)) return n; let f = qb(e, n.primitive, 'Failed to get length of "' + r + '"'); if (e.isError(f)) return f; if (!i && n.tag !== r && n.tagStr !== r && n.tagStr + "of" !== r) return e.error('Failed to match tag: "' + r + '"'); if (n.primitive || f !== null) return e.skip(f, 'Failed to match body of: "' + r + '"'); let h = e.save(), c = this._skipUntilEnd(e, 'Failed to skip indefinite length body: "' + this.tag + '"'); return e.isError(c) ? c : (f = e.offset - h.offset, e.restore(h), e.skip(f, 'Failed to match body of: "' + r + '"')) }; kt.prototype._skipUntilEnd = function (e, r) { for (; ;) { let i = Eu(e, r); if (e.isError(i)) return i; let n = qb(e, i.primitive, r); if (e.isError(n)) return n; let f; if (i.primitive || n !== null ? f = e.skip(n) : f = this._skipUntilEnd(e, r), e.isError(f)) return f; if (i.tagStr === "end") break } }; kt.prototype._decodeList = function (e, r, i, n) { let f = []; for (; !e.isEmpty();) { let h = this._peekTag(e, "end"); if (e.isError(h)) return h; let c = i.decode(e, "der", n); if (e.isError(c) && h) break; f.push(c) } return f }; kt.prototype._decodeStr = function (e, r) { if (r === "bitstr") { let i = e.readUInt8(); return e.isError(i) ? i : { unused: i, data: e.raw() } } else if (r === "bmpstr") { let i = e.raw(); if (i.length % 2 == 1) return e.error("Decoding of string type: bmpstr length mismatch"); let n = ""; for (let f = 0; f < i.length / 2; f++)n += String.fromCharCode(i.readUInt16BE(f * 2)); return n } else if (r === "numstr") { let i = e.raw().toString("ascii"); return this._isNumstr(i) ? i : e.error("Decoding of string type: numstr unsupported characters") } else { if (r === "octstr") return e.raw(); if (r === "objDesc") return e.raw(); if (r === "printstr") { let i = e.raw().toString("ascii"); return this._isPrintstr(i) ? i : e.error("Decoding of string type: printstr unsupported characters") } else return /str$/.test(r) ? e.raw().toString() : e.error("Decoding of string type: " + r + " unsupported") } }; kt.prototype._decodeObjid = function (e, r, i) { let n, f = [], h = 0, c = 0; for (; !e.isEmpty();)c = e.readUInt8(), h <<= 7, h |= c & 127, (c & 128) == 0 && (f.push(h), h = 0); c & 128 && f.push(h); let y = f[0] / 40 | 0, x = f[0] % 40; if (i ? n = f : n = [y, x].concat(f.slice(1)), r) { let M = r[n.join(" ")]; M === void 0 && (M = r[n.join(".")]), M !== void 0 && (n = M) } return n }; kt.prototype._decodeTime = function (e, r) { let i = e.raw().toString(), n, f, h, c, y, x; if (r === "gentime") n = i.slice(0, 4) | 0, f = i.slice(4, 6) | 0, h = i.slice(6, 8) | 0, c = i.slice(8, 10) | 0, y = i.slice(10, 12) | 0, x = i.slice(12, 14) | 0; else if (r === "utctime") n = i.slice(0, 2) | 0, f = i.slice(2, 4) | 0, h = i.slice(4, 6) | 0, c = i.slice(6, 8) | 0, y = i.slice(8, 10) | 0, x = i.slice(10, 12) | 0, n < 70 ? n = 2e3 + n : n = 1900 + n; else return e.error("Decoding " + r + " time is not supported yet"); return Date.UTC(n, f - 1, h, c, y, x, 0) }; kt.prototype._decodeNull = function () { return null }; kt.prototype._decodeBool = function (e) { let r = e.readUInt8(); return e.isError(r) ? r : r !== 0 }; kt.prototype._decodeInt = function (e, r) { let i = e.raw(), n = new A9(i); return r && (n = r[n.toString(10)] || n), n }; kt.prototype._use = function (e, r) { return typeof e == "function" && (e = e(r)), e._getDecoder("der").tree }; function Eu(t, e) { let r = t.readUInt8(e); if (t.isError(r)) return r; let i = Rb.tagClass[r >> 6], n = (r & 32) == 0; if ((r & 31) == 31) { let h = r; for (r = 0; (h & 128) == 128;) { if (h = t.readUInt8(e), t.isError(h)) return h; r <<= 7, r |= h & 127 } } else r &= 31; let f = Rb.tag[r]; return { cls: i, primitive: n, tag: r, tagStr: f } } function qb(t, e, r) { let i = t.readUInt8(r); if (t.isError(i)) return i; if (!e && i === 128) return null; if ((i & 128) == 0) return i; let n = i & 127; if (n > 4) return t.error("length octect is too long"); i = 0; for (let f = 0; f < n; f++) { i <<= 8; let h = t.readUInt8(r); if (t.isError(h)) return h; i |= h } return i } }); var Cb = I((dB, Pb) => { "use strict"; var B9 = Re(), I9 = Mo().Buffer, Bu = Au(); function Iu(t) { Bu.call(this, t), this.enc = "pem" } B9(Iu, Bu); Pb.exports = Iu; Iu.prototype.decode = function (e, r) { let i = e.toString().split(/[\r\n]+/g), n = r.label.toUpperCase(), f = /^-----(BEGIN|END) ([^-]+)-----$/, h = -1, c = -1; for (let M = 0; M < i.length; M++) { let E = i[M].match(f); if (E !== null && E[2] === n) if (h === -1) { if (E[1] !== "BEGIN") break; h = M } else { if (E[1] !== "END") break; c = M; break } } if (h === -1 || c === -1) throw new Error("PEM section not found for: " + n); let y = i.slice(h + 1, c).join(""); y.replace(/[^a-z0-9+/=]+/gi, ""); let x = I9.from(y, "base64"); return Bu.prototype.decode.call(this, x, r) } }); var Ru = I(Db => { "use strict"; var Ob = Db; Ob.der = Au(); Ob.pem = Cb() }); var Ub = I(Fb => { "use strict"; var R9 = Su(), T9 = Ru(), q9 = Re(), k9 = Fb; k9.define = function (e, r) { return new _a(e, r) }; function _a(t, e) { this.name = t, this.body = e, this.decoders = {}, this.encoders = {} } _a.prototype._createNamed = function (e) { let r = this.name; function i(n) { this._initNamed(n, r) } return q9(i, e), i.prototype._initNamed = function (f, h) { e.call(this, f, h) }, new i(this) }; _a.prototype._getDecoder = function (e) { return e = e || "der", this.decoders.hasOwnProperty(e) || (this.decoders[e] = this._createNamed(T9[e])), this.decoders[e] }; _a.prototype.decode = function (e, r, i) { return this._getDecoder(r).decode(e, i) }; _a.prototype._getEncoder = function (e) { return e = e || "der", this.encoders.hasOwnProperty(e) || (this.encoders[e] = this._createNamed(R9[e])), this.encoders[e] }; _a.prototype.encode = function (e, r, i) { return this._getEncoder(r).encode(e, i) } }); var Lb = I(Nb => { "use strict"; var Io = Nb; Io.Reporter = So().Reporter; Io.DecoderBuffer = wa().DecoderBuffer; Io.EncoderBuffer = wa().EncoderBuffer; Io.Node = Ao() }); var zb = I(jb => { "use strict"; var Hb = jb; Hb._reverse = function (e) { let r = {}; return Object.keys(e).forEach(function (i) { (i | 0) == i && (i = i | 0); let n = e[i]; r[n] = i }), r }; Hb.der = Bo() }); var Tu = I(Wb => { "use strict"; var xa = Wb; xa.bignum = rt(); xa.define = Ub().define; xa.base = Lb(); xa.constants = zb(); xa.decoders = Ru(); xa.encoders = Su() }); var $b = I((mB, Gb) => { "use strict"; var xr = Tu(), Kb = xr.define("Time", function () { this.choice({ utcTime: this.utctime(), generalTime: this.gentime() }) }), P9 = xr.define("AttributeTypeValue", function () { this.seq().obj(this.key("type").objid(), this.key("value").any()) }), qu = xr.define("AlgorithmIdentifier", function () { this.seq().obj(this.key("algorithm").objid(), this.key("parameters").optional(), this.key("curve").objid().optional()) }), C9 = xr.define("SubjectPublicKeyInfo", function () { this.seq().obj(this.key("algorithm").use(qu), this.key("subjectPublicKey").bitstr()) }), O9 = xr.define("RelativeDistinguishedName", function () { this.setof(P9) }), D9 = xr.define("RDNSequence", function () { this.seqof(O9) }), Vb = xr.define("Name", function () { this.choice({ rdnSequence: this.use(D9) }) }), F9 = xr.define("Validity", function () { this.seq().obj(this.key("notBefore").use(Kb), this.key("notAfter").use(Kb)) }), U9 = xr.define("Extension", function () { this.seq().obj(this.key("extnID").objid(), this.key("critical").bool().def(!1), this.key("extnValue").octstr()) }), N9 = xr.define("TBSCertificate", function () { this.seq().obj(this.key("version").explicit(0).int().optional(), this.key("serialNumber").int(), this.key("signature").use(qu), this.key("issuer").use(Vb), this.key("validity").use(F9), this.key("subject").use(Vb), this.key("subjectPublicKeyInfo").use(C9), this.key("issuerUniqueID").implicit(1).bitstr().optional(), this.key("subjectUniqueID").implicit(2).bitstr().optional(), this.key("extensions").explicit(3).seqof(U9).optional()) }), L9 = xr.define("X509Certificate", function () { this.seq().obj(this.key("tbsCertificate").use(N9), this.key("signatureAlgorithm").use(qu), this.key("signatureValue").bitstr()) }); Gb.exports = L9 }); var Yb = I(Sr => { "use strict"; var Mr = Tu(); Sr.certificate = $b(); var H9 = Mr.define("RSAPrivateKey", function () { this.seq().obj(this.key("version").int(), this.key("modulus").int(), this.key("publicExponent").int(), this.key("privateExponent").int(), this.key("prime1").int(), this.key("prime2").int(), this.key("exponent1").int(), this.key("exponent2").int(), this.key("coefficient").int()) }); Sr.RSAPrivateKey = H9; var j9 = Mr.define("RSAPublicKey", function () { this.seq().obj(this.key("modulus").int(), this.key("publicExponent").int()) }); Sr.RSAPublicKey = j9; var z9 = Mr.define("SubjectPublicKeyInfo", function () { this.seq().obj(this.key("algorithm").use(Xb), this.key("subjectPublicKey").bitstr()) }); Sr.PublicKey = z9; var Xb = Mr.define("AlgorithmIdentifier", function () { this.seq().obj(this.key("algorithm").objid(), this.key("none").null_().optional(), this.key("curve").objid().optional(), this.key("params").seq().obj(this.key("p").int(), this.key("q").int(), this.key("g").int()).optional()) }), W9 = Mr.define("PrivateKeyInfo", function () { this.seq().obj(this.key("version").int(), this.key("algorithm").use(Xb), this.key("subjectPrivateKey").octstr()) }); Sr.PrivateKey = W9; var K9 = Mr.define("EncryptedPrivateKeyInfo", function () { this.seq().obj(this.key("algorithm").seq().obj(this.key("id").objid(), this.key("decrypt").seq().obj(this.key("kde").seq().obj(this.key("id").objid(), this.key("kdeparams").seq().obj(this.key("salt").octstr(), this.key("iters").int())), this.key("cipher").seq().obj(this.key("algo").objid(), this.key("iv").octstr()))), this.key("subjectPrivateKey").octstr()) }); Sr.EncryptedPrivateKey = K9; var V9 = Mr.define("DSAPrivateKey", function () { this.seq().obj(this.key("version").int(), this.key("p").int(), this.key("q").int(), this.key("g").int(), this.key("pub_key").int(), this.key("priv_key").int()) }); Sr.DSAPrivateKey = V9; Sr.DSAparam = Mr.define("DSAparam", function () { this.int() }); var G9 = Mr.define("ECPrivateKey", function () { this.seq().obj(this.key("version").int(), this.key("privateKey").octstr(), this.key("parameters").optional().explicit(0).use($9), this.key("publicKey").optional().explicit(1).bitstr()) }); Sr.ECPrivateKey = G9; var $9 = Mr.define("ECParameters", function () { this.choice({ namedCurve: this.objid() }) }); Sr.signature = Mr.define("signature", function () { this.seq().obj(this.key("r").int(), this.key("s").int()) }) }); var Zb = I((wB, X9) => { X9.exports = { "2.16.840.1.101.3.4.1.1": "aes-128-ecb", "2.16.840.1.101.3.4.1.2": "aes-128-cbc", "2.16.840.1.101.3.4.1.3": "aes-128-ofb", "2.16.840.1.101.3.4.1.4": "aes-128-cfb", "2.16.840.1.101.3.4.1.21": "aes-192-ecb", "2.16.840.1.101.3.4.1.22": "aes-192-cbc", "2.16.840.1.101.3.4.1.23": "aes-192-ofb", "2.16.840.1.101.3.4.1.24": "aes-192-cfb", "2.16.840.1.101.3.4.1.41": "aes-256-ecb", "2.16.840.1.101.3.4.1.42": "aes-256-cbc", "2.16.840.1.101.3.4.1.43": "aes-256-ofb", "2.16.840.1.101.3.4.1.44": "aes-256-cfb" } }); var Qb = I((_B, Jb) => { var Y9 = /Proc-Type: 4,ENCRYPTED[\n\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\n\r]+([0-9A-z\n\r+/=]+)[\n\r]+/m, Z9 = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----/m, J9 = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----([0-9A-z\n\r+/=]+)-----END \1-----$/m, Q9 = _f(), e_ = yo(), Ro = Te().Buffer; Jb.exports = function (t, e) { var r = t.toString(), i = r.match(Y9), n; if (i) { var h = "aes" + i[1], c = Ro.from(i[2], "hex"), y = Ro.from(i[3].replace(/[\r\n]/g, ""), "base64"), x = Q9(e, c.slice(0, 8), parseInt(i[1], 10)).key, M = [], E = e_.createDecipheriv(h, x, c); M.push(E.update(y)), M.push(E.final()), n = Ro.concat(M) } else { var f = r.match(J9); n = Ro.from(f[2].replace(/[\r\n]/g, ""), "base64") } var A = r.match(Z9)[1]; return { tag: A, data: n } } }); var Sf = I((xB, t2) => { var At = Yb(), t_ = Zb(), r_ = Qb(), i_ = yo(), n_ = W0(), ku = Te().Buffer; t2.exports = e2; function e2(t) { var e; typeof t == "object" && !ku.isBuffer(t) && (e = t.passphrase, t = t.key), typeof t == "string" && (t = ku.from(t)); var r = r_(t, e), i = r.tag, n = r.data, f, h; switch (i) { case "CERTIFICATE": h = At.certificate.decode(n, "der").tbsCertificate.subjectPublicKeyInfo; case "PUBLIC KEY": switch (h || (h = At.PublicKey.decode(n, "der")), f = h.algorithm.algorithm.join("."), f) { case "1.2.840.113549.1.1.1": return At.RSAPublicKey.decode(h.subjectPublicKey.data, "der"); case "1.2.840.10045.2.1": return h.subjectPrivateKey = h.subjectPublicKey, { type: "ec", data: h }; case "1.2.840.10040.4.1": return h.algorithm.params.pub_key = At.DSAparam.decode(h.subjectPublicKey.data, "der"), { type: "dsa", data: h.algorithm.params }; default: throw new Error("unknown key id " + f) }case "ENCRYPTED PRIVATE KEY": n = At.EncryptedPrivateKey.decode(n, "der"), n = a_(n, e); case "PRIVATE KEY": switch (h = At.PrivateKey.decode(n, "der"), f = h.algorithm.algorithm.join("."), f) { case "1.2.840.113549.1.1.1": return At.RSAPrivateKey.decode(h.subjectPrivateKey, "der"); case "1.2.840.10045.2.1": return { curve: h.algorithm.curve, privateKey: At.ECPrivateKey.decode(h.subjectPrivateKey, "der").privateKey }; case "1.2.840.10040.4.1": return h.algorithm.params.priv_key = At.DSAparam.decode(h.subjectPrivateKey, "der"), { type: "dsa", params: h.algorithm.params }; default: throw new Error("unknown key id " + f) }case "RSA PUBLIC KEY": return At.RSAPublicKey.decode(n, "der"); case "RSA PRIVATE KEY": return At.RSAPrivateKey.decode(n, "der"); case "DSA PRIVATE KEY": return { type: "dsa", params: At.DSAPrivateKey.decode(n, "der") }; case "EC PRIVATE KEY": return n = At.ECPrivateKey.decode(n, "der"), { curve: n.parameters.value, privateKey: n.privateKey }; default: throw new Error("unknown key type " + i) } } e2.signature = At.signature; function a_(t, e) { var r = t.algorithm.decrypt.kde.kdeparams.salt, i = parseInt(t.algorithm.decrypt.kde.kdeparams.iters.toString(), 10), n = t_[t.algorithm.decrypt.cipher.algo.join(".")], f = t.algorithm.decrypt.cipher.iv, h = t.subjectPrivateKey, c = parseInt(n.split("-")[1], 10) / 8, y = n_.pbkdf2Sync(e, r, i, c, "sha1"), x = i_.createDecipheriv(n, y, f), M = []; return M.push(x.update(h)), M.push(x.final()), ku.concat(M) } }); var Pu = I((MB, f_) => { f_.exports = { "1.3.132.0.10": "secp256k1", "1.3.132.0.33": "p224", "1.2.840.10045.3.1.1": "p192", "1.2.840.10045.3.1.7": "p256", "1.3.132.0.34": "p384", "1.3.132.0.35": "p521" } }); var n2 = I((SB, qo) => { var gt = Te().Buffer, An = C0(), s_ = _o(), o_ = Ef().ec, To = mu(), h_ = Sf(), u_ = Pu(); function c_(t, e, r, i, n) { var f = h_(e); if (f.curve) { if (i !== "ecdsa" && i !== "ecdsa/rsa") throw new Error("wrong private key type"); return d_(t, f) } else if (f.type === "dsa") { if (i !== "dsa") throw new Error("wrong private key type"); return l_(t, f, r) } else if (i !== "rsa" && i !== "ecdsa/rsa") throw new Error("wrong private key type"); t = gt.concat([n, t]); for (var h = f.modulus.byteLength(), c = [0, 1]; t.length + c.length + 1 < h;)c.push(255); c.push(0); for (var y = -1; ++y < t.length;)c.push(t[y]); var x = s_(c, f); return x } function d_(t, e) { var r = u_[e.curve.join(".")]; if (!r) throw new Error("unknown curve " + e.curve.join(".")); var i = new o_(r), n = i.keyFromPrivate(e.privateKey), f = n.sign(t); return gt.from(f.toDER()) } function l_(t, e, r) { for (var i = e.params.priv_key, n = e.params.p, f = e.params.q, h = e.params.g, c = new To(0), y, x = Cu(t, f).mod(f), M = !1, E = r2(i, f, t, r); M === !1;)y = i2(f, E, r), c = b_(h, y, n, f), M = y.invm(f).imul(x.add(i.mul(c))).mod(f), M.cmpn(0) === 0 && (M = !1, c = new To(0)); return p_(c, M) } function p_(t, e) { t = t.toArray(), e = e.toArray(), t[0] & 128 && (t = [0].concat(t)), e[0] & 128 && (e = [0].concat(e)); var r = t.length + e.length + 4, i = [48, r, 2, t.length]; return i = i.concat(t, [2, e.length], e), gt.from(i) } function r2(t, e, r, i) { if (t = gt.from(t.toArray()), t.length < e.byteLength()) { var n = gt.alloc(e.byteLength() - t.length); t = gt.concat([n, t]) } var f = r.length, h = v_(r, e), c = gt.alloc(f); c.fill(1); var y = gt.alloc(f); return y = An(i, y).update(c).update(gt.from([0])).update(t).update(h).digest(), c = An(i, y).update(c).digest(), y = An(i, y).update(c).update(gt.from([1])).update(t).update(h).digest(), c = An(i, y).update(c).digest(), { k: y, v: c } } function Cu(t, e) { var r = new To(t), i = (t.length << 3) - e.bitLength(); return i > 0 && r.ishrn(i), r } function v_(t, e) { t = Cu(t, e), t = t.mod(e); var r = gt.from(t.toArray()); if (r.length < e.byteLength()) { var i = gt.alloc(e.byteLength() - r.length); r = gt.concat([i, r]) } return r } function i2(t, e, r) { var i, n; do { for (i = gt.alloc(0); i.length * 8 < t.bitLength();)e.v = An(r, e.k).update(e.v).digest(), i = gt.concat([i, e.v]); n = Cu(i, t), e.k = An(r, e.k).update(e.v).update(gt.from([0])).digest(), e.v = An(r, e.k).update(e.v).digest() } while (n.cmp(t) !== -1); return n } function b_(t, e, r, i) { return t.toRed(To.mont(r)).redPow(e).fromRed().mod(i) } qo.exports = c_; qo.exports.getKey = r2; qo.exports.makeKey = i2 }); var o2 = I((EB, s2) => { var Ou = Te().Buffer, Af = mu(), y_ = Ef().ec, a2 = Sf(), m_ = Pu(); function g_(t, e, r, i, n) { var f = a2(r); if (f.type === "ec") { if (i !== "ecdsa" && i !== "ecdsa/rsa") throw new Error("wrong public key type"); return w_(t, e, f) } else if (f.type === "dsa") { if (i !== "dsa") throw new Error("wrong public key type"); return __(t, e, f) } else if (i !== "rsa" && i !== "ecdsa/rsa") throw new Error("wrong public key type"); e = Ou.concat([n, e]); for (var h = f.modulus.byteLength(), c = [1], y = 0; e.length + c.length + 2 < h;)c.push(255), y++; c.push(0); for (var x = -1; ++x < e.length;)c.push(e[x]); c = Ou.from(c); var M = Af.mont(f.modulus); t = new Af(t).toRed(M), t = t.redPow(new Af(f.publicExponent)), t = Ou.from(t.fromRed().toArray()); var E = y < 8 ? 1 : 0; for (h = Math.min(t.length, c.length), t.length !== c.length && (E = 1), x = -1; ++x < h;)E |= t[x] ^ c[x]; return E === 0 } function w_(t, e, r) { var i = m_[r.data.algorithm.curve.join(".")]; if (!i) throw new Error("unknown curve " + r.data.algorithm.curve.join(".")); var n = new y_(i), f = r.data.subjectPrivateKey.data; return n.verify(e, t, f) } function __(t, e, r) { var i = r.data.p, n = r.data.q, f = r.data.g, h = r.data.pub_key, c = a2.signature.decode(t, "der"), y = c.s, x = c.r; f2(y, n), f2(x, n); var M = Af.mont(i), E = y.invm(n), A = f.toRed(M).redPow(new Af(e).mul(E).mod(n)).fromRed().mul(h.toRed(M).redPow(x.mul(E).mod(n)).fromRed()).mod(i).mod(n); return A.cmp(x) === 0 } function f2(t, e) { if (t.cmpn(0) <= 0) throw new Error("invalid sig"); if (t.cmp(e) >= e) throw new Error("invalid sig") } s2.exports = g_ }); var p2 = I((AB, l2) => { var ko = Te().Buffer, h2 = sa(), Po = E0(), u2 = Re(), x_ = n2(), M_ = o2(), Bn = O0(); Object.keys(Bn).forEach(function (t) { Bn[t].id = ko.from(Bn[t].id, "hex"), Bn[t.toLowerCase()] = Bn[t] }); function Bf(t) { Po.Writable.call(this); var e = Bn[t]; if (!e) throw new Error("Unknown message digest"); this._hashType = e.hash, this._hash = h2(e.hash), this._tag = e.id, this._signType = e.sign } u2(Bf, Po.Writable); Bf.prototype._write = function (e, r, i) { this._hash.update(e), i() }; Bf.prototype.update = function (e, r) { return typeof e == "string" && (e = ko.from(e, r)), this._hash.update(e), this }; Bf.prototype.sign = function (e, r) { this.end(); var i = this._hash.digest(), n = x_(i, e, this._hashType, this._signType, this._tag); return r ? n.toString(r) : n }; function If(t) { Po.Writable.call(this); var e = Bn[t]; if (!e) throw new Error("Unknown message digest"); this._hash = h2(e.hash), this._tag = e.id, this._signType = e.sign } u2(If, Po.Writable); If.prototype._write = function (e, r, i) { this._hash.update(e), i() }; If.prototype.update = function (e, r) { return typeof e == "string" && (e = ko.from(e, r)), this._hash.update(e), this }; If.prototype.verify = function (e, r, i) { typeof r == "string" && (r = ko.from(r, i)), this.end(); var n = this._hash.digest(); return M_(r, n, e, this._signType, this._tag) }; function c2(t) { return new Bf(t) } function d2(t) { return new If(t) } l2.exports = { Sign: c2, Verify: d2, createSign: c2, createVerify: d2 } }); var b2 = I((BB, v2) => { var S_ = Ef(), E_ = rt(); v2.exports = function (e) { return new In(e) }; var Pt = { secp256k1: { name: "secp256k1", byteLength: 32 }, secp224r1: { name: "p224", byteLength: 28 }, prime256v1: { name: "p256", byteLength: 32 }, prime192v1: { name: "p192", byteLength: 24 }, ed25519: { name: "ed25519", byteLength: 32 }, secp384r1: { name: "p384", byteLength: 48 }, secp521r1: { name: "p521", byteLength: 66 } }; Pt.p224 = Pt.secp224r1; Pt.p256 = Pt.secp256r1 = Pt.prime256v1; Pt.p192 = Pt.secp192r1 = Pt.prime192v1; Pt.p384 = Pt.secp384r1; Pt.p521 = Pt.secp521r1; function In(t) { this.curveType = Pt[t], this.curveType || (this.curveType = { name: t }), this.curve = new S_.ec(this.curveType.name), this.keys = void 0 } In.prototype.generateKeys = function (t, e) { return this.keys = this.curve.genKeyPair(), this.getPublicKey(t, e) }; In.prototype.computeSecret = function (t, e, r) { e = e || "utf8", Buffer.isBuffer(t) || (t = new Buffer(t, e)); var i = this.curve.keyFromPublic(t).getPublic(), n = i.mul(this.keys.getPrivate()).getX(); return Du(n, r, this.curveType.byteLength) }; In.prototype.getPublicKey = function (t, e) { var r = this.keys.getPublic(e === "compressed", !0); return e === "hybrid" && (r[r.length - 1] % 2 ? r[0] = 7 : r[0] = 6), Du(r, t) }; In.prototype.getPrivateKey = function (t) { return Du(this.keys.getPrivate(), t) }; In.prototype.setPublicKey = function (t, e) { return e = e || "utf8", Buffer.isBuffer(t) || (t = new Buffer(t, e)), this.keys._importPublic(t), this }; In.prototype.setPrivateKey = function (t, e) { e = e || "utf8", Buffer.isBuffer(t) || (t = new Buffer(t, e)); var r = new E_(t); return r = r.toString(16), this.keys = this.curve.genKeyPair(), this.keys._importPrivate(r), this }; function Du(t, e, r) { Array.isArray(t) || (t = t.toArray()); var i = new Buffer(t); if (r && i.length < r) { var n = new Buffer(r - i.length); n.fill(0), i = Buffer.concat([n, i]) } return e ? i.toString(e) : i } }); var Uu = I((IB, y2) => { var A_ = sa(), Fu = Te().Buffer; y2.exports = function (t, e) { for (var r = Fu.alloc(0), i = 0, n; r.length < e;)n = B_(i++), r = Fu.concat([r, A_("sha1").update(t).update(n).digest()]); return r.slice(0, e) }; function B_(t) { var e = Fu.allocUnsafe(4); return e.writeUInt32BE(t, 0), e } }); var Nu = I((RB, m2) => { m2.exports = function (e, r) { for (var i = e.length, n = -1; ++n < i;)e[n] ^= r[n]; return e } }); var Lu = I((TB, w2) => { var g2 = rt(), I_ = Te().Buffer; function R_(t, e) { return I_.from(t.toRed(g2.mont(e.modulus)).redPow(new g2(e.publicExponent)).fromRed().toArray()) } w2.exports = R_ }); var S2 = I((qB, M2) => { var T_ = Sf(), Hu = an(), q_ = sa(), _2 = Uu(), x2 = Nu(), ju = rt(), k_ = Lu(), P_ = _o(), Er = Te().Buffer; M2.exports = function (e, r, i) { var n; e.padding ? n = e.padding : i ? n = 1 : n = 4; var f = T_(e), h; if (n === 4) h = C_(f, r); else if (n === 1) h = O_(f, r, i); else if (n === 3) { if (h = new ju(r), h.cmp(f.modulus) >= 0) throw new Error("data too long for modulus") } else throw new Error("unknown padding"); return i ? P_(h, f) : k_(h, f) }; function C_(t, e) { var r = t.modulus.byteLength(), i = e.length, n = q_("sha1").update(Er.alloc(0)).digest(), f = n.length, h = 2 * f; if (i > r - h - 2) throw new Error("message too long"); var c = Er.alloc(r - i - h - 2), y = r - f - 1, x = Hu(f), M = x2(Er.concat([n, c, Er.alloc(1, 1), e], y), _2(x, y)), E = x2(x, _2(M, f)); return new ju(Er.concat([Er.alloc(1), E, M], r)) } function O_(t, e, r) { var i = e.length, n = t.modulus.byteLength(); if (i > n - 11) throw new Error("message too long"); var f; return r ? f = Er.alloc(n - i - 3, 255) : f = D_(n - i - 3), new ju(Er.concat([Er.from([0, r ? 1 : 2]), f, Er.alloc(1), e], n)) } function D_(t) { for (var e = Er.allocUnsafe(t), r = 0, i = Hu(t * 2), n = 0, f; r < t;)n === i.length && (i = Hu(t * 2), n = 0), f = i[n++], f && (e[r++] = f); return e } }); var R2 = I((kB, I2) => { var F_ = Sf(), E2 = Uu(), A2 = Nu(), B2 = rt(), U_ = _o(), N_ = sa(), L_ = Lu(), Rf = Te().Buffer; I2.exports = function (e, r, i) { var n; e.padding ? n = e.padding : i ? n = 1 : n = 4; var f = F_(e), h = f.modulus.byteLength(); if (r.length > h || new B2(r).cmp(f.modulus) >= 0) throw new Error("decryption error"); var c; i ? c = L_(new B2(r), f) : c = U_(r, f); var y = Rf.alloc(h - c.length); if (c = Rf.concat([y, c], h), n === 4) return H_(f, c); if (n === 1) return j_(f, c, i); if (n === 3) return c; throw new Error("unknown padding") }; function H_(t, e) { var r = t.modulus.byteLength(), i = N_("sha1").update(Rf.alloc(0)).digest(), n = i.length; if (e[0] !== 0) throw new Error("decryption error"); var f = e.slice(1, n + 1), h = e.slice(n + 1), c = A2(f, E2(h, n)), y = A2(h, E2(c, r - n - 1)); if (z_(i, y.slice(0, n))) throw new Error("decryption error"); for (var x = n; y[x] === 0;)x++; if (y[x++] !== 1) throw new Error("decryption error"); return y.slice(x) } function j_(t, e, r) { for (var i = e.slice(0, 2), n = 2, f = 0; e[n++] !== 0;)if (n >= e.length) { f++; break } var h = e.slice(2, n - 1); if ((i.toString("hex") !== "0002" && !r || i.toString("hex") !== "0001" && r) && f++, h.length < 8 && f++, f) throw new Error("decryption error"); return e.slice(n) } function z_(t, e) { t = Rf.from(t), e = Rf.from(e); var r = 0, i = t.length; t.length !== e.length && (r++, i = Math.min(t.length, e.length)); for (var n = -1; ++n < i;)r += t[n] ^ e[n]; return r } }); var T2 = I(Rn => { Rn.publicEncrypt = S2(); Rn.privateDecrypt = R2(); Rn.privateEncrypt = function (e, r) { return Rn.publicEncrypt(e, r, !0) }; Rn.publicDecrypt = function (e, r) { return Rn.privateDecrypt(e, r, !0) } }); var L2 = I(Tf => {
          "use strict"; function q2() {
            throw new Error(`secure random number generation not supported by this browser
use chrome, FireFox or Internet Explorer 11`)
          } var k2 = Te(), P2 = an(), C2 = k2.Buffer, O2 = k2.kMaxLength, zu = window.crypto || window.msCrypto, D2 = Math.pow(2, 32) - 1; function F2(t, e) { if (typeof t != "number" || t !== t) throw new TypeError("offset must be a number"); if (t > D2 || t < 0) throw new TypeError("offset must be a uint32"); if (t > O2 || t > e) throw new RangeError("offset out of range") } function U2(t, e, r) { if (typeof t != "number" || t !== t) throw new TypeError("size must be a number"); if (t > D2 || t < 0) throw new TypeError("size must be a uint32"); if (t + e > r || t > O2) throw new RangeError("buffer too small") } zu && zu.getRandomValues || !process.browser ? (Tf.randomFill = W_, Tf.randomFillSync = K_) : (Tf.randomFill = q2, Tf.randomFillSync = q2); function W_(t, e, r, i) { if (!C2.isBuffer(t) && !(t instanceof window.Uint8Array)) throw new TypeError('"buf" argument must be a Buffer or Uint8Array'); if (typeof e == "function") i = e, e = 0, r = t.length; else if (typeof r == "function") i = r, r = t.length - e; else if (typeof i != "function") throw new TypeError('"cb" argument must be a function'); return F2(e, t.length), U2(r, e, t.length), N2(t, e, r, i) } function N2(t, e, r, i) { if (process.browser) { var n = t.buffer, f = new Uint8Array(n, e, r); if (zu.getRandomValues(f), i) { process.nextTick(function () { i(null, t) }); return } return t } if (i) { P2(r, function (c, y) { if (c) return i(c); y.copy(t, e), i(null, t) }); return } var h = P2(r); return h.copy(t, e), t } function K_(t, e, r) { if (typeof e == "undefined" && (e = 0), !C2.isBuffer(t) && !(t instanceof window.Uint8Array)) throw new TypeError('"buf" argument must be a Buffer or Uint8Array'); return F2(e, t.length), r === void 0 && (r = t.length - e), U2(r, e, t.length), N2(t, e, r) }
        }); var z2 = I(qe => {
          "use strict"; qe.randomBytes = qe.rng = qe.pseudoRandomBytes = qe.prng = an(); qe.createHash = qe.Hash = sa(); qe.createHmac = qe.Hmac = C0(); var V_ = R1(), G_ = Object.keys(V_), $_ = ["sha1", "sha224", "sha256", "sha384", "sha512", "md5", "rmd160"].concat(G_); qe.getHashes = function () { return $_ }; var H2 = W0(); qe.pbkdf2 = H2.pbkdf2; qe.pbkdf2Sync = H2.pbkdf2Sync; var Cr = Yv(); qe.Cipher = Cr.Cipher; qe.createCipher = Cr.createCipher; qe.Cipheriv = Cr.Cipheriv; qe.createCipheriv = Cr.createCipheriv; qe.Decipher = Cr.Decipher; qe.createDecipher = Cr.createDecipher; qe.Decipheriv = Cr.Decipheriv; qe.createDecipheriv = Cr.createDecipheriv; qe.getCiphers = Cr.getCiphers; qe.listCiphers = Cr.listCiphers; var qf = ob(); qe.DiffieHellmanGroup = qf.DiffieHellmanGroup; qe.createDiffieHellmanGroup = qf.createDiffieHellmanGroup; qe.getDiffieHellman = qf.getDiffieHellman; qe.createDiffieHellman = qf.createDiffieHellman; qe.DiffieHellman = qf.DiffieHellman; var Co = p2(); qe.createSign = Co.createSign; qe.Sign = Co.Sign; qe.createVerify = Co.createVerify; qe.Verify = Co.Verify; qe.createECDH = b2(); var Oo = T2(); qe.publicEncrypt = Oo.publicEncrypt; qe.privateEncrypt = Oo.privateEncrypt; qe.publicDecrypt = Oo.publicDecrypt; qe.privateDecrypt = Oo.privateDecrypt; var j2 = L2(); qe.randomFill = j2.randomFill; qe.randomFillSync = j2.randomFillSync; qe.createCredentials = function () {
            throw new Error(["sorry, createCredentials is not implemented yet", "we accept pull requests", "https://github.com/crypto-browserify/crypto-browserify"].join(`
`))
          }; qe.constants = { DH_CHECK_P_NOT_SAFE_PRIME: 2, DH_CHECK_P_NOT_PRIME: 1, DH_UNABLE_TO_CHECK_GENERATOR: 4, DH_NOT_SUITABLE_GENERATOR: 8, NPN_ENABLED: 1, ALPN_ENABLED: 1, RSA_PKCS1_PADDING: 1, RSA_SSLV23_PADDING: 2, RSA_NO_PADDING: 3, RSA_PKCS1_OAEP_PADDING: 4, RSA_X931_PADDING: 5, RSA_PKCS1_PSS_PADDING: 6, POINT_CONVERSION_COMPRESSED: 2, POINT_CONVERSION_UNCOMPRESSED: 4, POINT_CONVERSION_HYBRID: 6 }
        }); var mo = I((DB, Vu) => { var Wu; Vu.exports = function (e) { return Wu || (Wu = new Wi(null)), Wu.generate(e) }; function Wi(t) { this.rand = t } Vu.exports.Rand = Wi; Wi.prototype.generate = function (e) { return this._rand(e) }; Wi.prototype._rand = function (e) { if (this.rand.getBytes) return this.rand.getBytes(e); for (var r = new Uint8Array(e), i = 0; i < r.length; i++)r[i] = this.rand.getByte(); return r }; if (typeof self == "object") self.crypto && self.crypto.getRandomValues ? Wi.prototype._rand = function (e) { var r = new Uint8Array(e); return self.crypto.getRandomValues(r), r } : self.msCrypto && self.msCrypto.getRandomValues ? Wi.prototype._rand = function (e) { var r = new Uint8Array(e); return self.msCrypto.getRandomValues(r), r } : typeof window == "object" && (Wi.prototype._rand = function () { throw new Error("Not implemented yet") }); else try { if (Ku = z2(), typeof Ku.randomBytes != "function") throw new Error("Not supported"); Wi.prototype._rand = function (e) { return Ku.randomBytes(e) } } catch (t) { } var Ku }); var Pf = I((FB, W2) => { "use strict"; var Tn = rt(), kf = qt(), Do = kf.getNAF, X_ = kf.getJSF, Fo = kf.assert; function Ki(t, e) { this.type = t, this.p = new Tn(e.p, 16), this.red = e.prime ? Tn.red(e.prime) : Tn.mont(this.p), this.zero = new Tn(0).toRed(this.red), this.one = new Tn(1).toRed(this.red), this.two = new Tn(2).toRed(this.red), this.n = e.n && new Tn(e.n, 16), this.g = e.g && this.pointFromJSON(e.g, e.gRed), this._wnafT1 = new Array(4), this._wnafT2 = new Array(4), this._wnafT3 = new Array(4), this._wnafT4 = new Array(4), this._bitLength = this.n ? this.n.bitLength() : 0; var r = this.n && this.p.div(this.n); !r || r.cmpn(100) > 0 ? this.redN = null : (this._maxwellTrick = !0, this.redN = this.n.toRed(this.red)) } W2.exports = Ki; Ki.prototype.point = function () { throw new Error("Not implemented") }; Ki.prototype.validate = function () { throw new Error("Not implemented") }; Ki.prototype._fixedNafMul = function (e, r) { Fo(e.precomputed); var i = e._getDoubles(), n = Do(r, 1, this._bitLength), f = (1 << i.step + 1) - (i.step % 2 == 0 ? 2 : 1); f /= 3; var h = [], c, y; for (c = 0; c < n.length; c += i.step) { y = 0; for (var x = c + i.step - 1; x >= c; x--)y = (y << 1) + n[x]; h.push(y) } for (var M = this.jpoint(null, null, null), E = this.jpoint(null, null, null), A = f; A > 0; A--) { for (c = 0; c < h.length; c++)y = h[c], y === A ? E = E.mixedAdd(i.points[c]) : y === -A && (E = E.mixedAdd(i.points[c].neg())); M = M.add(E) } return M.toP() }; Ki.prototype._wnafMul = function (e, r) { var i = 4, n = e._getNAFPoints(i); i = n.wnd; for (var f = n.points, h = Do(r, i, this._bitLength), c = this.jpoint(null, null, null), y = h.length - 1; y >= 0; y--) { for (var x = 0; y >= 0 && h[y] === 0; y--)x++; if (y >= 0 && x++, c = c.dblp(x), y < 0) break; var M = h[y]; Fo(M !== 0), e.type === "affine" ? M > 0 ? c = c.mixedAdd(f[M - 1 >> 1]) : c = c.mixedAdd(f[-M - 1 >> 1].neg()) : M > 0 ? c = c.add(f[M - 1 >> 1]) : c = c.add(f[-M - 1 >> 1].neg()) } return e.type === "affine" ? c.toP() : c }; Ki.prototype._wnafMulAdd = function (e, r, i, n, f) { var h = this._wnafT1, c = this._wnafT2, y = this._wnafT3, x = 0, M, E, A; for (M = 0; M < n; M++) { A = r[M]; var B = A._getNAFPoints(e); h[M] = B.wnd, c[M] = B.points } for (M = n - 1; M >= 1; M -= 2) { var T = M - 1, C = M; if (h[T] !== 1 || h[C] !== 1) { y[T] = Do(i[T], h[T], this._bitLength), y[C] = Do(i[C], h[C], this._bitLength), x = Math.max(y[T].length, x), x = Math.max(y[C].length, x); continue } var H = [r[T], null, null, r[C]]; r[T].y.cmp(r[C].y) === 0 ? (H[1] = r[T].add(r[C]), H[2] = r[T].toJ().mixedAdd(r[C].neg())) : r[T].y.cmp(r[C].y.redNeg()) === 0 ? (H[1] = r[T].toJ().mixedAdd(r[C]), H[2] = r[T].add(r[C].neg())) : (H[1] = r[T].toJ().mixedAdd(r[C]), H[2] = r[T].toJ().mixedAdd(r[C].neg())); var F = [-3, -1, -5, -7, 0, 7, 5, 1, 3], we = X_(i[T], i[C]); for (x = Math.max(we[0].length, x), y[T] = new Array(x), y[C] = new Array(x), E = 0; E < x; E++) { var Be = we[0][E] | 0, xe = we[1][E] | 0; y[T][E] = F[(Be + 1) * 3 + (xe + 1)], y[C][E] = 0, c[T] = H } } var Le = this.jpoint(null, null, null), Me = this._wnafT4; for (M = x; M >= 0; M--) { for (var De = 0; M >= 0;) { var Ie = !0; for (E = 0; E < n; E++)Me[E] = y[E][M] | 0, Me[E] !== 0 && (Ie = !1); if (!Ie) break; De++, M-- } if (M >= 0 && De++, Le = Le.dblp(De), M < 0) break; for (E = 0; E < n; E++) { var je = Me[E]; je !== 0 && (je > 0 ? A = c[E][je - 1 >> 1] : je < 0 && (A = c[E][-je - 1 >> 1].neg()), A.type === "affine" ? Le = Le.mixedAdd(A) : Le = Le.add(A)) } } for (M = 0; M < n; M++)c[M] = null; return f ? Le : Le.toP() }; function Yt(t, e) { this.curve = t, this.type = e, this.precomputed = null } Ki.BasePoint = Yt; Yt.prototype.eq = function () { throw new Error("Not implemented") }; Yt.prototype.validate = function () { return this.curve.validate(this) }; Ki.prototype.decodePoint = function (e, r) { e = kf.toArray(e, r); var i = this.p.byteLength(); if ((e[0] === 4 || e[0] === 6 || e[0] === 7) && e.length - 1 == 2 * i) { e[0] === 6 ? Fo(e[e.length - 1] % 2 == 0) : e[0] === 7 && Fo(e[e.length - 1] % 2 == 1); var n = this.point(e.slice(1, 1 + i), e.slice(1 + i, 1 + 2 * i)); return n } else if ((e[0] === 2 || e[0] === 3) && e.length - 1 === i) return this.pointFromX(e.slice(1, 1 + i), e[0] === 3); throw new Error("Unknown point format") }; Yt.prototype.encodeCompressed = function (e) { return this.encode(e, !0) }; Yt.prototype._encode = function (e) { var r = this.curve.p.byteLength(), i = this.getX().toArray("be", r); return e ? [this.getY().isEven() ? 2 : 3].concat(i) : [4].concat(i, this.getY().toArray("be", r)) }; Yt.prototype.encode = function (e, r) { return kf.encode(this._encode(r), e) }; Yt.prototype.precompute = function (e) { if (this.precomputed) return this; var r = { doubles: null, naf: null, beta: null }; return r.naf = this._getNAFPoints(8), r.doubles = this._getDoubles(4, e), r.beta = this._getBeta(), this.precomputed = r, this }; Yt.prototype._hasDoubles = function (e) { if (!this.precomputed) return !1; var r = this.precomputed.doubles; return r ? r.points.length >= Math.ceil((e.bitLength() + 1) / r.step) : !1 }; Yt.prototype._getDoubles = function (e, r) { if (this.precomputed && this.precomputed.doubles) return this.precomputed.doubles; for (var i = [this], n = this, f = 0; f < r; f += e) { for (var h = 0; h < e; h++)n = n.dbl(); i.push(n) } return { step: e, points: i } }; Yt.prototype._getNAFPoints = function (e) { if (this.precomputed && this.precomputed.naf) return this.precomputed.naf; for (var r = [this], i = (1 << e) - 1, n = i === 1 ? null : this.dbl(), f = 1; f < i; f++)r[f] = r[f - 1].add(n); return { wnd: e, points: r } }; Yt.prototype._getBeta = function () { return null }; Yt.prototype.dblp = function (e) { for (var r = this, i = 0; i < e; i++)r = r.dbl(); return r } }); var V2 = I((UB, K2) => { "use strict"; var Y_ = qt(), Ze = rt(), Gu = Re(), Ma = Pf(), Z_ = Y_.assert; function Zt(t) { Ma.call(this, "short", t), this.a = new Ze(t.a, 16).toRed(this.red), this.b = new Ze(t.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = this.a.fromRed().cmpn(0) === 0, this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0, this.endo = this._getEndomorphism(t), this._endoWnafT1 = new Array(4), this._endoWnafT2 = new Array(4) } Gu(Zt, Ma); K2.exports = Zt; Zt.prototype._getEndomorphism = function (e) { if (!(!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)) { var r, i; if (e.beta) r = new Ze(e.beta, 16).toRed(this.red); else { var n = this._getEndoRoots(this.p); r = n[0].cmp(n[1]) < 0 ? n[0] : n[1], r = r.toRed(this.red) } if (e.lambda) i = new Ze(e.lambda, 16); else { var f = this._getEndoRoots(this.n); this.g.mul(f[0]).x.cmp(this.g.x.redMul(r)) === 0 ? i = f[0] : (i = f[1], Z_(this.g.mul(i).x.cmp(this.g.x.redMul(r)) === 0)) } var h; return e.basis ? h = e.basis.map(function (c) { return { a: new Ze(c.a, 16), b: new Ze(c.b, 16) } }) : h = this._getEndoBasis(i), { beta: r, lambda: i, basis: h } } }; Zt.prototype._getEndoRoots = function (e) { var r = e === this.p ? this.red : Ze.mont(e), i = new Ze(2).toRed(r).redInvm(), n = i.redNeg(), f = new Ze(3).toRed(r).redNeg().redSqrt().redMul(i), h = n.redAdd(f).fromRed(), c = n.redSub(f).fromRed(); return [h, c] }; Zt.prototype._getEndoBasis = function (e) { for (var r = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), i = e, n = this.n.clone(), f = new Ze(1), h = new Ze(0), c = new Ze(0), y = new Ze(1), x, M, E, A, B, T, C, H = 0, F, we; i.cmpn(0) !== 0;) { var Be = n.div(i); F = n.sub(Be.mul(i)), we = c.sub(Be.mul(f)); var xe = y.sub(Be.mul(h)); if (!E && F.cmp(r) < 0) x = C.neg(), M = f, E = F.neg(), A = we; else if (E && ++H == 2) break; C = F, n = i, i = F, c = f, f = we, y = h, h = xe } B = F.neg(), T = we; var Le = E.sqr().add(A.sqr()), Me = B.sqr().add(T.sqr()); return Me.cmp(Le) >= 0 && (B = x, T = M), E.negative && (E = E.neg(), A = A.neg()), B.negative && (B = B.neg(), T = T.neg()), [{ a: E, b: A }, { a: B, b: T }] }; Zt.prototype._endoSplit = function (e) { var r = this.endo.basis, i = r[0], n = r[1], f = n.b.mul(e).divRound(this.n), h = i.b.neg().mul(e).divRound(this.n), c = f.mul(i.a), y = h.mul(n.a), x = f.mul(i.b), M = h.mul(n.b), E = e.sub(c).sub(y), A = x.add(M).neg(); return { k1: E, k2: A } }; Zt.prototype.pointFromX = function (e, r) { e = new Ze(e, 16), e.red || (e = e.toRed(this.red)); var i = e.redSqr().redMul(e).redIAdd(e.redMul(this.a)).redIAdd(this.b), n = i.redSqrt(); if (n.redSqr().redSub(i).cmp(this.zero) !== 0) throw new Error("invalid point"); var f = n.fromRed().isOdd(); return (r && !f || !r && f) && (n = n.redNeg()), this.point(e, n) }; Zt.prototype.validate = function (e) { if (e.inf) return !0; var r = e.x, i = e.y, n = this.a.redMul(r), f = r.redSqr().redMul(r).redIAdd(n).redIAdd(this.b); return i.redSqr().redISub(f).cmpn(0) === 0 }; Zt.prototype._endoWnafMulAdd = function (e, r, i) { for (var n = this._endoWnafT1, f = this._endoWnafT2, h = 0; h < e.length; h++) { var c = this._endoSplit(r[h]), y = e[h], x = y._getBeta(); c.k1.negative && (c.k1.ineg(), y = y.neg(!0)), c.k2.negative && (c.k2.ineg(), x = x.neg(!0)), n[h * 2] = y, n[h * 2 + 1] = x, f[h * 2] = c.k1, f[h * 2 + 1] = c.k2 } for (var M = this._wnafMulAdd(1, n, f, h * 2, i), E = 0; E < h * 2; E++)n[E] = null, f[E] = null; return M }; function st(t, e, r, i) { Ma.BasePoint.call(this, t, "affine"), e === null && r === null ? (this.x = null, this.y = null, this.inf = !0) : (this.x = new Ze(e, 16), this.y = new Ze(r, 16), i && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = !1) } Gu(st, Ma.BasePoint); Zt.prototype.point = function (e, r, i) { return new st(this, e, r, i) }; Zt.prototype.pointFromJSON = function (e, r) { return st.fromJSON(this, e, r) }; st.prototype._getBeta = function () { if (!!this.curve.endo) { var e = this.precomputed; if (e && e.beta) return e.beta; var r = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y); if (e) { var i = this.curve, n = function (f) { return i.point(f.x.redMul(i.endo.beta), f.y) }; e.beta = r, r.precomputed = { beta: null, naf: e.naf && { wnd: e.naf.wnd, points: e.naf.points.map(n) }, doubles: e.doubles && { step: e.doubles.step, points: e.doubles.points.map(n) } } } return r } }; st.prototype.toJSON = function () { return this.precomputed ? [this.x, this.y, this.precomputed && { doubles: this.precomputed.doubles && { step: this.precomputed.doubles.step, points: this.precomputed.doubles.points.slice(1) }, naf: this.precomputed.naf && { wnd: this.precomputed.naf.wnd, points: this.precomputed.naf.points.slice(1) } }] : [this.x, this.y] }; st.fromJSON = function (e, r, i) { typeof r == "string" && (r = JSON.parse(r)); var n = e.point(r[0], r[1], i); if (!r[2]) return n; function f(c) { return e.point(c[0], c[1], i) } var h = r[2]; return n.precomputed = { beta: null, doubles: h.doubles && { step: h.doubles.step, points: [n].concat(h.doubles.points.map(f)) }, naf: h.naf && { wnd: h.naf.wnd, points: [n].concat(h.naf.points.map(f)) } }, n }; st.prototype.inspect = function () { return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">" }; st.prototype.isInfinity = function () { return this.inf }; st.prototype.add = function (e) { if (this.inf) return e; if (e.inf) return this; if (this.eq(e)) return this.dbl(); if (this.neg().eq(e)) return this.curve.point(null, null); if (this.x.cmp(e.x) === 0) return this.curve.point(null, null); var r = this.y.redSub(e.y); r.cmpn(0) !== 0 && (r = r.redMul(this.x.redSub(e.x).redInvm())); var i = r.redSqr().redISub(this.x).redISub(e.x), n = r.redMul(this.x.redSub(i)).redISub(this.y); return this.curve.point(i, n) }; st.prototype.dbl = function () { if (this.inf) return this; var e = this.y.redAdd(this.y); if (e.cmpn(0) === 0) return this.curve.point(null, null); var r = this.curve.a, i = this.x.redSqr(), n = e.redInvm(), f = i.redAdd(i).redIAdd(i).redIAdd(r).redMul(n), h = f.redSqr().redISub(this.x.redAdd(this.x)), c = f.redMul(this.x.redSub(h)).redISub(this.y); return this.curve.point(h, c) }; st.prototype.getX = function () { return this.x.fromRed() }; st.prototype.getY = function () { return this.y.fromRed() }; st.prototype.mul = function (e) { return e = new Ze(e, 16), this.isInfinity() ? this : this._hasDoubles(e) ? this.curve._fixedNafMul(this, e) : this.curve.endo ? this.curve._endoWnafMulAdd([this], [e]) : this.curve._wnafMul(this, e) }; st.prototype.mulAdd = function (e, r, i) { var n = [this, r], f = [e, i]; return this.curve.endo ? this.curve._endoWnafMulAdd(n, f) : this.curve._wnafMulAdd(1, n, f, 2) }; st.prototype.jmulAdd = function (e, r, i) { var n = [this, r], f = [e, i]; return this.curve.endo ? this.curve._endoWnafMulAdd(n, f, !0) : this.curve._wnafMulAdd(1, n, f, 2, !0) }; st.prototype.eq = function (e) { return this === e || this.inf === e.inf && (this.inf || this.x.cmp(e.x) === 0 && this.y.cmp(e.y) === 0) }; st.prototype.neg = function (e) { if (this.inf) return this; var r = this.curve.point(this.x, this.y.redNeg()); if (e && this.precomputed) { var i = this.precomputed, n = function (f) { return f.neg() }; r.precomputed = { naf: i.naf && { wnd: i.naf.wnd, points: i.naf.points.map(n) }, doubles: i.doubles && { step: i.doubles.step, points: i.doubles.points.map(n) } } } return r }; st.prototype.toJ = function () { if (this.inf) return this.curve.jpoint(null, null, null); var e = this.curve.jpoint(this.x, this.y, this.curve.one); return e }; function lt(t, e, r, i) { Ma.BasePoint.call(this, t, "jacobian"), e === null && r === null && i === null ? (this.x = this.curve.one, this.y = this.curve.one, this.z = new Ze(0)) : (this.x = new Ze(e, 16), this.y = new Ze(r, 16), this.z = new Ze(i, 16)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z === this.curve.one } Gu(lt, Ma.BasePoint); Zt.prototype.jpoint = function (e, r, i) { return new lt(this, e, r, i) }; lt.prototype.toP = function () { if (this.isInfinity()) return this.curve.point(null, null); var e = this.z.redInvm(), r = e.redSqr(), i = this.x.redMul(r), n = this.y.redMul(r).redMul(e); return this.curve.point(i, n) }; lt.prototype.neg = function () { return this.curve.jpoint(this.x, this.y.redNeg(), this.z) }; lt.prototype.add = function (e) { if (this.isInfinity()) return e; if (e.isInfinity()) return this; var r = e.z.redSqr(), i = this.z.redSqr(), n = this.x.redMul(r), f = e.x.redMul(i), h = this.y.redMul(r.redMul(e.z)), c = e.y.redMul(i.redMul(this.z)), y = n.redSub(f), x = h.redSub(c); if (y.cmpn(0) === 0) return x.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl(); var M = y.redSqr(), E = M.redMul(y), A = n.redMul(M), B = x.redSqr().redIAdd(E).redISub(A).redISub(A), T = x.redMul(A.redISub(B)).redISub(h.redMul(E)), C = this.z.redMul(e.z).redMul(y); return this.curve.jpoint(B, T, C) }; lt.prototype.mixedAdd = function (e) { if (this.isInfinity()) return e.toJ(); if (e.isInfinity()) return this; var r = this.z.redSqr(), i = this.x, n = e.x.redMul(r), f = this.y, h = e.y.redMul(r).redMul(this.z), c = i.redSub(n), y = f.redSub(h); if (c.cmpn(0) === 0) return y.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl(); var x = c.redSqr(), M = x.redMul(c), E = i.redMul(x), A = y.redSqr().redIAdd(M).redISub(E).redISub(E), B = y.redMul(E.redISub(A)).redISub(f.redMul(M)), T = this.z.redMul(c); return this.curve.jpoint(A, B, T) }; lt.prototype.dblp = function (e) { if (e === 0) return this; if (this.isInfinity()) return this; if (!e) return this.dbl(); var r; if (this.curve.zeroA || this.curve.threeA) { var i = this; for (r = 0; r < e; r++)i = i.dbl(); return i } var n = this.curve.a, f = this.curve.tinv, h = this.x, c = this.y, y = this.z, x = y.redSqr().redSqr(), M = c.redAdd(c); for (r = 0; r < e; r++) { var E = h.redSqr(), A = M.redSqr(), B = A.redSqr(), T = E.redAdd(E).redIAdd(E).redIAdd(n.redMul(x)), C = h.redMul(A), H = T.redSqr().redISub(C.redAdd(C)), F = C.redISub(H), we = T.redMul(F); we = we.redIAdd(we).redISub(B); var Be = M.redMul(y); r + 1 < e && (x = x.redMul(B)), h = H, y = Be, M = we } return this.curve.jpoint(h, M.redMul(f), y) }; lt.prototype.dbl = function () { return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl() }; lt.prototype._zeroDbl = function () { var e, r, i; if (this.zOne) { var n = this.x.redSqr(), f = this.y.redSqr(), h = f.redSqr(), c = this.x.redAdd(f).redSqr().redISub(n).redISub(h); c = c.redIAdd(c); var y = n.redAdd(n).redIAdd(n), x = y.redSqr().redISub(c).redISub(c), M = h.redIAdd(h); M = M.redIAdd(M), M = M.redIAdd(M), e = x, r = y.redMul(c.redISub(x)).redISub(M), i = this.y.redAdd(this.y) } else { var E = this.x.redSqr(), A = this.y.redSqr(), B = A.redSqr(), T = this.x.redAdd(A).redSqr().redISub(E).redISub(B); T = T.redIAdd(T); var C = E.redAdd(E).redIAdd(E), H = C.redSqr(), F = B.redIAdd(B); F = F.redIAdd(F), F = F.redIAdd(F), e = H.redISub(T).redISub(T), r = C.redMul(T.redISub(e)).redISub(F), i = this.y.redMul(this.z), i = i.redIAdd(i) } return this.curve.jpoint(e, r, i) }; lt.prototype._threeDbl = function () { var e, r, i; if (this.zOne) { var n = this.x.redSqr(), f = this.y.redSqr(), h = f.redSqr(), c = this.x.redAdd(f).redSqr().redISub(n).redISub(h); c = c.redIAdd(c); var y = n.redAdd(n).redIAdd(n).redIAdd(this.curve.a), x = y.redSqr().redISub(c).redISub(c); e = x; var M = h.redIAdd(h); M = M.redIAdd(M), M = M.redIAdd(M), r = y.redMul(c.redISub(x)).redISub(M), i = this.y.redAdd(this.y) } else { var E = this.z.redSqr(), A = this.y.redSqr(), B = this.x.redMul(A), T = this.x.redSub(E).redMul(this.x.redAdd(E)); T = T.redAdd(T).redIAdd(T); var C = B.redIAdd(B); C = C.redIAdd(C); var H = C.redAdd(C); e = T.redSqr().redISub(H), i = this.y.redAdd(this.z).redSqr().redISub(A).redISub(E); var F = A.redSqr(); F = F.redIAdd(F), F = F.redIAdd(F), F = F.redIAdd(F), r = T.redMul(C.redISub(e)).redISub(F) } return this.curve.jpoint(e, r, i) }; lt.prototype._dbl = function () { var e = this.curve.a, r = this.x, i = this.y, n = this.z, f = n.redSqr().redSqr(), h = r.redSqr(), c = i.redSqr(), y = h.redAdd(h).redIAdd(h).redIAdd(e.redMul(f)), x = r.redAdd(r); x = x.redIAdd(x); var M = x.redMul(c), E = y.redSqr().redISub(M.redAdd(M)), A = M.redISub(E), B = c.redSqr(); B = B.redIAdd(B), B = B.redIAdd(B), B = B.redIAdd(B); var T = y.redMul(A).redISub(B), C = i.redAdd(i).redMul(n); return this.curve.jpoint(E, T, C) }; lt.prototype.trpl = function () { if (!this.curve.zeroA) return this.dbl().add(this); var e = this.x.redSqr(), r = this.y.redSqr(), i = this.z.redSqr(), n = r.redSqr(), f = e.redAdd(e).redIAdd(e), h = f.redSqr(), c = this.x.redAdd(r).redSqr().redISub(e).redISub(n); c = c.redIAdd(c), c = c.redAdd(c).redIAdd(c), c = c.redISub(h); var y = c.redSqr(), x = n.redIAdd(n); x = x.redIAdd(x), x = x.redIAdd(x), x = x.redIAdd(x); var M = f.redIAdd(c).redSqr().redISub(h).redISub(y).redISub(x), E = r.redMul(M); E = E.redIAdd(E), E = E.redIAdd(E); var A = this.x.redMul(y).redISub(E); A = A.redIAdd(A), A = A.redIAdd(A); var B = this.y.redMul(M.redMul(x.redISub(M)).redISub(c.redMul(y))); B = B.redIAdd(B), B = B.redIAdd(B), B = B.redIAdd(B); var T = this.z.redAdd(c).redSqr().redISub(i).redISub(y); return this.curve.jpoint(A, B, T) }; lt.prototype.mul = function (e, r) { return e = new Ze(e, r), this.curve._wnafMul(this, e) }; lt.prototype.eq = function (e) { if (e.type === "affine") return this.eq(e.toJ()); if (this === e) return !0; var r = this.z.redSqr(), i = e.z.redSqr(); if (this.x.redMul(i).redISub(e.x.redMul(r)).cmpn(0) !== 0) return !1; var n = r.redMul(this.z), f = i.redMul(e.z); return this.y.redMul(f).redISub(e.y.redMul(n)).cmpn(0) === 0 }; lt.prototype.eqXToP = function (e) { var r = this.z.redSqr(), i = e.toRed(this.curve.red).redMul(r); if (this.x.cmp(i) === 0) return !0; for (var n = e.clone(), f = this.curve.redN.redMul(r); ;) { if (n.iadd(this.curve.n), n.cmp(this.curve.p) >= 0) return !1; if (i.redIAdd(f), this.x.cmp(i) === 0) return !0 } }; lt.prototype.inspect = function () { return this.isInfinity() ? "<EC JPoint Infinity>" : "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">" }; lt.prototype.isInfinity = function () { return this.z.cmpn(0) === 0 } }); var X2 = I((NB, $2) => { "use strict"; var Sa = rt(), G2 = Re(), Uo = Pf(), J_ = qt(); function Ea(t) { Uo.call(this, "mont", t), this.a = new Sa(t.a, 16).toRed(this.red), this.b = new Sa(t.b, 16).toRed(this.red), this.i4 = new Sa(4).toRed(this.red).redInvm(), this.two = new Sa(2).toRed(this.red), this.a24 = this.i4.redMul(this.a.redAdd(this.two)) } G2(Ea, Uo); $2.exports = Ea; Ea.prototype.validate = function (e) { var r = e.normalize().x, i = r.redSqr(), n = i.redMul(r).redAdd(i.redMul(this.a)).redAdd(r), f = n.redSqrt(); return f.redSqr().cmp(n) === 0 }; function ot(t, e, r) { Uo.BasePoint.call(this, t, "projective"), e === null && r === null ? (this.x = this.curve.one, this.z = this.curve.zero) : (this.x = new Sa(e, 16), this.z = new Sa(r, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red))) } G2(ot, Uo.BasePoint); Ea.prototype.decodePoint = function (e, r) { return this.point(J_.toArray(e, r), 1) }; Ea.prototype.point = function (e, r) { return new ot(this, e, r) }; Ea.prototype.pointFromJSON = function (e) { return ot.fromJSON(this, e) }; ot.prototype.precompute = function () { }; ot.prototype._encode = function () { return this.getX().toArray("be", this.curve.p.byteLength()) }; ot.fromJSON = function (e, r) { return new ot(e, r[0], r[1] || e.one) }; ot.prototype.inspect = function () { return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">" }; ot.prototype.isInfinity = function () { return this.z.cmpn(0) === 0 }; ot.prototype.dbl = function () { var e = this.x.redAdd(this.z), r = e.redSqr(), i = this.x.redSub(this.z), n = i.redSqr(), f = r.redSub(n), h = r.redMul(n), c = f.redMul(n.redAdd(this.curve.a24.redMul(f))); return this.curve.point(h, c) }; ot.prototype.add = function () { throw new Error("Not supported on Montgomery curve") }; ot.prototype.diffAdd = function (e, r) { var i = this.x.redAdd(this.z), n = this.x.redSub(this.z), f = e.x.redAdd(e.z), h = e.x.redSub(e.z), c = h.redMul(i), y = f.redMul(n), x = r.z.redMul(c.redAdd(y).redSqr()), M = r.x.redMul(c.redISub(y).redSqr()); return this.curve.point(x, M) }; ot.prototype.mul = function (e) { for (var r = e.clone(), i = this, n = this.curve.point(null, null), f = this, h = []; r.cmpn(0) !== 0; r.iushrn(1))h.push(r.andln(1)); for (var c = h.length - 1; c >= 0; c--)h[c] === 0 ? (i = i.diffAdd(n, f), n = n.dbl()) : (n = i.diffAdd(n, f), i = i.dbl()); return n }; ot.prototype.mulAdd = function () { throw new Error("Not supported on Montgomery curve") }; ot.prototype.jumlAdd = function () { throw new Error("Not supported on Montgomery curve") }; ot.prototype.eq = function (e) { return this.getX().cmp(e.getX()) === 0 }; ot.prototype.normalize = function () { return this.x = this.x.redMul(this.z.redInvm()), this.z = this.curve.one, this }; ot.prototype.getX = function () { return this.normalize(), this.x.fromRed() } }); var J2 = I((LB, Z2) => { "use strict"; var Q_ = qt(), ai = rt(), Y2 = Re(), No = Pf(), ex = Q_.assert; function Or(t) { this.twisted = (t.a | 0) != 1, this.mOneA = this.twisted && (t.a | 0) == -1, this.extended = this.mOneA, No.call(this, "edwards", t), this.a = new ai(t.a, 16).umod(this.red.m), this.a = this.a.toRed(this.red), this.c = new ai(t.c, 16).toRed(this.red), this.c2 = this.c.redSqr(), this.d = new ai(t.d, 16).toRed(this.red), this.dd = this.d.redAdd(this.d), ex(!this.twisted || this.c.fromRed().cmpn(1) === 0), this.oneC = (t.c | 0) == 1 } Y2(Or, No); Z2.exports = Or; Or.prototype._mulA = function (e) { return this.mOneA ? e.redNeg() : this.a.redMul(e) }; Or.prototype._mulC = function (e) { return this.oneC ? e : this.c.redMul(e) }; Or.prototype.jpoint = function (e, r, i, n) { return this.point(e, r, i, n) }; Or.prototype.pointFromX = function (e, r) { e = new ai(e, 16), e.red || (e = e.toRed(this.red)); var i = e.redSqr(), n = this.c2.redSub(this.a.redMul(i)), f = this.one.redSub(this.c2.redMul(this.d).redMul(i)), h = n.redMul(f.redInvm()), c = h.redSqrt(); if (c.redSqr().redSub(h).cmp(this.zero) !== 0) throw new Error("invalid point"); var y = c.fromRed().isOdd(); return (r && !y || !r && y) && (c = c.redNeg()), this.point(e, c) }; Or.prototype.pointFromY = function (e, r) { e = new ai(e, 16), e.red || (e = e.toRed(this.red)); var i = e.redSqr(), n = i.redSub(this.c2), f = i.redMul(this.d).redMul(this.c2).redSub(this.a), h = n.redMul(f.redInvm()); if (h.cmp(this.zero) === 0) { if (r) throw new Error("invalid point"); return this.point(this.zero, e) } var c = h.redSqrt(); if (c.redSqr().redSub(h).cmp(this.zero) !== 0) throw new Error("invalid point"); return c.fromRed().isOdd() !== r && (c = c.redNeg()), this.point(c, e) }; Or.prototype.validate = function (e) { if (e.isInfinity()) return !0; e.normalize(); var r = e.x.redSqr(), i = e.y.redSqr(), n = r.redMul(this.a).redAdd(i), f = this.c2.redMul(this.one.redAdd(this.d.redMul(r).redMul(i))); return n.cmp(f) === 0 }; function Ve(t, e, r, i, n) { No.BasePoint.call(this, t, "projective"), e === null && r === null && i === null ? (this.x = this.curve.zero, this.y = this.curve.one, this.z = this.curve.one, this.t = this.curve.zero, this.zOne = !0) : (this.x = new ai(e, 16), this.y = new ai(r, 16), this.z = i ? new ai(i, 16) : this.curve.one, this.t = n && new ai(n, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.t && !this.t.red && (this.t = this.t.toRed(this.curve.red)), this.zOne = this.z === this.curve.one, this.curve.extended && !this.t && (this.t = this.x.redMul(this.y), this.zOne || (this.t = this.t.redMul(this.z.redInvm())))) } Y2(Ve, No.BasePoint); Or.prototype.pointFromJSON = function (e) { return Ve.fromJSON(this, e) }; Or.prototype.point = function (e, r, i, n) { return new Ve(this, e, r, i, n) }; Ve.fromJSON = function (e, r) { return new Ve(e, r[0], r[1], r[2]) }; Ve.prototype.inspect = function () { return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">" }; Ve.prototype.isInfinity = function () { return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0) }; Ve.prototype._extDbl = function () { var e = this.x.redSqr(), r = this.y.redSqr(), i = this.z.redSqr(); i = i.redIAdd(i); var n = this.curve._mulA(e), f = this.x.redAdd(this.y).redSqr().redISub(e).redISub(r), h = n.redAdd(r), c = h.redSub(i), y = n.redSub(r), x = f.redMul(c), M = h.redMul(y), E = f.redMul(y), A = c.redMul(h); return this.curve.point(x, M, A, E) }; Ve.prototype._projDbl = function () { var e = this.x.redAdd(this.y).redSqr(), r = this.x.redSqr(), i = this.y.redSqr(), n, f, h, c, y, x; if (this.curve.twisted) { c = this.curve._mulA(r); var M = c.redAdd(i); this.zOne ? (n = e.redSub(r).redSub(i).redMul(M.redSub(this.curve.two)), f = M.redMul(c.redSub(i)), h = M.redSqr().redSub(M).redSub(M)) : (y = this.z.redSqr(), x = M.redSub(y).redISub(y), n = e.redSub(r).redISub(i).redMul(x), f = M.redMul(c.redSub(i)), h = M.redMul(x)) } else c = r.redAdd(i), y = this.curve._mulC(this.z).redSqr(), x = c.redSub(y).redSub(y), n = this.curve._mulC(e.redISub(c)).redMul(x), f = this.curve._mulC(c).redMul(r.redISub(i)), h = c.redMul(x); return this.curve.point(n, f, h) }; Ve.prototype.dbl = function () { return this.isInfinity() ? this : this.curve.extended ? this._extDbl() : this._projDbl() }; Ve.prototype._extAdd = function (e) { var r = this.y.redSub(this.x).redMul(e.y.redSub(e.x)), i = this.y.redAdd(this.x).redMul(e.y.redAdd(e.x)), n = this.t.redMul(this.curve.dd).redMul(e.t), f = this.z.redMul(e.z.redAdd(e.z)), h = i.redSub(r), c = f.redSub(n), y = f.redAdd(n), x = i.redAdd(r), M = h.redMul(c), E = y.redMul(x), A = h.redMul(x), B = c.redMul(y); return this.curve.point(M, E, B, A) }; Ve.prototype._projAdd = function (e) { var r = this.z.redMul(e.z), i = r.redSqr(), n = this.x.redMul(e.x), f = this.y.redMul(e.y), h = this.curve.d.redMul(n).redMul(f), c = i.redSub(h), y = i.redAdd(h), x = this.x.redAdd(this.y).redMul(e.x.redAdd(e.y)).redISub(n).redISub(f), M = r.redMul(c).redMul(x), E, A; return this.curve.twisted ? (E = r.redMul(y).redMul(f.redSub(this.curve._mulA(n))), A = c.redMul(y)) : (E = r.redMul(y).redMul(f.redSub(n)), A = this.curve._mulC(c).redMul(y)), this.curve.point(M, E, A) }; Ve.prototype.add = function (e) { return this.isInfinity() ? e : e.isInfinity() ? this : this.curve.extended ? this._extAdd(e) : this._projAdd(e) }; Ve.prototype.mul = function (e) { return this._hasDoubles(e) ? this.curve._fixedNafMul(this, e) : this.curve._wnafMul(this, e) }; Ve.prototype.mulAdd = function (e, r, i) { return this.curve._wnafMulAdd(1, [this, r], [e, i], 2, !1) }; Ve.prototype.jmulAdd = function (e, r, i) { return this.curve._wnafMulAdd(1, [this, r], [e, i], 2, !0) }; Ve.prototype.normalize = function () { if (this.zOne) return this; var e = this.z.redInvm(); return this.x = this.x.redMul(e), this.y = this.y.redMul(e), this.t && (this.t = this.t.redMul(e)), this.z = this.curve.one, this.zOne = !0, this }; Ve.prototype.neg = function () { return this.curve.point(this.x.redNeg(), this.y, this.z, this.t && this.t.redNeg()) }; Ve.prototype.getX = function () { return this.normalize(), this.x.fromRed() }; Ve.prototype.getY = function () { return this.normalize(), this.y.fromRed() }; Ve.prototype.eq = function (e) { return this === e || this.getX().cmp(e.getX()) === 0 && this.getY().cmp(e.getY()) === 0 }; Ve.prototype.eqXToP = function (e) { var r = e.toRed(this.curve.red).redMul(this.z); if (this.x.cmp(r) === 0) return !0; for (var i = e.clone(), n = this.curve.redN.redMul(this.z); ;) { if (i.iadd(this.curve.n), i.cmp(this.curve.p) >= 0) return !1; if (r.redIAdd(n), this.x.cmp(r) === 0) return !0 } }; Ve.prototype.toP = Ve.prototype.normalize; Ve.prototype.mixedAdd = Ve.prototype.add }); var $u = I(Q2 => { "use strict"; var Lo = Q2; Lo.base = Pf(); Lo.short = V2(); Lo.mont = X2(); Lo.edwards = J2() }); var Ar = I(Ke => { "use strict"; var tx = Tt(), rx = Re(); Ke.inherits = rx; function ix(t, e) { return (t.charCodeAt(e) & 64512) != 55296 || e < 0 || e + 1 >= t.length ? !1 : (t.charCodeAt(e + 1) & 64512) == 56320 } function nx(t, e) { if (Array.isArray(t)) return t.slice(); if (!t) return []; var r = []; if (typeof t == "string") if (e) { if (e === "hex") for (t = t.replace(/[^a-z0-9]+/ig, ""), t.length % 2 != 0 && (t = "0" + t), n = 0; n < t.length; n += 2)r.push(parseInt(t[n] + t[n + 1], 16)) } else for (var i = 0, n = 0; n < t.length; n++) { var f = t.charCodeAt(n); f < 128 ? r[i++] = f : f < 2048 ? (r[i++] = f >> 6 | 192, r[i++] = f & 63 | 128) : ix(t, n) ? (f = 65536 + ((f & 1023) << 10) + (t.charCodeAt(++n) & 1023), r[i++] = f >> 18 | 240, r[i++] = f >> 12 & 63 | 128, r[i++] = f >> 6 & 63 | 128, r[i++] = f & 63 | 128) : (r[i++] = f >> 12 | 224, r[i++] = f >> 6 & 63 | 128, r[i++] = f & 63 | 128) } else for (n = 0; n < t.length; n++)r[n] = t[n] | 0; return r } Ke.toArray = nx; function ax(t) { for (var e = "", r = 0; r < t.length; r++)e += ty(t[r].toString(16)); return e } Ke.toHex = ax; function ey(t) { var e = t >>> 24 | t >>> 8 & 65280 | t << 8 & 16711680 | (t & 255) << 24; return e >>> 0 } Ke.htonl = ey; function fx(t, e) { for (var r = "", i = 0; i < t.length; i++) { var n = t[i]; e === "little" && (n = ey(n)), r += ry(n.toString(16)) } return r } Ke.toHex32 = fx; function ty(t) { return t.length === 1 ? "0" + t : t } Ke.zero2 = ty; function ry(t) { return t.length === 7 ? "0" + t : t.length === 6 ? "00" + t : t.length === 5 ? "000" + t : t.length === 4 ? "0000" + t : t.length === 3 ? "00000" + t : t.length === 2 ? "000000" + t : t.length === 1 ? "0000000" + t : t } Ke.zero8 = ry; function sx(t, e, r, i) { var n = r - e; tx(n % 4 == 0); for (var f = new Array(n / 4), h = 0, c = e; h < f.length; h++, c += 4) { var y; i === "big" ? y = t[c] << 24 | t[c + 1] << 16 | t[c + 2] << 8 | t[c + 3] : y = t[c + 3] << 24 | t[c + 2] << 16 | t[c + 1] << 8 | t[c], f[h] = y >>> 0 } return f } Ke.join32 = sx; function ox(t, e) { for (var r = new Array(t.length * 4), i = 0, n = 0; i < t.length; i++, n += 4) { var f = t[i]; e === "big" ? (r[n] = f >>> 24, r[n + 1] = f >>> 16 & 255, r[n + 2] = f >>> 8 & 255, r[n + 3] = f & 255) : (r[n + 3] = f >>> 24, r[n + 2] = f >>> 16 & 255, r[n + 1] = f >>> 8 & 255, r[n] = f & 255) } return r } Ke.split32 = ox; function hx(t, e) { return t >>> e | t << 32 - e } Ke.rotr32 = hx; function ux(t, e) { return t << e | t >>> 32 - e } Ke.rotl32 = ux; function cx(t, e) { return t + e >>> 0 } Ke.sum32 = cx; function dx(t, e, r) { return t + e + r >>> 0 } Ke.sum32_3 = dx; function lx(t, e, r, i) { return t + e + r + i >>> 0 } Ke.sum32_4 = lx; function px(t, e, r, i, n) { return t + e + r + i + n >>> 0 } Ke.sum32_5 = px; function vx(t, e, r, i) { var n = t[e], f = t[e + 1], h = i + f >>> 0, c = (h < i ? 1 : 0) + r + n; t[e] = c >>> 0, t[e + 1] = h } Ke.sum64 = vx; function bx(t, e, r, i) { var n = e + i >>> 0, f = (n < e ? 1 : 0) + t + r; return f >>> 0 } Ke.sum64_hi = bx; function yx(t, e, r, i) { var n = e + i; return n >>> 0 } Ke.sum64_lo = yx; function mx(t, e, r, i, n, f, h, c) { var y = 0, x = e; x = x + i >>> 0, y += x < e ? 1 : 0, x = x + f >>> 0, y += x < f ? 1 : 0, x = x + c >>> 0, y += x < c ? 1 : 0; var M = t + r + n + h + y; return M >>> 0 } Ke.sum64_4_hi = mx; function gx(t, e, r, i, n, f, h, c) { var y = e + i + f + c; return y >>> 0 } Ke.sum64_4_lo = gx; function wx(t, e, r, i, n, f, h, c, y, x) { var M = 0, E = e; E = E + i >>> 0, M += E < e ? 1 : 0, E = E + f >>> 0, M += E < f ? 1 : 0, E = E + c >>> 0, M += E < c ? 1 : 0, E = E + x >>> 0, M += E < x ? 1 : 0; var A = t + r + n + h + y + M; return A >>> 0 } Ke.sum64_5_hi = wx; function _x(t, e, r, i, n, f, h, c, y, x) { var M = e + i + f + c + x; return M >>> 0 } Ke.sum64_5_lo = _x; function xx(t, e, r) { var i = e << 32 - r | t >>> r; return i >>> 0 } Ke.rotr64_hi = xx; function Mx(t, e, r) { var i = t << 32 - r | e >>> r; return i >>> 0 } Ke.rotr64_lo = Mx; function Sx(t, e, r) { return t >>> r } Ke.shr64_hi = Sx; function Ex(t, e, r) { var i = t << 32 - r | e >>> r; return i >>> 0 } Ke.shr64_lo = Ex }); var Aa = I(ny => { "use strict"; var iy = Ar(), Ax = Tt(); function Ho() { this.pending = null, this.pendingTotal = 0, this.blockSize = this.constructor.blockSize, this.outSize = this.constructor.outSize, this.hmacStrength = this.constructor.hmacStrength, this.padLength = this.constructor.padLength / 8, this.endian = "big", this._delta8 = this.blockSize / 8, this._delta32 = this.blockSize / 32 } ny.BlockHash = Ho; Ho.prototype.update = function (e, r) { if (e = iy.toArray(e, r), this.pending ? this.pending = this.pending.concat(e) : this.pending = e, this.pendingTotal += e.length, this.pending.length >= this._delta8) { e = this.pending; var i = e.length % this._delta8; this.pending = e.slice(e.length - i, e.length), this.pending.length === 0 && (this.pending = null), e = iy.join32(e, 0, e.length - i, this.endian); for (var n = 0; n < e.length; n += this._delta32)this._update(e, n, n + this._delta32) } return this }; Ho.prototype.digest = function (e) { return this.update(this._pad()), Ax(this.pending === null), this._digest(e) }; Ho.prototype._pad = function () { var e = this.pendingTotal, r = this._delta8, i = r - (e + this.padLength) % r, n = new Array(i + this.padLength); n[0] = 128; for (var f = 1; f < i; f++)n[f] = 0; if (e <<= 3, this.endian === "big") { for (var h = 8; h < this.padLength; h++)n[f++] = 0; n[f++] = 0, n[f++] = 0, n[f++] = 0, n[f++] = 0, n[f++] = e >>> 24 & 255, n[f++] = e >>> 16 & 255, n[f++] = e >>> 8 & 255, n[f++] = e & 255 } else for (n[f++] = e & 255, n[f++] = e >>> 8 & 255, n[f++] = e >>> 16 & 255, n[f++] = e >>> 24 & 255, n[f++] = 0, n[f++] = 0, n[f++] = 0, n[f++] = 0, h = 8; h < this.padLength; h++)n[f++] = 0; return n } }); var Xu = I(fi => { "use strict"; var Bx = Ar(), Dr = Bx.rotr32; function Ix(t, e, r, i) { if (t === 0) return ay(e, r, i); if (t === 1 || t === 3) return sy(e, r, i); if (t === 2) return fy(e, r, i) } fi.ft_1 = Ix; function ay(t, e, r) { return t & e ^ ~t & r } fi.ch32 = ay; function fy(t, e, r) { return t & e ^ t & r ^ e & r } fi.maj32 = fy; function sy(t, e, r) { return t ^ e ^ r } fi.p32 = sy; function Rx(t) { return Dr(t, 2) ^ Dr(t, 13) ^ Dr(t, 22) } fi.s0_256 = Rx; function Tx(t) { return Dr(t, 6) ^ Dr(t, 11) ^ Dr(t, 25) } fi.s1_256 = Tx; function qx(t) { return Dr(t, 7) ^ Dr(t, 18) ^ t >>> 3 } fi.g0_256 = qx; function kx(t) { return Dr(t, 17) ^ Dr(t, 19) ^ t >>> 10 } fi.g1_256 = kx }); var uy = I((KB, hy) => { "use strict"; var Ba = Ar(), Px = Aa(), Cx = Xu(), Yu = Ba.rotl32, Cf = Ba.sum32, Ox = Ba.sum32_5, Dx = Cx.ft_1, oy = Px.BlockHash, Fx = [1518500249, 1859775393, 2400959708, 3395469782]; function Fr() { if (!(this instanceof Fr)) return new Fr; oy.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.W = new Array(80) } Ba.inherits(Fr, oy); hy.exports = Fr; Fr.blockSize = 512; Fr.outSize = 160; Fr.hmacStrength = 80; Fr.padLength = 64; Fr.prototype._update = function (e, r) { for (var i = this.W, n = 0; n < 16; n++)i[n] = e[r + n]; for (; n < i.length; n++)i[n] = Yu(i[n - 3] ^ i[n - 8] ^ i[n - 14] ^ i[n - 16], 1); var f = this.h[0], h = this.h[1], c = this.h[2], y = this.h[3], x = this.h[4]; for (n = 0; n < i.length; n++) { var M = ~~(n / 20), E = Ox(Yu(f, 5), Dx(M, h, c, y), x, i[n], Fx[M]); x = y, y = c, c = Yu(h, 30), h = f, f = E } this.h[0] = Cf(this.h[0], f), this.h[1] = Cf(this.h[1], h), this.h[2] = Cf(this.h[2], c), this.h[3] = Cf(this.h[3], y), this.h[4] = Cf(this.h[4], x) }; Fr.prototype._digest = function (e) { return e === "hex" ? Ba.toHex32(this.h, "big") : Ba.split32(this.h, "big") } }); var Zu = I((VB, dy) => { "use strict"; var Ia = Ar(), Ux = Aa(), Ra = Xu(), Nx = Tt(), Br = Ia.sum32, Lx = Ia.sum32_4, Hx = Ia.sum32_5, jx = Ra.ch32, zx = Ra.maj32, Wx = Ra.s0_256, Kx = Ra.s1_256, Vx = Ra.g0_256, Gx = Ra.g1_256, cy = Ux.BlockHash, $x = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]; function Ur() { if (!(this instanceof Ur)) return new Ur; cy.call(this), this.h = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225], this.k = $x, this.W = new Array(64) } Ia.inherits(Ur, cy); dy.exports = Ur; Ur.blockSize = 512; Ur.outSize = 256; Ur.hmacStrength = 192; Ur.padLength = 64; Ur.prototype._update = function (e, r) { for (var i = this.W, n = 0; n < 16; n++)i[n] = e[r + n]; for (; n < i.length; n++)i[n] = Lx(Gx(i[n - 2]), i[n - 7], Vx(i[n - 15]), i[n - 16]); var f = this.h[0], h = this.h[1], c = this.h[2], y = this.h[3], x = this.h[4], M = this.h[5], E = this.h[6], A = this.h[7]; for (Nx(this.k.length === i.length), n = 0; n < i.length; n++) { var B = Hx(A, Kx(x), jx(x, M, E), this.k[n], i[n]), T = Br(Wx(f), zx(f, h, c)); A = E, E = M, M = x, x = Br(y, B), y = c, c = h, h = f, f = Br(B, T) } this.h[0] = Br(this.h[0], f), this.h[1] = Br(this.h[1], h), this.h[2] = Br(this.h[2], c), this.h[3] = Br(this.h[3], y), this.h[4] = Br(this.h[4], x), this.h[5] = Br(this.h[5], M), this.h[6] = Br(this.h[6], E), this.h[7] = Br(this.h[7], A) }; Ur.prototype._digest = function (e) { return e === "hex" ? Ia.toHex32(this.h, "big") : Ia.split32(this.h, "big") } }); var vy = I((GB, py) => { "use strict"; var Ju = Ar(), ly = Zu(); function si() { if (!(this instanceof si)) return new si; ly.call(this), this.h = [3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428] } Ju.inherits(si, ly); py.exports = si; si.blockSize = 512; si.outSize = 224; si.hmacStrength = 192; si.padLength = 64; si.prototype._digest = function (e) { return e === "hex" ? Ju.toHex32(this.h.slice(0, 7), "big") : Ju.split32(this.h.slice(0, 7), "big") } }); var tc = I(($B, gy) => { "use strict"; var Bt = Ar(), Xx = Aa(), Yx = Tt(), Nr = Bt.rotr64_hi, Lr = Bt.rotr64_lo, by = Bt.shr64_hi, yy = Bt.shr64_lo, Vi = Bt.sum64, Qu = Bt.sum64_hi, ec = Bt.sum64_lo, Zx = Bt.sum64_4_hi, Jx = Bt.sum64_4_lo, Qx = Bt.sum64_5_hi, eM = Bt.sum64_5_lo, my = Xx.BlockHash, tM = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591]; function Ir() { if (!(this instanceof Ir)) return new Ir; my.call(this), this.h = [1779033703, 4089235720, 3144134277, 2227873595, 1013904242, 4271175723, 2773480762, 1595750129, 1359893119, 2917565137, 2600822924, 725511199, 528734635, 4215389547, 1541459225, 327033209], this.k = tM, this.W = new Array(160) } Bt.inherits(Ir, my); gy.exports = Ir; Ir.blockSize = 1024; Ir.outSize = 512; Ir.hmacStrength = 192; Ir.padLength = 128; Ir.prototype._prepareBlock = function (e, r) { for (var i = this.W, n = 0; n < 32; n++)i[n] = e[r + n]; for (; n < i.length; n += 2) { var f = dM(i[n - 4], i[n - 3]), h = lM(i[n - 4], i[n - 3]), c = i[n - 14], y = i[n - 13], x = uM(i[n - 30], i[n - 29]), M = cM(i[n - 30], i[n - 29]), E = i[n - 32], A = i[n - 31]; i[n] = Zx(f, h, c, y, x, M, E, A), i[n + 1] = Jx(f, h, c, y, x, M, E, A) } }; Ir.prototype._update = function (e, r) { this._prepareBlock(e, r); var i = this.W, n = this.h[0], f = this.h[1], h = this.h[2], c = this.h[3], y = this.h[4], x = this.h[5], M = this.h[6], E = this.h[7], A = this.h[8], B = this.h[9], T = this.h[10], C = this.h[11], H = this.h[12], F = this.h[13], we = this.h[14], Be = this.h[15]; Yx(this.k.length === i.length); for (var xe = 0; xe < i.length; xe += 2) { var Le = we, Me = Be, De = oM(A, B), Ie = hM(A, B), je = rM(A, B, T, C, H, F), S = iM(A, B, T, C, H, F), b = this.k[xe], _ = this.k[xe + 1], l = i[xe], a = i[xe + 1], s = Qx(Le, Me, De, Ie, je, S, b, _, l, a), d = eM(Le, Me, De, Ie, je, S, b, _, l, a); Le = fM(n, f), Me = sM(n, f), De = nM(n, f, h, c, y, x), Ie = aM(n, f, h, c, y, x); var v = Qu(Le, Me, De, Ie), p = ec(Le, Me, De, Ie); we = H, Be = F, H = T, F = C, T = A, C = B, A = Qu(M, E, s, d), B = ec(E, E, s, d), M = y, E = x, y = h, x = c, h = n, c = f, n = Qu(s, d, v, p), f = ec(s, d, v, p) } Vi(this.h, 0, n, f), Vi(this.h, 2, h, c), Vi(this.h, 4, y, x), Vi(this.h, 6, M, E), Vi(this.h, 8, A, B), Vi(this.h, 10, T, C), Vi(this.h, 12, H, F), Vi(this.h, 14, we, Be) }; Ir.prototype._digest = function (e) { return e === "hex" ? Bt.toHex32(this.h, "big") : Bt.split32(this.h, "big") }; function rM(t, e, r, i, n) { var f = t & r ^ ~t & n; return f < 0 && (f += 4294967296), f } function iM(t, e, r, i, n, f) { var h = e & i ^ ~e & f; return h < 0 && (h += 4294967296), h } function nM(t, e, r, i, n) { var f = t & r ^ t & n ^ r & n; return f < 0 && (f += 4294967296), f } function aM(t, e, r, i, n, f) { var h = e & i ^ e & f ^ i & f; return h < 0 && (h += 4294967296), h } function fM(t, e) { var r = Nr(t, e, 28), i = Nr(e, t, 2), n = Nr(e, t, 7), f = r ^ i ^ n; return f < 0 && (f += 4294967296), f } function sM(t, e) { var r = Lr(t, e, 28), i = Lr(e, t, 2), n = Lr(e, t, 7), f = r ^ i ^ n; return f < 0 && (f += 4294967296), f } function oM(t, e) { var r = Nr(t, e, 14), i = Nr(t, e, 18), n = Nr(e, t, 9), f = r ^ i ^ n; return f < 0 && (f += 4294967296), f } function hM(t, e) { var r = Lr(t, e, 14), i = Lr(t, e, 18), n = Lr(e, t, 9), f = r ^ i ^ n; return f < 0 && (f += 4294967296), f } function uM(t, e) { var r = Nr(t, e, 1), i = Nr(t, e, 8), n = by(t, e, 7), f = r ^ i ^ n; return f < 0 && (f += 4294967296), f } function cM(t, e) { var r = Lr(t, e, 1), i = Lr(t, e, 8), n = yy(t, e, 7), f = r ^ i ^ n; return f < 0 && (f += 4294967296), f } function dM(t, e) { var r = Nr(t, e, 19), i = Nr(e, t, 29), n = by(t, e, 6), f = r ^ i ^ n; return f < 0 && (f += 4294967296), f } function lM(t, e) { var r = Lr(t, e, 19), i = Lr(e, t, 29), n = yy(t, e, 6), f = r ^ i ^ n; return f < 0 && (f += 4294967296), f } }); var xy = I((XB, _y) => { "use strict"; var rc = Ar(), wy = tc(); function oi() { if (!(this instanceof oi)) return new oi; wy.call(this), this.h = [3418070365, 3238371032, 1654270250, 914150663, 2438529370, 812702999, 355462360, 4144912697, 1731405415, 4290775857, 2394180231, 1750603025, 3675008525, 1694076839, 1203062813, 3204075428] } rc.inherits(oi, wy); _y.exports = oi; oi.blockSize = 1024; oi.outSize = 384; oi.hmacStrength = 192; oi.padLength = 128; oi.prototype._digest = function (e) { return e === "hex" ? rc.toHex32(this.h.slice(0, 12), "big") : rc.split32(this.h.slice(0, 12), "big") } }); var My = I(Ta => { "use strict"; Ta.sha1 = uy(); Ta.sha224 = vy(); Ta.sha256 = Zu(); Ta.sha384 = xy(); Ta.sha512 = tc() }); var Ry = I(Iy => { "use strict"; var qn = Ar(), pM = Aa(), jo = qn.rotl32, Sy = qn.sum32, Of = qn.sum32_3, Ey = qn.sum32_4, Ay = pM.BlockHash; function Hr() { if (!(this instanceof Hr)) return new Hr; Ay.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.endian = "little" } qn.inherits(Hr, Ay); Iy.ripemd160 = Hr; Hr.blockSize = 512; Hr.outSize = 160; Hr.hmacStrength = 192; Hr.padLength = 64; Hr.prototype._update = function (e, r) { for (var i = this.h[0], n = this.h[1], f = this.h[2], h = this.h[3], c = this.h[4], y = i, x = n, M = f, E = h, A = c, B = 0; B < 80; B++) { var T = Sy(jo(Ey(i, By(B, n, f, h), e[yM[B] + r], vM(B)), gM[B]), c); i = c, c = h, h = jo(f, 10), f = n, n = T, T = Sy(jo(Ey(y, By(79 - B, x, M, E), e[mM[B] + r], bM(B)), wM[B]), A), y = A, A = E, E = jo(M, 10), M = x, x = T } T = Of(this.h[1], f, E), this.h[1] = Of(this.h[2], h, A), this.h[2] = Of(this.h[3], c, y), this.h[3] = Of(this.h[4], i, x), this.h[4] = Of(this.h[0], n, M), this.h[0] = T }; Hr.prototype._digest = function (e) { return e === "hex" ? qn.toHex32(this.h, "little") : qn.split32(this.h, "little") }; function By(t, e, r, i) { return t <= 15 ? e ^ r ^ i : t <= 31 ? e & r | ~e & i : t <= 47 ? (e | ~r) ^ i : t <= 63 ? e & i | r & ~i : e ^ (r | ~i) } function vM(t) { return t <= 15 ? 0 : t <= 31 ? 1518500249 : t <= 47 ? 1859775393 : t <= 63 ? 2400959708 : 2840853838 } function bM(t) { return t <= 15 ? 1352829926 : t <= 31 ? 1548603684 : t <= 47 ? 1836072691 : t <= 63 ? 2053994217 : 0 } var yM = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13], mM = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11], gM = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6], wM = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11] }); var qy = I((JB, Ty) => { "use strict"; var _M = Ar(), xM = Tt(); function qa(t, e, r) { if (!(this instanceof qa)) return new qa(t, e, r); this.Hash = t, this.blockSize = t.blockSize / 8, this.outSize = t.outSize / 8, this.inner = null, this.outer = null, this._init(_M.toArray(e, r)) } Ty.exports = qa; qa.prototype._init = function (e) { e.length > this.blockSize && (e = new this.Hash().update(e).digest()), xM(e.length <= this.blockSize); for (var r = e.length; r < this.blockSize; r++)e.push(0); for (r = 0; r < e.length; r++)e[r] ^= 54; for (this.inner = new this.Hash().update(e), r = 0; r < e.length; r++)e[r] ^= 106; this.outer = new this.Hash().update(e) }; qa.prototype.update = function (e, r) { return this.inner.update(e, r), this }; qa.prototype.digest = function (e) { return this.outer.update(this.inner.digest()), this.outer.digest(e) } }); var zo = I(ky => { var pt = ky; pt.utils = Ar(); pt.common = Aa(); pt.sha = My(); pt.ripemd = Ry(); pt.hmac = qy(); pt.sha1 = pt.sha.sha1; pt.sha256 = pt.sha.sha256; pt.sha224 = pt.sha.sha224; pt.sha384 = pt.sha.sha384; pt.sha512 = pt.sha.sha512; pt.ripemd160 = pt.ripemd.ripemd160 }); var Cy = I((eI, Py) => { Py.exports = { doubles: { step: 4, points: [["e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a", "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"], ["8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508", "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"], ["175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739", "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"], ["363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640", "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"], ["8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c", "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"], ["723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda", "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"], ["eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa", "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"], ["100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0", "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"], ["e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d", "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"], ["feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d", "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"], ["da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1", "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"], ["53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0", "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"], ["8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047", "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"], ["385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862", "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"], ["6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7", "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"], ["3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd", "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"], ["85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83", "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"], ["948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a", "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"], ["6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8", "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"], ["e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d", "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"], ["e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725", "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"], ["213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754", "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"], ["4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c", "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"], ["fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6", "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"], ["76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39", "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"], ["c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891", "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"], ["d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b", "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"], ["b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03", "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"], ["e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d", "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"], ["a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070", "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"], ["90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4", "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"], ["8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da", "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"], ["e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11", "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"], ["8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e", "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"], ["e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41", "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"], ["b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef", "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"], ["d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8", "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"], ["324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d", "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"], ["4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96", "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"], ["9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd", "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"], ["6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5", "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"], ["a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266", "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"], ["7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71", "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"], ["928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac", "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"], ["85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751", "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"], ["ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e", "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"], ["827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241", "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"], ["eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3", "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"], ["e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f", "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"], ["1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19", "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"], ["146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be", "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"], ["fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9", "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"], ["da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2", "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"], ["a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13", "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"], ["174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c", "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"], ["959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba", "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"], ["d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151", "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"], ["64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073", "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"], ["8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458", "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"], ["13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b", "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"], ["bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366", "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"], ["8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa", "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"], ["8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0", "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"], ["dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787", "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"], ["f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e", "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"]] }, naf: { wnd: 7, points: [["f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9", "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"], ["2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4", "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"], ["5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc", "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"], ["acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe", "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"], ["774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb", "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"], ["f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8", "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"], ["d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e", "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"], ["defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34", "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"], ["2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c", "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"], ["352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5", "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"], ["2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f", "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"], ["9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714", "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"], ["daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729", "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"], ["c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db", "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"], ["6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4", "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"], ["1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5", "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"], ["605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479", "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"], ["62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d", "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"], ["80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f", "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"], ["7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb", "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"], ["d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9", "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"], ["49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963", "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"], ["77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74", "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"], ["f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530", "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"], ["463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b", "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"], ["f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247", "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"], ["caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1", "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"], ["2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120", "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"], ["7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435", "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"], ["754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18", "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"], ["e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8", "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"], ["186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb", "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"], ["df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f", "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"], ["5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143", "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"], ["290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba", "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"], ["af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45", "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"], ["766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a", "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"], ["59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e", "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"], ["f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8", "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"], ["7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c", "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"], ["948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519", "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"], ["7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab", "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"], ["3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca", "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"], ["d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf", "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"], ["1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610", "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"], ["733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4", "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"], ["15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c", "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"], ["a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940", "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"], ["e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980", "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"], ["311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3", "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"], ["34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf", "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"], ["f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63", "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"], ["d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448", "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"], ["32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf", "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"], ["7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5", "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"], ["ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6", "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"], ["16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5", "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"], ["eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99", "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"], ["78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51", "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"], ["494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5", "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"], ["a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5", "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"], ["c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997", "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"], ["841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881", "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"], ["5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5", "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"], ["36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66", "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"], ["336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726", "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"], ["8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede", "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"], ["1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94", "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"], ["85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31", "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"], ["29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51", "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"], ["a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252", "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"], ["4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5", "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"], ["d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b", "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"], ["ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4", "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"], ["af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f", "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"], ["e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889", "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"], ["591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246", "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"], ["11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984", "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"], ["3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a", "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"], ["cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030", "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"], ["c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197", "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"], ["c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593", "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"], ["a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef", "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"], ["347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38", "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"], ["da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a", "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"], ["c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111", "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"], ["4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502", "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"], ["3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea", "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"], ["cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26", "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"], ["b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986", "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"], ["d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e", "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"], ["48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4", "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"], ["dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda", "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"], ["6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859", "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"], ["e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f", "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"], ["eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c", "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"], ["13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942", "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"], ["ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a", "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"], ["b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80", "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"], ["ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d", "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"], ["8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1", "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"], ["52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63", "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"], ["e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352", "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"], ["7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193", "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"], ["5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00", "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"], ["32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58", "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"], ["e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7", "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"], ["8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8", "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"], ["4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e", "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"], ["3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d", "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"], ["674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b", "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"], ["d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f", "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"], ["30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6", "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"], ["be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297", "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"], ["93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a", "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"], ["b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c", "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"], ["d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52", "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"], ["d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb", "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"], ["463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065", "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"], ["7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917", "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"], ["74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9", "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"], ["30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3", "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"], ["9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57", "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"], ["176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66", "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"], ["75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8", "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"], ["809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721", "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"], ["1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180", "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"]] } } }); var Wo = I(Fy => { "use strict"; var ic = Fy, Gi = zo(), nc = $u(), MM = qt(), Oy = MM.assert; function Dy(t) { t.type === "short" ? this.curve = new nc.short(t) : t.type === "edwards" ? this.curve = new nc.edwards(t) : this.curve = new nc.mont(t), this.g = this.curve.g, this.n = this.curve.n, this.hash = t.hash, Oy(this.g.validate(), "Invalid curve"), Oy(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O") } ic.PresetCurve = Dy; function $i(t, e) { Object.defineProperty(ic, t, { configurable: !0, enumerable: !0, get: function () { var r = new Dy(e); return Object.defineProperty(ic, t, { configurable: !0, enumerable: !0, value: r }), r } }) } $i("p192", { type: "short", prime: "p192", p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff", a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc", b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1", n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831", hash: Gi.sha256, gRed: !1, g: ["188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012", "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"] }); $i("p224", { type: "short", prime: "p224", p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001", a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe", b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4", n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d", hash: Gi.sha256, gRed: !1, g: ["b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21", "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"] }); $i("p256", { type: "short", prime: null, p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff", a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc", b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b", n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551", hash: Gi.sha256, gRed: !1, g: ["6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296", "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"] }); $i("p384", { type: "short", prime: null, p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff", a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc", b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef", n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973", hash: Gi.sha384, gRed: !1, g: ["aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7", "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"] }); $i("p521", { type: "short", prime: null, p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff", a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc", b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00", n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409", hash: Gi.sha512, gRed: !1, g: ["000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66", "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"] }); $i("curve25519", { type: "mont", prime: "p25519", p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed", a: "76d06", b: "1", n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed", hash: Gi.sha256, gRed: !1, g: ["9"] }); $i("ed25519", { type: "edwards", prime: "p25519", p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed", a: "-1", c: "1", d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3", n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed", hash: Gi.sha256, gRed: !1, g: ["216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a", "6666666666666666666666666666666666666666666666666666666666666658"] }); var ac; try { ac = Cy() } catch (t) { ac = void 0 } $i("secp256k1", { type: "short", prime: "k256", p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f", a: "0", b: "7", n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141", h: "1", hash: Gi.sha256, beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee", lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72", basis: [{ a: "3086d221a7d46bcde86c90e49284eb15", b: "-e4437ed6010e88286f547fa90abfe4c3" }, { a: "114ca50f7a8e2f3f657c1108d9d44cfd8", b: "3086d221a7d46bcde86c90e49284eb15" }], gRed: !1, g: ["79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798", "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8", ac] }) }); var Ly = I((rI, Ny) => { "use strict"; var SM = zo(), kn = Sh(), Uy = Tt(); function Xi(t) { if (!(this instanceof Xi)) return new Xi(t); this.hash = t.hash, this.predResist = !!t.predResist, this.outLen = this.hash.outSize, this.minEntropy = t.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null; var e = kn.toArray(t.entropy, t.entropyEnc || "hex"), r = kn.toArray(t.nonce, t.nonceEnc || "hex"), i = kn.toArray(t.pers, t.persEnc || "hex"); Uy(e.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"), this._init(e, r, i) } Ny.exports = Xi; Xi.prototype._init = function (e, r, i) { var n = e.concat(r).concat(i); this.K = new Array(this.outLen / 8), this.V = new Array(this.outLen / 8); for (var f = 0; f < this.V.length; f++)this.K[f] = 0, this.V[f] = 1; this._update(n), this._reseed = 1, this.reseedInterval = 281474976710656 }; Xi.prototype._hmac = function () { return new SM.hmac(this.hash, this.K) }; Xi.prototype._update = function (e) { var r = this._hmac().update(this.V).update([0]); e && (r = r.update(e)), this.K = r.digest(), this.V = this._hmac().update(this.V).digest(), !!e && (this.K = this._hmac().update(this.V).update([1]).update(e).digest(), this.V = this._hmac().update(this.V).digest()) }; Xi.prototype.reseed = function (e, r, i, n) { typeof r != "string" && (n = i, i = r, r = null), e = kn.toArray(e, r), i = kn.toArray(i, n), Uy(e.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"), this._update(e.concat(i || [])), this._reseed = 1 }; Xi.prototype.generate = function (e, r, i, n) { if (this._reseed > this.reseedInterval) throw new Error("Reseed is required"); typeof r != "string" && (n = i, i = r, r = null), i && (i = kn.toArray(i, n || "hex"), this._update(i)); for (var f = []; f.length < e;)this.V = this._hmac().update(this.V).digest(), f = f.concat(this.V); var h = f.slice(0, e); return this._update(i), this._reseed++, kn.encode(h, r) } }); var jy = I((iI, Hy) => { "use strict"; var EM = rt(), AM = qt(), fc = AM.assert; function wt(t, e) { this.ec = t, this.priv = null, this.pub = null, e.priv && this._importPrivate(e.priv, e.privEnc), e.pub && this._importPublic(e.pub, e.pubEnc) } Hy.exports = wt; wt.fromPublic = function (e, r, i) { return r instanceof wt ? r : new wt(e, { pub: r, pubEnc: i }) }; wt.fromPrivate = function (e, r, i) { return r instanceof wt ? r : new wt(e, { priv: r, privEnc: i }) }; wt.prototype.validate = function () { var e = this.getPublic(); return e.isInfinity() ? { result: !1, reason: "Invalid public key" } : e.validate() ? e.mul(this.ec.curve.n).isInfinity() ? { result: !0, reason: null } : { result: !1, reason: "Public key * N != O" } : { result: !1, reason: "Public key is not a point" } }; wt.prototype.getPublic = function (e, r) { return typeof e == "string" && (r = e, e = null), this.pub || (this.pub = this.ec.g.mul(this.priv)), r ? this.pub.encode(r, e) : this.pub }; wt.prototype.getPrivate = function (e) { return e === "hex" ? this.priv.toString(16, 2) : this.priv }; wt.prototype._importPrivate = function (e, r) { this.priv = new EM(e, r || 16), this.priv = this.priv.umod(this.ec.curve.n) }; wt.prototype._importPublic = function (e, r) { if (e.x || e.y) { this.ec.curve.type === "mont" ? fc(e.x, "Need x coordinate") : (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") && fc(e.x && e.y, "Need both x and y coordinate"), this.pub = this.ec.curve.point(e.x, e.y); return } this.pub = this.ec.curve.decodePoint(e, r) }; wt.prototype.derive = function (e) { return e.validate() || fc(e.validate(), "public point not validated"), e.mul(this.priv).getX() }; wt.prototype.sign = function (e, r, i) { return this.ec.sign(e, this, r, i) }; wt.prototype.verify = function (e, r) { return this.ec.verify(e, r, this) }; wt.prototype.inspect = function () { return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >" } }); var Ky = I((nI, Wy) => { "use strict"; var Ko = rt(), sc = qt(), BM = sc.assert; function Vo(t, e) { if (t instanceof Vo) return t; this._importDER(t, e) || (BM(t.r && t.s, "Signature without r or s"), this.r = new Ko(t.r, 16), this.s = new Ko(t.s, 16), t.recoveryParam === void 0 ? this.recoveryParam = null : this.recoveryParam = t.recoveryParam) } Wy.exports = Vo; function IM() { this.place = 0 } function oc(t, e) { var r = t[e.place++]; if (!(r & 128)) return r; var i = r & 15; if (i === 0 || i > 4) return !1; for (var n = 0, f = 0, h = e.place; f < i; f++, h++)n <<= 8, n |= t[h], n >>>= 0; return n <= 127 ? !1 : (e.place = h, n) } function zy(t) { for (var e = 0, r = t.length - 1; !t[e] && !(t[e + 1] & 128) && e < r;)e++; return e === 0 ? t : t.slice(e) } Vo.prototype._importDER = function (e, r) { e = sc.toArray(e, r); var i = new IM; if (e[i.place++] !== 48) return !1; var n = oc(e, i); if (n === !1 || n + i.place !== e.length || e[i.place++] !== 2) return !1; var f = oc(e, i); if (f === !1) return !1; var h = e.slice(i.place, f + i.place); if (i.place += f, e[i.place++] !== 2) return !1; var c = oc(e, i); if (c === !1 || e.length !== c + i.place) return !1; var y = e.slice(i.place, c + i.place); if (h[0] === 0) if (h[1] & 128) h = h.slice(1); else return !1; if (y[0] === 0) if (y[1] & 128) y = y.slice(1); else return !1; return this.r = new Ko(h), this.s = new Ko(y), this.recoveryParam = null, !0 }; function hc(t, e) { if (e < 128) { t.push(e); return } var r = 1 + (Math.log(e) / Math.LN2 >>> 3); for (t.push(r | 128); --r;)t.push(e >>> (r << 3) & 255); t.push(e) } Vo.prototype.toDER = function (e) { var r = this.r.toArray(), i = this.s.toArray(); for (r[0] & 128 && (r = [0].concat(r)), i[0] & 128 && (i = [0].concat(i)), r = zy(r), i = zy(i); !i[0] && !(i[1] & 128);)i = i.slice(1); var n = [2]; hc(n, r.length), n = n.concat(r), n.push(2), hc(n, i.length); var f = n.concat(i), h = [48]; return hc(h, f.length), h = h.concat(f), sc.encode(h, e) } }); var Xy = I((aI, $y) => { "use strict"; var Pn = rt(), Vy = Ly(), RM = qt(), uc = Wo(), TM = mo(), Gy = RM.assert, cc = jy(), Go = Ky(); function Jt(t) { if (!(this instanceof Jt)) return new Jt(t); typeof t == "string" && (Gy(Object.prototype.hasOwnProperty.call(uc, t), "Unknown curve " + t), t = uc[t]), t instanceof uc.PresetCurve && (t = { curve: t }), this.curve = t.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = t.curve.g, this.g.precompute(t.curve.n.bitLength() + 1), this.hash = t.hash || t.curve.hash } $y.exports = Jt; Jt.prototype.keyPair = function (e) { return new cc(this, e) }; Jt.prototype.keyFromPrivate = function (e, r) { return cc.fromPrivate(this, e, r) }; Jt.prototype.keyFromPublic = function (e, r) { return cc.fromPublic(this, e, r) }; Jt.prototype.genKeyPair = function (e) { e || (e = {}); for (var r = new Vy({ hash: this.hash, pers: e.pers, persEnc: e.persEnc || "utf8", entropy: e.entropy || TM(this.hash.hmacStrength), entropyEnc: e.entropy && e.entropyEnc || "utf8", nonce: this.n.toArray() }), i = this.n.byteLength(), n = this.n.sub(new Pn(2)); ;) { var f = new Pn(r.generate(i)); if (!(f.cmp(n) > 0)) return f.iaddn(1), this.keyFromPrivate(f) } }; Jt.prototype._truncateToN = function (e, r) { var i = e.byteLength() * 8 - this.n.bitLength(); return i > 0 && (e = e.ushrn(i)), !r && e.cmp(this.n) >= 0 ? e.sub(this.n) : e }; Jt.prototype.sign = function (e, r, i, n) { typeof i == "object" && (n = i, i = null), n || (n = {}), r = this.keyFromPrivate(r, i), e = this._truncateToN(new Pn(e, 16)); for (var f = this.n.byteLength(), h = r.getPrivate().toArray("be", f), c = e.toArray("be", f), y = new Vy({ hash: this.hash, entropy: h, nonce: c, pers: n.pers, persEnc: n.persEnc || "utf8" }), x = this.n.sub(new Pn(1)), M = 0; ; M++) { var E = n.k ? n.k(M) : new Pn(y.generate(this.n.byteLength())); if (E = this._truncateToN(E, !0), !(E.cmpn(1) <= 0 || E.cmp(x) >= 0)) { var A = this.g.mul(E); if (!A.isInfinity()) { var B = A.getX(), T = B.umod(this.n); if (T.cmpn(0) !== 0) { var C = E.invm(this.n).mul(T.mul(r.getPrivate()).iadd(e)); if (C = C.umod(this.n), C.cmpn(0) !== 0) { var H = (A.getY().isOdd() ? 1 : 0) | (B.cmp(T) !== 0 ? 2 : 0); return n.canonical && C.cmp(this.nh) > 0 && (C = this.n.sub(C), H ^= 1), new Go({ r: T, s: C, recoveryParam: H }) } } } } } }; Jt.prototype.verify = function (e, r, i, n) { e = this._truncateToN(new Pn(e, 16)), i = this.keyFromPublic(i, n), r = new Go(r, "hex"); var f = r.r, h = r.s; if (f.cmpn(1) < 0 || f.cmp(this.n) >= 0 || h.cmpn(1) < 0 || h.cmp(this.n) >= 0) return !1; var c = h.invm(this.n), y = c.mul(e).umod(this.n), x = c.mul(f).umod(this.n), M; return this.curve._maxwellTrick ? (M = this.g.jmulAdd(y, i.getPublic(), x), M.isInfinity() ? !1 : M.eqXToP(f)) : (M = this.g.mulAdd(y, i.getPublic(), x), M.isInfinity() ? !1 : M.getX().umod(this.n).cmp(f) === 0) }; Jt.prototype.recoverPubKey = function (t, e, r, i) { Gy((3 & r) === r, "The recovery param is more than two bits"), e = new Go(e, i); var n = this.n, f = new Pn(t), h = e.r, c = e.s, y = r & 1, x = r >> 1; if (h.cmp(this.curve.p.umod(this.curve.n)) >= 0 && x) throw new Error("Unable to find sencond key candinate"); x ? h = this.curve.pointFromX(h.add(this.curve.n), y) : h = this.curve.pointFromX(h, y); var M = e.r.invm(n), E = n.sub(f).mul(M).umod(n), A = c.mul(M).umod(n); return this.g.mulAdd(E, h, A) }; Jt.prototype.getKeyRecoveryParam = function (t, e, r, i) { if (e = new Go(e, i), e.recoveryParam !== null) return e.recoveryParam; for (var n = 0; n < 4; n++) { var f; try { f = this.recoverPubKey(t, e, n) } catch (h) { continue } if (f.eq(r)) return n } throw new Error("Unable to find valid recovery factor") } }); var Qy = I((fI, Jy) => { "use strict"; var Df = qt(), Yy = Df.assert, Zy = Df.parseBytes, ka = Df.cachedProperty; function ht(t, e) { this.eddsa = t, this._secret = Zy(e.secret), t.isPoint(e.pub) ? this._pub = e.pub : this._pubBytes = Zy(e.pub) } ht.fromPublic = function (e, r) { return r instanceof ht ? r : new ht(e, { pub: r }) }; ht.fromSecret = function (e, r) { return r instanceof ht ? r : new ht(e, { secret: r }) }; ht.prototype.secret = function () { return this._secret }; ka(ht, "pubBytes", function () { return this.eddsa.encodePoint(this.pub()) }); ka(ht, "pub", function () { return this._pubBytes ? this.eddsa.decodePoint(this._pubBytes) : this.eddsa.g.mul(this.priv()) }); ka(ht, "privBytes", function () { var e = this.eddsa, r = this.hash(), i = e.encodingLength - 1, n = r.slice(0, e.encodingLength); return n[0] &= 248, n[i] &= 127, n[i] |= 64, n }); ka(ht, "priv", function () { return this.eddsa.decodeInt(this.privBytes()) }); ka(ht, "hash", function () { return this.eddsa.hash().update(this.secret()).digest() }); ka(ht, "messagePrefix", function () { return this.hash().slice(this.eddsa.encodingLength) }); ht.prototype.sign = function (e) { return Yy(this._secret, "KeyPair can only verify"), this.eddsa.sign(e, this) }; ht.prototype.verify = function (e, r) { return this.eddsa.verify(e, r, this) }; ht.prototype.getSecret = function (e) { return Yy(this._secret, "KeyPair is public only"), Df.encode(this.secret(), e) }; ht.prototype.getPublic = function (e) { return Df.encode(this.pubBytes(), e) }; Jy.exports = ht }); var tm = I((sI, em) => { "use strict"; var qM = rt(), $o = qt(), kM = $o.assert, Xo = $o.cachedProperty, PM = $o.parseBytes; function Cn(t, e) { this.eddsa = t, typeof e != "object" && (e = PM(e)), Array.isArray(e) && (e = { R: e.slice(0, t.encodingLength), S: e.slice(t.encodingLength) }), kM(e.R && e.S, "Signature without R or S"), t.isPoint(e.R) && (this._R = e.R), e.S instanceof qM && (this._S = e.S), this._Rencoded = Array.isArray(e.R) ? e.R : e.Rencoded, this._Sencoded = Array.isArray(e.S) ? e.S : e.Sencoded } Xo(Cn, "S", function () { return this.eddsa.decodeInt(this.Sencoded()) }); Xo(Cn, "R", function () { return this.eddsa.decodePoint(this.Rencoded()) }); Xo(Cn, "Rencoded", function () { return this.eddsa.encodePoint(this.R()) }); Xo(Cn, "Sencoded", function () { return this.eddsa.encodeInt(this.S()) }); Cn.prototype.toBytes = function () { return this.Rencoded().concat(this.Sencoded()) }; Cn.prototype.toHex = function () { return $o.encode(this.toBytes(), "hex").toUpperCase() }; em.exports = Cn }); var fm = I((oI, am) => { "use strict"; var CM = zo(), OM = Wo(), Pa = qt(), DM = Pa.assert, rm = Pa.parseBytes, im = Qy(), nm = tm(); function It(t) { if (DM(t === "ed25519", "only tested with ed25519 so far"), !(this instanceof It)) return new It(t); t = OM[t].curve, this.curve = t, this.g = t.g, this.g.precompute(t.n.bitLength() + 1), this.pointClass = t.point().constructor, this.encodingLength = Math.ceil(t.n.bitLength() / 8), this.hash = CM.sha512 } am.exports = It; It.prototype.sign = function (e, r) { e = rm(e); var i = this.keyFromSecret(r), n = this.hashInt(i.messagePrefix(), e), f = this.g.mul(n), h = this.encodePoint(f), c = this.hashInt(h, i.pubBytes(), e).mul(i.priv()), y = n.add(c).umod(this.curve.n); return this.makeSignature({ R: f, S: y, Rencoded: h }) }; It.prototype.verify = function (e, r, i) { e = rm(e), r = this.makeSignature(r); var n = this.keyFromPublic(i), f = this.hashInt(r.Rencoded(), n.pubBytes(), e), h = this.g.mul(r.S()), c = r.R().add(n.pub().mul(f)); return c.eq(h) }; It.prototype.hashInt = function () { for (var e = this.hash(), r = 0; r < arguments.length; r++)e.update(arguments[r]); return Pa.intFromLE(e.digest()).umod(this.curve.n) }; It.prototype.keyFromPublic = function (e) { return im.fromPublic(this, e) }; It.prototype.keyFromSecret = function (e) { return im.fromSecret(this, e) }; It.prototype.makeSignature = function (e) { return e instanceof nm ? e : new nm(this, e) }; It.prototype.encodePoint = function (e) { var r = e.getY().toArray("le", this.encodingLength); return r[this.encodingLength - 1] |= e.getX().isOdd() ? 128 : 0, r }; It.prototype.decodePoint = function (e) { e = Pa.parseBytes(e); var r = e.length - 1, i = e.slice(0, r).concat(e[r] & ~128), n = (e[r] & 128) != 0, f = Pa.intFromLE(i); return this.curve.pointFromY(f, n) }; It.prototype.encodeInt = function (e) { return e.toArray("le", this.encodingLength) }; It.prototype.decodeInt = function (e) { return Pa.intFromLE(e) }; It.prototype.isPoint = function (e) { return e instanceof this.pointClass } }); var Ef = I(sm => { "use strict"; var On = sm; On.version = Gc().version; On.utils = qt(); On.rand = mo(); On.curve = $u(); On.curves = Wo(); On.ec = Xy(); On.eddsa = fm() }); var dm = I((uI, cm) => { var Je = cm.exports = {}, jr, zr; function dc() { throw new Error("setTimeout has not been defined") } function lc() { throw new Error("clearTimeout has not been defined") } (function () { try { typeof setTimeout == "function" ? jr = setTimeout : jr = dc } catch (t) { jr = dc } try { typeof clearTimeout == "function" ? zr = clearTimeout : zr = lc } catch (t) { zr = lc } })(); function om(t) { if (jr === setTimeout) return setTimeout(t, 0); if ((jr === dc || !jr) && setTimeout) return jr = setTimeout, setTimeout(t, 0); try { return jr(t, 0) } catch (e) { try { return jr.call(null, t, 0) } catch (r) { return jr.call(this, t, 0) } } } function FM(t) { if (zr === clearTimeout) return clearTimeout(t); if ((zr === lc || !zr) && clearTimeout) return zr = clearTimeout, clearTimeout(t); try { return zr(t) } catch (e) { try { return zr.call(null, t) } catch (r) { return zr.call(this, t) } } } var hi = [], Ca = !1, Dn, Yo = -1; function UM() { !Ca || !Dn || (Ca = !1, Dn.length ? hi = Dn.concat(hi) : Yo = -1, hi.length && hm()) } function hm() { if (!Ca) { var t = om(UM); Ca = !0; for (var e = hi.length; e;) { for (Dn = hi, hi = []; ++Yo < e;)Dn && Dn[Yo].run(); Yo = -1, e = hi.length } Dn = null, Ca = !1, FM(t) } } Je.nextTick = function (t) { var e = new Array(arguments.length - 1); if (arguments.length > 1) for (var r = 1; r < arguments.length; r++)e[r - 1] = arguments[r]; hi.push(new um(t, e)), hi.length === 1 && !Ca && om(hm) }; function um(t, e) { this.fun = t, this.array = e } um.prototype.run = function () { this.fun.apply(null, this.array) }; Je.title = "browser"; Je.browser = !0; Je.env = {}; Je.argv = []; Je.version = ""; Je.versions = {}; function ui() { } Je.on = ui; Je.addListener = ui; Je.once = ui; Je.off = ui; Je.removeListener = ui; Je.removeAllListeners = ui; Je.emit = ui; Je.prependListener = ui; Je.prependOnceListener = ui; Je.listeners = function (t) { return [] }; Je.binding = function (t) { throw new Error("process.binding is not supported") }; Je.cwd = function () { return "/" }; Je.chdir = function (t) { throw new Error("process.chdir is not supported") }; Je.umask = function () { return 0 } }); var Fn = I((cI, lm) => { "use strict"; var NM = Zr(), { Buffer: _e } = ct(), LM = new TextDecoder("utf8", { fatal: !0, ignoreBOM: !0 }), Oa = class extends NM.Transform { constructor(e, r, i = {}) { let n = null, f = null; switch (typeof e) { case "object": _e.isBuffer(e) ? n = e : e && (i = e); break; case "string": n = e; break; case "undefined": break; default: throw new TypeError("Invalid input") }switch (typeof r) { case "object": r && (i = r); break; case "string": f = r; break; case "undefined": break; default: throw new TypeError("Invalid inputEncoding") }if (!i || typeof i != "object") throw new TypeError("Invalid options"); n == null && (n = i.input), f == null && (f = i.inputEncoding), delete i.input, delete i.inputEncoding; let h = i.watchPipe == null ? !0 : i.watchPipe; delete i.watchPipe; let c = Boolean(i.readError); delete i.readError, super(i), this.readError = c, h && this.on("pipe", y => { let x = y._readableState.objectMode; if (this.length > 0 && x !== this._readableState.objectMode) throw new Error("Do not switch objectMode in the middle of the stream"); this._readableState.objectMode = x, this._writableState.objectMode = x }), n != null && this.end(n, f) } static isNoFilter(e) { return e instanceof this } static compare(e, r) { if (!(e instanceof this)) throw new TypeError("Arguments must be NoFilters"); return e === r ? 0 : e.compare(r) } static concat(e, r) { if (!Array.isArray(e)) throw new TypeError("list argument must be an Array of NoFilters"); if (e.length === 0 || r === 0) return _e.alloc(0); r == null && (r = e.reduce((h, c) => { if (!(c instanceof Oa)) throw new TypeError("list argument must be an Array of NoFilters"); return h + c.length }, 0)); let i = !0, n = !0, f = e.map(h => { if (!(h instanceof Oa)) throw new TypeError("list argument must be an Array of NoFilters"); let c = h.slice(); return _e.isBuffer(c) ? n = !1 : i = !1, c }); if (i) return _e.concat(f, r); if (n) return [].concat(...f).slice(0, r); throw new Error("Concatenating mixed object and byte streams not supported") } _transform(e, r, i) { !this._readableState.objectMode && !_e.isBuffer(e) && (e = _e.from(e, r)), this.push(e), i() } _bufArray() { let e = this._readableState.buffer; if (!Array.isArray(e)) { let r = e.head; for (e = []; r != null;)e.push(r.data), r = r.next } return e } read(e) { let r = super.read(e); if (r != null) { if (this.emit("read", r), this.readError && r.length < e) throw new Error(`Read ${r.length}, wanted ${e}`) } else if (this.readError) throw new Error(`No data available, wanted ${e}`); return r } readFull(e) { let r = null, i = null, n = null; return new Promise((f, h) => { if (this.length >= e) { f(this.read(e)); return } if (this.writableFinished) { h(new Error(`Stream finished before ${e} bytes were available`)); return } r = c => { this.length >= e && f(this.read(e)) }, i = () => { h(new Error(`Stream finished before ${e} bytes were available`)) }, n = h, this.on("readable", r), this.on("error", n), this.on("finish", i) }).finally(() => { r && (this.removeListener("readable", r), this.removeListener("error", n), this.removeListener("finish", i)) }) } promise(e) { let r = !1; return new Promise((i, n) => { this.on("finish", () => { let f = this.read(); e != null && !r && (r = !0, e(null, f)), i(f) }), this.on("error", f => { e != null && !r && (r = !0, e(f)), n(f) }) }) } compare(e) { if (!(e instanceof Oa)) throw new TypeError("Arguments must be NoFilters"); if (this === e) return 0; let r = this.slice(), i = e.slice(); if (_e.isBuffer(r) && _e.isBuffer(i)) return r.compare(i); throw new Error("Cannot compare streams in object mode") } equals(e) { return this.compare(e) === 0 } slice(e, r) { if (this._readableState.objectMode) return this._bufArray().slice(e, r); let i = this._bufArray(); switch (i.length) { case 0: return _e.alloc(0); case 1: return i[0].slice(e, r); default: return _e.concat(i).slice(e, r) } } get(e) { return this.slice()[e] } toJSON() { let e = this.slice(); return _e.isBuffer(e) ? e.toJSON() : e } toString(e, r, i) { let n = this.slice(r, i); return _e.isBuffer(n) ? !e || e === "utf8" ? LM.decode(n) : n.toString(e) : JSON.stringify(n) } [Symbol.for("nodejs.util.inspect.custom")](e, r) { let n = this._bufArray().map(f => _e.isBuffer(f) ? r.stylize(f.toString("hex"), "string") : JSON.stringify(f)).join(", "); return `${this.constructor.name} [${n}]` } get length() { return this._readableState.length } writeBigInt(e) { let r = e.toString(16); if (e < 0) { let i = BigInt(Math.floor(r.length / 2)); e = (BigInt(1) << i * BigInt(8)) + e, r = e.toString(16) } return r.length % 2 && (r = `0${r}`), this.push(_e.from(r, "hex")) } readUBigInt(e) { let r = this.read(e); return _e.isBuffer(r) ? BigInt(`0x${r.toString("hex")}`) : null } readBigInt(e) { let r = this.read(e); if (!_e.isBuffer(r)) return null; let i = BigInt(`0x${r.toString("hex")}`); return r[0] & 128 && (i -= BigInt(1) << BigInt(r.length) * BigInt(8)), i } writeUInt8(e) { let r = _e.from([e]); return this.push(r) } writeUInt16LE(e) { let r = _e.alloc(2); return r.writeUInt16LE(e), this.push(r) } writeUInt16BE(e) { let r = _e.alloc(2); return r.writeUInt16BE(e), this.push(r) } writeUInt32LE(e) { let r = _e.alloc(4); return r.writeUInt32LE(e), this.push(r) } writeUInt32BE(e) { let r = _e.alloc(4); return r.writeUInt32BE(e), this.push(r) } writeInt8(e) { let r = _e.from([e]); return this.push(r) } writeInt16LE(e) { let r = _e.alloc(2); return r.writeUInt16LE(e), this.push(r) } writeInt16BE(e) { let r = _e.alloc(2); return r.writeUInt16BE(e), this.push(r) } writeInt32LE(e) { let r = _e.alloc(4); return r.writeUInt32LE(e), this.push(r) } writeInt32BE(e) { let r = _e.alloc(4); return r.writeUInt32BE(e), this.push(r) } writeFloatLE(e) { let r = _e.alloc(4); return r.writeFloatLE(e), this.push(r) } writeFloatBE(e) { let r = _e.alloc(4); return r.writeFloatBE(e), this.push(r) } writeDoubleLE(e) { let r = _e.alloc(8); return r.writeDoubleLE(e), this.push(r) } writeDoubleBE(e) { let r = _e.alloc(8); return r.writeDoubleBE(e), this.push(r) } writeBigInt64LE(e) { let r = _e.alloc(8); return r.writeBigInt64LE(e), this.push(r) } writeBigInt64BE(e) { let r = _e.alloc(8); return r.writeBigInt64BE(e), this.push(r) } writeBigUInt64LE(e) { let r = _e.alloc(8); return r.writeBigUInt64LE(e), this.push(r) } writeBigUInt64BE(e) { let r = _e.alloc(8); return r.writeBigUInt64BE(e), this.push(r) } readUInt8() { let e = this.read(1); return _e.isBuffer(e) ? e.readUInt8() : null } readUInt16LE() { let e = this.read(2); return _e.isBuffer(e) ? e.readUInt16LE() : null } readUInt16BE() { let e = this.read(2); return _e.isBuffer(e) ? e.readUInt16BE() : null } readUInt32LE() { let e = this.read(4); return _e.isBuffer(e) ? e.readUInt32LE() : null } readUInt32BE() { let e = this.read(4); return _e.isBuffer(e) ? e.readUInt32BE() : null } readInt8() { let e = this.read(1); return _e.isBuffer(e) ? e.readInt8() : null } readInt16LE() { let e = this.read(2); return _e.isBuffer(e) ? e.readInt16LE() : null } readInt16BE() { let e = this.read(2); return _e.isBuffer(e) ? e.readInt16BE() : null } readInt32LE() { let e = this.read(4); return _e.isBuffer(e) ? e.readInt32LE() : null } readInt32BE() { let e = this.read(4); return _e.isBuffer(e) ? e.readInt32BE() : null } readFloatLE() { let e = this.read(4); return _e.isBuffer(e) ? e.readFloatLE() : null } readFloatBE() { let e = this.read(4); return _e.isBuffer(e) ? e.readFloatBE() : null } readDoubleLE() { let e = this.read(8); return _e.isBuffer(e) ? e.readDoubleLE() : null } readDoubleBE() { let e = this.read(8); return _e.isBuffer(e) ? e.readDoubleBE() : null } readBigInt64LE() { let e = this.read(8); return _e.isBuffer(e) ? e.readBigInt64LE() : null } readBigInt64BE() { let e = this.read(8); return _e.isBuffer(e) ? e.readBigInt64BE() : null } readBigUInt64LE() { let e = this.read(8); return _e.isBuffer(e) ? e.readBigUInt64LE() : null } readBigUInt64BE() { let e = this.read(8); return _e.isBuffer(e) ? e.readBigUInt64BE() : null } }; lm.exports = Oa }); var di = I(ci => { "use strict"; ci.MT = { POS_INT: 0, NEG_INT: 1, BYTE_STRING: 2, UTF8_STRING: 3, ARRAY: 4, MAP: 5, TAG: 6, SIMPLE_FLOAT: 7 }; ci.TAG = { DATE_STRING: 0, DATE_EPOCH: 1, POS_BIGINT: 2, NEG_BIGINT: 3, DECIMAL_FRAC: 4, BIGFLOAT: 5, BASE64URL_EXPECTED: 21, BASE64_EXPECTED: 22, BASE16_EXPECTED: 23, CBOR: 24, URI: 32, BASE64URL: 33, BASE64: 34, REGEXP: 35, MIME: 36, SET: 258 }; ci.NUMBYTES = { ZERO: 0, ONE: 24, TWO: 25, FOUR: 26, EIGHT: 27, INDEFINITE: 31 }; ci.SIMPLE = { FALSE: 20, TRUE: 21, NULL: 22, UNDEFINED: 23 }; ci.SYMS = { NULL: Symbol.for("github.com/hildjj/node-cbor/null"), UNDEFINED: Symbol.for("github.com/hildjj/node-cbor/undef"), PARENT: Symbol.for("github.com/hildjj/node-cbor/parent"), BREAK: Symbol.for("github.com/hildjj/node-cbor/break"), STREAM: Symbol.for("github.com/hildjj/node-cbor/stream") }; ci.SHIFT32 = 4294967296; ci.BI = { MINUS_ONE: BigInt(-1), NEG_MAX: BigInt(-1) - BigInt(Number.MAX_SAFE_INTEGER), MAXINT32: BigInt("0xffffffff"), MAXINT64: BigInt("0xffffffffffffffff"), SHIFT32: BigInt(ci.SHIFT32) } }); var Da = I($e => { "use strict"; var { Buffer: Un } = ct(), pm = Fn(), HM = Zr(), jM = di(), { NUMBYTES: Zo, SHIFT32: zM, BI: WM, SYMS: pc } = jM, KM = 2097151, VM = new TextDecoder("utf8", { fatal: !0, ignoreBOM: !0 }); $e.utf8 = t => VM.decode(t); $e.utf8.checksUTF8 = !0; function GM(t) { return t instanceof HM.Readable ? !0 : ["read", "on", "pipe"].every(e => typeof t[e] == "function") } $e.isBufferish = function (e) { return e && typeof e == "object" && (Un.isBuffer(e) || e instanceof Uint8Array || e instanceof Uint8ClampedArray || e instanceof ArrayBuffer || e instanceof DataView) }; $e.bufferishToBuffer = function (e) { return Un.isBuffer(e) ? e : ArrayBuffer.isView(e) ? Un.from(e.buffer, e.byteOffset, e.byteLength) : e instanceof ArrayBuffer ? Un.from(e) : null }; $e.parseCBORint = function (e, r) { switch (e) { case Zo.ONE: return r.readUInt8(0); case Zo.TWO: return r.readUInt16BE(0); case Zo.FOUR: return r.readUInt32BE(0); case Zo.EIGHT: { let i = r.readUInt32BE(0), n = r.readUInt32BE(4); return i > KM ? BigInt(i) * WM.SHIFT32 + BigInt(n) : i * zM + n } default: throw new Error(`Invalid additional info for int: ${e}`) } }; $e.writeHalf = function (e, r) { let i = Un.allocUnsafe(4); i.writeFloatBE(r, 0); let n = i.readUInt32BE(0); if ((n & 8191) != 0) return !1; let f = n >> 16 & 32768, h = n >> 23 & 255, c = n & 8388607; if (h >= 113 && h <= 142) f += (h - 112 << 10) + (c >> 13); else if (h >= 103 && h < 113) { if (c & (1 << 126 - h) - 1) return !1; f += c + 8388608 >> 126 - h } else return !1; return e.writeUInt16BE(f), !0 }; $e.parseHalf = function (e) { let r = e[0] & 128 ? -1 : 1, i = (e[0] & 124) >> 2, n = (e[0] & 3) << 8 | e[1]; if (i) { if (i === 31) return r * (n ? NaN : Infinity) } else return r * 5960464477539063e-23 * n; return r * He(2, i - 25) * (1024 + n) }; $e.parseCBORfloat = function (e) { switch (e.length) { case 2: return $e.parseHalf(e); case 4: return e.readFloatBE(0); case 8: return e.readDoubleBE(0); default: throw new Error(`Invalid float size: ${e.length}`) } }; $e.hex = function (e) { return Un.from(e.replace(/^0x/, ""), "hex") }; $e.bin = function (e) { e = e.replace(/\s/g, ""); let r = 0, i = e.length % 8 || 8, n = []; for (; i <= e.length;)n.push(parseInt(e.slice(r, i), 2)), r = i, i += 8; return Un.from(n) }; $e.arrayEqual = function (e, r) { return e == null && r == null ? !0 : e == null || r == null ? !1 : e.length === r.length && e.every((i, n) => i === r[n]) }; $e.bufferToBigInt = function (e) { return BigInt(`0x${e.toString("hex")}`) }; $e.cborValueToString = function (e, r = -1) { switch (typeof e) { case "symbol": { switch (e) { case pc.NULL: return "null"; case pc.UNDEFINED: return "undefined"; case pc.BREAK: return "BREAK" }if (e.description) return e.description; let n = e.toString().match(/^Symbol\((?<name>.*)\)/); return n && n.groups.name ? n.groups.name : "Symbol" } case "string": return JSON.stringify(e); case "bigint": return e.toString(); case "number": { let i = Object.is(e, -0) ? "-0" : String(e); return r > 0 ? `${i}_${r}` : i } case "object": { let i = $e.bufferishToBuffer(e); if (i) { let n = i.toString("hex"); return r === -Infinity ? n : `h'${n}'` } return typeof e[Symbol.for("nodejs.util.inspect.custom")] == "function" ? e[Symbol.for("nodejs.util.inspect.custom")]() : Array.isArray(e) ? "[]" : "{}" } }return String(e) }; $e.guessEncoding = function (e, r) { if (typeof e == "string") return new pm(e, r == null ? "hex" : r); let i = $e.bufferishToBuffer(e); if (i) return new pm(i); if (GM(e)) return e; throw new Error("Unknown input type") }; var $M = { "=": "", "+": "-", "/": "_" }; $e.base64url = function (e) { return $e.bufferishToBuffer(e).toString("base64").replace(/[=+/]/g, r => $M[r]) }; $e.base64 = function (e) { return $e.bufferishToBuffer(e).toString("base64") }; $e.isBigEndian = function () { let e = new Uint8Array(4), r = new Uint32Array(e.buffer); return !((r[0] = 1) & e[0]) } }); var ym = I((pI, bm) => { "use strict"; var XM = Zr(), YM = Fn(), vm = class extends XM.Transform { constructor(e) { super(e); this._writableState.objectMode = !1, this._readableState.objectMode = !0, this.bs = new YM, this.__restart() } _transform(e, r, i) { for (this.bs.write(e); this.bs.length >= this.__needed;) { let n = null, f = this.__needed === null ? void 0 : this.bs.read(this.__needed); try { n = this.__parser.next(f) } catch (h) { return i(h) } this.__needed && (this.__fresh = !1), n.done ? (this.push(n.value), this.__restart()) : this.__needed = n.value || Infinity } return i() } *_parse() { throw new Error("Must be implemented in subclass") } __restart() { this.__needed = null, this.__parser = this._parse(), this.__fresh = !0 } _flush(e) { e(this.__fresh ? null : new Error("unexpected end of input")) } }; bm.exports = vm }); var vc = I((vI, Mm) => { "use strict"; var ZM = di(), Wr = Da(), Fa = Symbol("INTERNAL_JSON"); function Ff(t, e) { if (Wr.isBufferish(t)) t.toJSON = e; else if (Array.isArray(t)) for (let r of t) Ff(r, e); else if (t && typeof t == "object" && (!(t instanceof Yi) || t.tag < 21 || t.tag > 23)) for (let r of Object.values(t)) Ff(r, e) } function mm() { return Wr.base64(this) } function gm() { return Wr.base64url(this) } function wm() { return this.toString("hex") } function JM(t, e, r, i) { let n = new DataView(t), [f, h] = { 2: [n.getUint16, n.setUint16], 4: [n.getUint32, n.setUint32], 8: [n.getBigUint64, n.setBigUint64] }[e], c = r + i; for (let y = r; y < c; y += e)h.call(n, y, f.call(n, y, !0)) } var _m = { 0: t => new Date(t), 1: t => new Date(t * 1e3), 2: t => Wr.bufferToBigInt(t), 3: t => ZM.BI.MINUS_ONE - Wr.bufferToBigInt(t), 21: (t, e) => (Wr.isBufferish(t) ? e[Fa] = gm : Ff(t, gm), e), 22: (t, e) => (Wr.isBufferish(t) ? e[Fa] = mm : Ff(t, mm), e), 23: (t, e) => (Wr.isBufferish(t) ? e[Fa] = wm : Ff(t, wm), e), 32: t => new URL(t), 33: (t, e) => { if (!t.match(/^[a-zA-Z0-9_-]+$/)) throw new Error("Invalid base64url characters"); let r = t.length % 4; if (r === 1) throw new Error("Invalid base64url length"); if (r === 2) { if ("AQgw".indexOf(t[t.length - 1]) === -1) throw new Error("Invalid base64 padding") } else if (r === 3 && "AEIMQUYcgkosw048".indexOf(t[t.length - 1]) === -1) throw new Error("Invalid base64 padding"); return e }, 34: (t, e) => { let r = t.match(/^[a-zA-Z0-9+/]+(?<padding>={0,2})$/); if (!r) throw new Error("Invalid base64 characters"); if (t.length % 4 != 0) throw new Error("Invalid base64 length"); if (r.groups.padding === "=") { if ("AQgw".indexOf(t[t.length - 2]) === -1) throw new Error("Invalid base64 padding") } else if (r.groups.padding === "==" && "AEIMQUYcgkosw048".indexOf(t[t.length - 3]) === -1) throw new Error("Invalid base64 padding"); return e }, 35: t => new RegExp(t), 258: t => new Set(t) }, Ua = { 64: Uint8Array, 65: Uint16Array, 66: Uint32Array, 68: Uint8ClampedArray, 69: Uint16Array, 70: Uint32Array, 72: Int8Array, 73: Int16Array, 74: Int32Array, 77: Int16Array, 78: Int32Array, 81: Float32Array, 82: Float64Array, 85: Float32Array, 86: Float64Array }; typeof BigUint64Array != "undefined" && (Ua[67] = BigUint64Array, Ua[71] = BigUint64Array); typeof BigInt64Array != "undefined" && (Ua[75] = BigInt64Array, Ua[79] = BigInt64Array); function QM(t, e) { if (!Wr.isBufferish(t)) throw new TypeError("val not a buffer"); let { tag: r } = e, i = Ua[r]; if (!i) throw new Error(`Invalid typed array tag: ${r}`); let n = r & 4, f = (r & 16) >> 4, h = He(2, f + (r & 3)); !n !== Wr.isBigEndian() && h > 1 && JM(t.buffer, h, t.byteOffset, t.byteLength); let c = t.buffer.slice(t.byteOffset, t.byteOffset + t.byteLength); return new i(c) } for (let t of Object.keys(Ua)) _m[t] = QM; var xm = {}, Yi = class { constructor(e, r, i) { if (this.tag = e, this.value = r, this.err = i, typeof this.tag != "number") throw new Error(`Invalid tag type (${typeof this.tag})`); if (this.tag < 0 || (this.tag | 0) !== this.tag) throw new Error(`Tag must be a positive integer: ${this.tag}`) } toJSON() { if (this[Fa]) return this[Fa].call(this.value); let e = { tag: this.tag, value: this.value }; return this.err && (e.err = this.err), e } toString() { return `${this.tag}(${JSON.stringify(this.value)})` } encodeCBOR(e) { return e._pushTag(this.tag), e.pushAny(this.value) } convert(e) { let r = e == null ? void 0 : e[this.tag]; if (typeof r != "function" && (r = Yi.TAGS[this.tag], typeof r != "function")) return this; try { return r.call(this, this.value, this) } catch (i) { return i && i.message && i.message.length > 0 ? this.err = i.message : this.err = i, this } } static get TAGS() { return xm } static set TAGS(e) { xm = e } static reset() { Yi.TAGS = Xe({}, _m) } }; Yi.INTERNAL_JSON = Fa; Yi.reset(); Mm.exports = Yi }); var yc = I((bI, Sm) => { "use strict"; var { MT: eS, SIMPLE: Jo, SYMS: bc } = di(), Uf = class { constructor(e) { if (typeof e != "number") throw new Error(`Invalid Simple type: ${typeof e}`); if (e < 0 || e > 255 || (e | 0) !== e) throw new Error(`value must be a small positive integer: ${e}`); this.value = e } toString() { return `simple(${this.value})` } [Symbol.for("nodejs.util.inspect.custom")](e, r) { return `simple(${this.value})` } encodeCBOR(e) { return e._pushInt(this.value, eS.SIMPLE_FLOAT) } static isSimple(e) { return e instanceof Uf } static decode(e, r = !0, i = !1) { switch (e) { case Jo.FALSE: return !1; case Jo.TRUE: return !0; case Jo.NULL: return r ? null : bc.NULL; case Jo.UNDEFINED: return r ? void 0 : bc.UNDEFINED; case -1: if (!r || !i) throw new Error("Invalid BREAK"); return bc.BREAK; default: return new Uf(e) } } }; Sm.exports = Uf }); var Lf = I((mI, Im) => { "use strict"; var tS = ym(), rS = vc(), iS = yc(), Nn = Da(), Qo = Fn(), yI = Zr(), nS = di(), { MT: tt, NUMBYTES: Na, SYMS: li, BI: Em } = nS, { Buffer: Am } = ct(), La = Symbol("count"), Zi = Symbol("major type"), Bm = Symbol("error"), Nf = Symbol("not found"); function mc(t, e, r) { let i = []; return i[La] = r, i[li.PARENT] = t, i[Zi] = e, i } function aS(t, e) { let r = new Qo; return r[La] = -1, r[li.PARENT] = t, r[Zi] = e, r } var eh = class extends Error { constructor(e, r) { super(`Unexpected data: 0x${e.toString(16)}`); this.name = "UnexpectedDataError", this.byte = e, this.value = r } }; function th(t, e) { switch (typeof t) { case "function": return { options: {}, cb: t }; case "string": return { options: { encoding: t }, cb: e }; case "object": return { options: t || {}, cb: e }; default: throw new TypeError("Unknown option type") } } var Ct = class extends tS { constructor(e = {}) { let M = e, { tags: r = {}, max_depth: i = -1, preferWeb: n = !1, required: f = !1, encoding: h = "hex", extendedResults: c = !1, preventDuplicateKeys: y = !1 } = M, x = Mt(M, ["tags", "max_depth", "preferWeb", "required", "encoding", "extendedResults", "preventDuplicateKeys"]); super(Xe({ defaultEncoding: h }, x)); this.running = !0, this.max_depth = i, this.tags = r, this.preferWeb = n, this.extendedResults = c, this.required = f, this.preventDuplicateKeys = y, c && (this.bs.on("read", this._onRead.bind(this)), this.valueBytes = new Qo) } static nullcheck(e) { switch (e) { case li.NULL: return null; case li.UNDEFINED: return; case Nf: throw new Error("Value not found"); default: return e } } static decodeFirstSync(e, r = {}) { if (e == null) throw new TypeError("input required"); ({ options: r } = th(r)); let M = r, { encoding: i = "hex" } = M, n = Mt(M, ["encoding"]), f = new Ct(n), h = Nn.guessEncoding(e, i), c = f._parse(), y = c.next(); for (; !y.done;) { let E = h.read(y.value); if (E == null || E.length !== y.value) throw new Error("Insufficient data"); f.extendedResults && f.valueBytes.write(E), y = c.next(E) } let x = null; if (f.extendedResults) x = y.value, x.unused = h.read(); else if (x = Ct.nullcheck(y.value), h.length > 0) { let E = h.read(1); throw h.unshift(E), new eh(E[0], x) } return x } static decodeAllSync(e, r = {}) { if (e == null) throw new TypeError("input required"); ({ options: r } = th(r)); let y = r, { encoding: i = "hex" } = y, n = Mt(y, ["encoding"]), f = new Ct(n), h = Nn.guessEncoding(e, i), c = []; for (; h.length > 0;) { let x = f._parse(), M = x.next(); for (; !M.done;) { let E = h.read(M.value); if (E == null || E.length !== M.value) throw new Error("Insufficient data"); f.extendedResults && f.valueBytes.write(E), M = x.next(E) } c.push(Ct.nullcheck(M.value)) } return c } static decodeFirst(e, r = {}, i = null) { if (e == null) throw new TypeError("input required"); ({ options: r, cb: i } = th(r, i)); let E = r, { encoding: n = "hex", required: f = !1 } = E, h = Mt(E, ["encoding", "required"]), c = new Ct(h), y = Nf, x = Nn.guessEncoding(e, n), M = new Promise((A, B) => { c.on("data", T => { y = Ct.nullcheck(T), c.close() }), c.once("error", T => c.extendedResults && T instanceof eh ? (y.unused = c.bs.slice(), A(y)) : (y !== Nf && (T.value = y), y = Bm, c.close(), B(T))), c.once("end", () => { switch (y) { case Nf: return f ? B(new Error("No CBOR found")) : A(y); case Bm: return; default: return A(y) } }) }); return typeof i == "function" && M.then(A => i(null, A), i), x.pipe(c), M } static decodeAll(e, r = {}, i = null) { if (e == null) throw new TypeError("input required"); ({ options: r, cb: i } = th(r, i)); let x = r, { encoding: n = "hex" } = x, f = Mt(x, ["encoding"]), h = new Ct(f), c = []; h.on("data", M => c.push(Ct.nullcheck(M))); let y = new Promise((M, E) => { h.on("error", E), h.on("end", () => M(c)) }); return typeof i == "function" && y.then(M => i(void 0, M), M => i(M, void 0)), Nn.guessEncoding(e, n).pipe(h), y } close() { this.running = !1, this.__fresh = !0 } _onRead(e) { this.valueBytes.write(e) } *_parse() { let e = null, r = 0, i = null; for (; ;) { if (this.max_depth >= 0 && r > this.max_depth) throw new Error(`Maximum depth ${this.max_depth} exceeded`); let [n] = yield 1; if (!this.running) throw this.bs.unshift(Am.from([n])), new eh(n); let f = n >> 5, h = n & 31, c = e == null ? void 0 : e[Zi], y = e == null ? void 0 : e.length; switch (h) { case Na.ONE: this.emit("more-bytes", f, 1, c, y), [i] = yield 1; break; case Na.TWO: case Na.FOUR: case Na.EIGHT: { let M = 1 << h - 24; this.emit("more-bytes", f, M, c, y); let E = yield M; i = f === tt.SIMPLE_FLOAT ? E : Nn.parseCBORint(h, E); break } case 28: case 29: case 30: throw this.running = !1, new Error(`Additional info not implemented: ${h}`); case Na.INDEFINITE: switch (f) { case tt.POS_INT: case tt.NEG_INT: case tt.TAG: throw new Error(`Invalid indefinite encoding for MT ${f}`) }i = -1; break; default: i = h }switch (f) { case tt.POS_INT: break; case tt.NEG_INT: i === Number.MAX_SAFE_INTEGER ? i = Em.NEG_MAX : i = typeof i == "bigint" ? Em.MINUS_ONE - i : -1 - i; break; case tt.BYTE_STRING: case tt.UTF8_STRING: switch (i) { case 0: this.emit("start-string", f, i, c, y), f === tt.UTF8_STRING ? i = "" : i = this.preferWeb ? new Uint8Array(0) : Am.allocUnsafe(0); break; case -1: this.emit("start", f, li.STREAM, c, y), e = aS(e, f), r++; continue; default: this.emit("start-string", f, i, c, y), i = yield i, f === tt.UTF8_STRING ? i = Nn.utf8(i) : this.preferWeb && (i = new Uint8Array(i.buffer, i.byteOffset, i.length)) }break; case tt.ARRAY: case tt.MAP: switch (i) { case 0: i = f === tt.MAP ? {} : []; break; case -1: this.emit("start", f, li.STREAM, c, y), e = mc(e, f, -1), r++; continue; default: this.emit("start", f, i, c, y), e = mc(e, f, i * (f - 3)), r++; continue }break; case tt.TAG: this.emit("start", f, i, c, y), e = mc(e, f, 1), e.push(i), r++; continue; case tt.SIMPLE_FLOAT: if (typeof i == "number") { if (h === Na.ONE && i < 32) throw new Error(`Invalid two-byte encoding of simple value ${i}`); let M = e != null; i = iS.decode(i, M, M && e[La] < 0) } else i = Nn.parseCBORfloat(i) }this.emit("value", i, c, y, h); let x = !1; for (; e != null;) { if (i === li.BREAK) e[La] = 1; else if (Array.isArray(e)) e.push(i); else { let E = e[Zi]; if (E != null && E !== f) throw this.running = !1, new Error("Invalid major type in indefinite encoding"); e.write(i) } if (--e[La] != 0) { x = !0; break } if (--r, delete e[La], Array.isArray(e)) switch (e[Zi]) { case tt.ARRAY: i = e; break; case tt.MAP: { let E = !0; if (e.length % 2 != 0) throw new Error(`Invalid map length: ${e.length}`); for (let A = 0, B = e.length; A < B; A += 2)if (typeof e[A] != "string" || e[A] === "__proto__") { E = !1; break } if (E) { i = {}; for (let A = 0, B = e.length; A < B; A += 2) { if (this.preventDuplicateKeys && Object.prototype.hasOwnProperty.call(i, e[A])) throw new Error("Duplicate keys in a map"); i[e[A]] = e[A + 1] } } else { i = new Map; for (let A = 0, B = e.length; A < B; A += 2) { if (this.preventDuplicateKeys && i.has(e[A])) throw new Error("Duplicate keys in a map"); i.set(e[A], e[A + 1]) } } break } case tt.TAG: { i = new rS(e[0], e[1]).convert(this.tags); break } } else if (e instanceof Qo) switch (e[Zi]) { case tt.BYTE_STRING: i = e.slice(), this.preferWeb && (i = new Uint8Array(i.buffer, i.byteOffset, i.length)); break; case tt.UTF8_STRING: i = e.toString("utf-8"); break }this.emit("stop", e[Zi]); let M = e; e = e[li.PARENT], delete M[li.PARENT], delete M[Zi] } if (!x) { if (this.extendedResults) { let M = this.valueBytes.slice(), E = { value: Ct.nullcheck(i), bytes: M, length: M.length }; return this.valueBytes = new Qo, E } return i } } } }; Ct.NOT_FOUND = Nf; Im.exports = Ct }); var km = I((gI, qm) => {
          "use strict"; var fS = Zr(), Rm = Da(), sS = Lf(), Tm = Fn(), { MT: ut, NUMBYTES: rh, SYMS: gc } = di(), { Buffer: oS } = ct(); function wc(t) { return t > 1 ? "s" : "" } function hS(t, e) { switch (typeof t) { case "function": return { options: {}, cb: t }; case "string": return { options: { encoding: t }, cb: e }; case "number": return { options: { max_depth: t }, cb: e }; case "object": return { options: t || {}, cb: e }; default: throw new TypeError("Unknown option type") } } var Hf = class extends fS.Transform {
            constructor(e = {}) { let x = e, { depth: r = 1, max_depth: i = 10, no_summary: n = !1, tags: f = {}, preferWeb: h, encoding: c } = x, y = Mt(x, ["depth", "max_depth", "no_summary", "tags", "preferWeb", "encoding"]); super(vr(Xe({}, y), { readableObjectMode: !1, writableObjectMode: !1 })); this.depth = r, this.max_depth = i, this.all = new Tm, f[24] || (f[24] = this._tag_24.bind(this)), this.parser = new sS({ tags: f, max_depth: i, preferWeb: h, encoding: c }), this.parser.on("value", this._on_value.bind(this)), this.parser.on("start", this._on_start.bind(this)), this.parser.on("start-string", this._on_start_string.bind(this)), this.parser.on("stop", this._on_stop.bind(this)), this.parser.on("more-bytes", this._on_more.bind(this)), this.parser.on("error", this._on_error.bind(this)), n || this.parser.on("data", this._on_data.bind(this)), this.parser.bs.on("read", this._on_read.bind(this)) } _tag_24(e) { let r = new Hf({ depth: this.depth + 1, no_summary: !0 }); r.on("data", i => this.push(i)), r.on("error", i => this.emit("error", i)), r.end(e) } _transform(e, r, i) { this.parser.write(e, r, i) } _flush(e) { return this.parser._flush(e) } static comment(e, r = {}, i = null) { if (e == null) throw new Error("input required"); ({ options: r, cb: i } = hS(r, i)); let n = new Tm, x = r, { encoding: f = "hex" } = x, h = Mt(x, ["encoding"]), c = new Hf(h), y = null; return typeof i == "function" ? (c.on("end", () => { i(null, n.toString("utf8")) }), c.on("error", i)) : y = new Promise((M, E) => { c.on("end", () => { M(n.toString("utf8")) }), c.on("error", E) }), c.pipe(n), Rm.guessEncoding(e, f).pipe(c), y } _on_error(e) {
              this.push("ERROR: "), this.push(e.toString()), this.push(`
`)
            } _on_read(e) { this.all.write(e); let r = e.toString("hex"); this.push(new Array(this.depth + 1).join("  ")), this.push(r); let i = (this.max_depth - this.depth) * 2 - r.length; i < 1 && (i = 1), this.push(new Array(i + 1).join(" ")), this.push("-- ") } _on_more(e, r, i, n) {
              let f = ""; switch (this.depth++, e) { case ut.POS_INT: f = "Positive number,"; break; case ut.NEG_INT: f = "Negative number,"; break; case ut.ARRAY: f = "Array, length"; break; case ut.MAP: f = "Map, count"; break; case ut.BYTE_STRING: f = "Bytes, length"; break; case ut.UTF8_STRING: f = "String, length"; break; case ut.SIMPLE_FLOAT: r === 1 ? f = "Simple value," : f = "Float,"; break }this.push(`${f} next ${r} byte${wc(r)}
`)
            } _on_start_string(e, r, i, n) {
              let f = ""; switch (this.depth++, e) { case ut.BYTE_STRING: f = `Bytes, length: ${r}`; break; case ut.UTF8_STRING: f = `String, length: ${r.toString()}`; break }this.push(`${f}
`)
            } _on_start(e, r, i, n) {
              switch (this.depth++, i) { case ut.ARRAY: this.push(`[${n}], `); break; case ut.MAP: n % 2 ? this.push(`{Val:${Math.floor(n / 2)}}, `) : this.push(`{Key:${Math.floor(n / 2)}}, `); break }switch (e) { case ut.TAG: this.push(`Tag #${r}`), r === 24 && this.push(" Encoded CBOR data item"); break; case ut.ARRAY: r === gc.STREAM ? this.push("Array (streaming)") : this.push(`Array, ${r} item${wc(r)}`); break; case ut.MAP: r === gc.STREAM ? this.push("Map (streaming)") : this.push(`Map, ${r} pair${wc(r)}`); break; case ut.BYTE_STRING: this.push("Bytes (streaming)"); break; case ut.UTF8_STRING: this.push("String (streaming)"); break }this.push(`
`)
            } _on_stop(e) { this.depth-- } _on_value(e, r, i, n) {
              if (e !== gc.BREAK) switch (r) { case ut.ARRAY: this.push(`[${i}], `); break; case ut.MAP: i % 2 ? this.push(`{Val:${Math.floor(i / 2)}}, `) : this.push(`{Key:${Math.floor(i / 2)}}, `); break }let f = Rm.cborValueToString(e, -Infinity); switch (typeof e == "string" || oS.isBuffer(e) ? (e.length > 0 && (this.push(f), this.push(`
`)), this.depth--) : (this.push(f), this.push(`
`)), n) { case rh.ONE: case rh.TWO: case rh.FOUR: case rh.EIGHT: this.depth-- }
            } _on_data() {
              this.push("0x"), this.push(this.all.read().toString("hex")), this.push(`
`)
            }
          }; qm.exports = Hf
        }); var Dm = I((wI, Om) => {
          "use strict"; var uS = Zr(), cS = Lf(), Pm = Da(), dS = Fn(), { MT: xt, SYMS: Cm } = di(); function lS(t, e) { switch (typeof t) { case "function": return { options: {}, cb: t }; case "string": return { options: { encoding: t }, cb: e }; case "object": return { options: t || {}, cb: e }; default: throw new TypeError("Unknown option type") } } var ih = class extends uS.Transform {
            constructor(e = {}) {
              let x = e, { separator: r = `
`, stream_errors: i = !1, tags: n, max_depth: f, preferWeb: h, encoding: c } = x, y = Mt(x, ["separator", "stream_errors", "tags", "max_depth", "preferWeb", "encoding"]); super(vr(Xe({}, y), { readableObjectMode: !1, writableObjectMode: !1 })); this.float_bytes = -1, this.separator = r, this.stream_errors = i, this.parser = new cS({ tags: n, max_depth: f, preferWeb: h, encoding: c }), this.parser.on("more-bytes", this._on_more.bind(this)), this.parser.on("value", this._on_value.bind(this)), this.parser.on("start", this._on_start.bind(this)), this.parser.on("stop", this._on_stop.bind(this)), this.parser.on("data", this._on_data.bind(this)), this.parser.on("error", this._on_error.bind(this))
            } _transform(e, r, i) { return this.parser.write(e, r, i) } _flush(e) { return this.parser._flush(r => this.stream_errors ? (r && this._on_error(r), e()) : e(r)) } static diagnose(e, r = {}, i = null) { if (e == null) throw new TypeError("input required"); ({ options: r, cb: i } = lS(r, i)); let x = r, { encoding: n = "hex" } = x, f = Mt(x, ["encoding"]), h = new dS, c = new ih(f), y = null; return typeof i == "function" ? (c.on("end", () => i(null, h.toString("utf8"))), c.on("error", i)) : y = new Promise((M, E) => { c.on("end", () => M(h.toString("utf8"))), c.on("error", E) }), c.pipe(h), Pm.guessEncoding(e, n).pipe(c), y } _on_error(e) { this.stream_errors ? this.push(e.toString()) : this.emit("error", e) } _on_more(e, r, i, n) { e === xt.SIMPLE_FLOAT && (this.float_bytes = { 2: 1, 4: 2, 8: 3 }[r]) } _fore(e, r) { switch (e) { case xt.BYTE_STRING: case xt.UTF8_STRING: case xt.ARRAY: r > 0 && this.push(", "); break; case xt.MAP: r > 0 && (r % 2 ? this.push(": ") : this.push(", ")) } } _on_value(e, r, i) { if (e === Cm.BREAK) return; this._fore(r, i); let n = this.float_bytes; this.float_bytes = -1, this.push(Pm.cborValueToString(e, n)) } _on_start(e, r, i, n) { switch (this._fore(i, n), e) { case xt.TAG: this.push(`${r}(`); break; case xt.ARRAY: this.push("["); break; case xt.MAP: this.push("{"); break; case xt.BYTE_STRING: case xt.UTF8_STRING: this.push("("); break }r === Cm.STREAM && this.push("_ ") } _on_stop(e) { switch (e) { case xt.TAG: this.push(")"); break; case xt.ARRAY: this.push("]"); break; case xt.MAP: this.push("}"); break; case xt.BYTE_STRING: case xt.UTF8_STRING: this.push(")"); break } } _on_data() { this.push(this.separator) }
          }; Om.exports = ih
        }); var xc = I((_I, Lm) => {
          "use strict"; var pS = Zr(), _c = Fn(), nh = Da(), vS = di(), { MT: Ge, NUMBYTES: Ot, SHIFT32: Fm, SIMPLE: ah, SYMS: Um, TAG: pi, BI: fh } = vS, { Buffer: nt } = ct(), bS = Ge.SIMPLE_FLOAT << 5 | Ot.TWO, yS = Ge.SIMPLE_FLOAT << 5 | Ot.FOUR, mS = Ge.SIMPLE_FLOAT << 5 | Ot.EIGHT, gS = Ge.SIMPLE_FLOAT << 5 | ah.TRUE, wS = Ge.SIMPLE_FLOAT << 5 | ah.FALSE, _S = Ge.SIMPLE_FLOAT << 5 | ah.UNDEFINED, xS = Ge.SIMPLE_FLOAT << 5 | ah.NULL, jf = nt.from([255]), MS = nt.from("f97e00", "hex"), SS = nt.from("f9fc00", "hex"), ES = nt.from("f97c00", "hex"), AS = nt.from("f98000", "hex"), sh = {}, Nm = {}; function BS(t) { if (!t) return "number"; switch (t.toLowerCase()) { case "number": return "number"; case "float": return "float"; case "int": case "integer": return "int"; case "string": return "string" }throw new TypeError(`dateType invalid, got "${t}"`) } var Ae = class extends pS.Transform {
            constructor(e = {}) { let E = e, { canonical: r = !1, encodeUndefined: i, disallowUndefinedKeys: n = !1, dateType: f = "number", collapseBigIntegers: h = !1, detectLoops: c = !1, omitUndefinedProperties: y = !1, genTypes: x = [] } = E, M = Mt(E, ["canonical", "encodeUndefined", "disallowUndefinedKeys", "dateType", "collapseBigIntegers", "detectLoops", "omitUndefinedProperties", "genTypes"]); super(vr(Xe({}, M), { readableObjectMode: !1, writableObjectMode: !0 })); if (this.canonical = r, this.encodeUndefined = i, this.disallowUndefinedKeys = n, this.dateType = BS(f), this.collapseBigIntegers = this.canonical ? !0 : h, this.detectLoops = void 0, typeof c == "boolean") c && (this.detectLoops = new WeakSet); else if (c instanceof WeakSet) this.detectLoops = c; else throw new TypeError("detectLoops must be boolean or WeakSet"); if (this.omitUndefinedProperties = y, this.semanticTypes = Xe({}, Ae.SEMANTIC_TYPES), Array.isArray(x)) for (let A = 0, B = x.length; A < B; A += 2)this.addSemanticType(x[A], x[A + 1]); else for (let [A, B] of Object.entries(x)) this.addSemanticType(A, B) } _transform(e, r, i) { let n = this.pushAny(e); return i(n === !1 ? new Error("Push Error") : void 0) } _flush(e) { return e() } _pushUInt8(e) { let r = nt.allocUnsafe(1); return r.writeUInt8(e, 0), this.push(r) } _pushUInt16BE(e) { let r = nt.allocUnsafe(2); return r.writeUInt16BE(e, 0), this.push(r) } _pushUInt32BE(e) { let r = nt.allocUnsafe(4); return r.writeUInt32BE(e, 0), this.push(r) } _pushFloatBE(e) { let r = nt.allocUnsafe(4); return r.writeFloatBE(e, 0), this.push(r) } _pushDoubleBE(e) { let r = nt.allocUnsafe(8); return r.writeDoubleBE(e, 0), this.push(r) } _pushNaN() { return this.push(MS) } _pushInfinity(e) { let r = e < 0 ? SS : ES; return this.push(r) } _pushFloat(e) { if (this.canonical) { let r = nt.allocUnsafe(2); if (nh.writeHalf(r, e)) return this._pushUInt8(bS) && this.push(r) } return Math.fround(e) === e ? this._pushUInt8(yS) && this._pushFloatBE(e) : this._pushUInt8(mS) && this._pushDoubleBE(e) } _pushInt(e, r, i) { let n = r << 5; if (e < 24) return this._pushUInt8(n | e); if (e <= 255) return this._pushUInt8(n | Ot.ONE) && this._pushUInt8(e); if (e <= 65535) return this._pushUInt8(n | Ot.TWO) && this._pushUInt16BE(e); if (e <= 4294967295) return this._pushUInt8(n | Ot.FOUR) && this._pushUInt32BE(e); let f = Number.MAX_SAFE_INTEGER; return r === Ge.NEG_INT && f--, e <= f ? this._pushUInt8(n | Ot.EIGHT) && this._pushUInt32BE(Math.floor(e / Fm)) && this._pushUInt32BE(e % Fm) : r === Ge.NEG_INT ? this._pushFloat(i) : this._pushFloat(e) } _pushIntNum(e) { return Object.is(e, -0) ? this.push(AS) : e < 0 ? this._pushInt(-e - 1, Ge.NEG_INT, e) : this._pushInt(e, Ge.POS_INT) } _pushNumber(e) { return isNaN(e) ? this._pushNaN() : isFinite(e) ? Math.round(e) === e ? this._pushIntNum(e) : this._pushFloat(e) : this._pushInfinity(e) } _pushString(e) { let r = nt.byteLength(e, "utf8"); return this._pushInt(r, Ge.UTF8_STRING) && this.push(e, "utf8") } _pushBoolean(e) { return this._pushUInt8(e ? gS : wS) } _pushUndefined(e) { switch (typeof this.encodeUndefined) { case "undefined": return this._pushUInt8(_S); case "function": return this.pushAny(this.encodeUndefined(e)); case "object": { let r = nh.bufferishToBuffer(this.encodeUndefined); if (r) return this.push(r) } }return this.pushAny(this.encodeUndefined) } _pushNull(e) { return this._pushUInt8(xS) } _pushTag(e) { return this._pushInt(e, Ge.TAG) } _pushJSBigint(e) { let r = Ge.POS_INT, i = pi.POS_BIGINT; if (e < 0 && (e = -e + fh.MINUS_ONE, r = Ge.NEG_INT, i = pi.NEG_BIGINT), this.collapseBigIntegers && e <= fh.MAXINT64) return e <= 4294967295 ? this._pushInt(Number(e), r) : this._pushUInt8(r << 5 | Ot.EIGHT) && this._pushUInt32BE(Number(e / fh.SHIFT32)) && this._pushUInt32BE(Number(e % fh.SHIFT32)); let n = e.toString(16); n.length % 2 && (n = `0${n}`); let f = nt.from(n, "hex"); return this._pushTag(i) && Ae._pushBuffer(this, f) } _pushObject(e, r) {
              if (!e) return this._pushNull(e); if (r = Xe({ indefinite: !1, skipTypes: !1 }, r), !r.indefinite && this.detectLoops) {
                if (this.detectLoops.has(e)) throw new Error(`Loop detected while CBOR encoding.
Call removeLoopDetectors before resuming.`); this.detectLoops.add(e)
              } if (!r.skipTypes) { let h = e.encodeCBOR; if (typeof h == "function") return h.call(e, this); if (nt.isBuffer(e)) return this.semanticTypes[nt.name].call(e, this, e); let c = this.semanticTypes[e.constructor.name]; if (c) return c.call(e, this, e) } let i = Object.keys(e).filter(h => { let c = typeof e[h]; return c !== "function" && (!this.omitUndefinedProperties || c !== "undefined") }), n = {}; if (this.canonical && i.sort((h, c) => { let y = n[h] || (n[h] = Ae.encode(h)), x = n[c] || (n[c] = Ae.encode(c)); return y.compare(x) }), r.indefinite) { if (!this._pushUInt8(Ge.MAP << 5 | Ot.INDEFINITE)) return !1 } else if (!this._pushInt(i.length, Ge.MAP)) return !1; let f = null; for (let h = 0, c = i.length; h < c; h++) { let y = i[h]; if (this.canonical && (f = n[y])) { if (!this.push(f)) return !1 } else if (!this._pushString(y)) return !1; if (!this.pushAny(e[y])) return !1 } if (r.indefinite) { if (!this.push(jf)) return !1 } else this.detectLoops && this.detectLoops.delete(e); return !0
            } _encodeAll(e) { let r = new _c({ highWaterMark: this.readableHighWaterMark }); this.pipe(r); for (let i of e) this.pushAny(i); return this.end(), r.read() } addSemanticType(e, r) { let i = typeof e == "string" ? e : e.name, n = this.semanticTypes[i]; if (r) { if (typeof r != "function") throw new TypeError("fun must be of type function"); this.semanticTypes[i] = r } else n && delete this.semanticTypes[i]; return n } pushAny(e) { switch (typeof e) { case "number": return this._pushNumber(e); case "bigint": return this._pushJSBigint(e); case "string": return this._pushString(e); case "boolean": return this._pushBoolean(e); case "undefined": return this._pushUndefined(e); case "object": return this._pushObject(e); case "symbol": switch (e) { case Um.NULL: return this._pushNull(null); case Um.UNDEFINED: return this._pushUndefined(void 0); default: throw new TypeError(`Unknown symbol: ${e.toString()}`) }default: throw new TypeError(`Unknown type: ${typeof e}, ${typeof e.toString == "function" ? e.toString() : ""}`) } } static pushArray(e, r, i) { i = Xe({ indefinite: !1 }, i); let n = r.length; if (i.indefinite) { if (!e._pushUInt8(Ge.ARRAY << 5 | Ot.INDEFINITE)) return !1 } else if (!e._pushInt(n, Ge.ARRAY)) return !1; for (let f = 0; f < n; f++)if (!e.pushAny(r[f])) return !1; return !(i.indefinite && !e.push(jf)) } removeLoopDetectors() { return this.detectLoops ? (this.detectLoops = new WeakSet, !0) : !1 } static _pushDate(e, r) { switch (e.dateType) { case "string": return e._pushTag(pi.DATE_STRING) && e._pushString(r.toISOString()); case "int": return e._pushTag(pi.DATE_EPOCH) && e._pushIntNum(Math.round(r.getTime() / 1e3)); case "float": return e._pushTag(pi.DATE_EPOCH) && e._pushFloat(r.getTime() / 1e3); case "number": default: return e._pushTag(pi.DATE_EPOCH) && e.pushAny(r.getTime() / 1e3) } } static _pushBuffer(e, r) { return e._pushInt(r.length, Ge.BYTE_STRING) && e.push(r) } static _pushNoFilter(e, r) { return Ae._pushBuffer(e, r.slice()) } static _pushRegexp(e, r) { return e._pushTag(pi.REGEXP) && e.pushAny(r.source) } static _pushSet(e, r) { if (!e._pushTag(pi.SET) || !e._pushInt(r.size, Ge.ARRAY)) return !1; for (let i of r) if (!e.pushAny(i)) return !1; return !0 } static _pushURL(e, r) { return e._pushTag(pi.URI) && e.pushAny(r.toString()) } static _pushBoxed(e, r) { return e.pushAny(r.valueOf()) } static _pushMap(e, r, i) { i = Xe({ indefinite: !1 }, i); let n = [...r.entries()]; if (e.omitUndefinedProperties && (n = n.filter(([f, h]) => h !== void 0)), i.indefinite) { if (!e._pushUInt8(Ge.MAP << 5 | Ot.INDEFINITE)) return !1 } else if (!e._pushInt(n.length, Ge.MAP)) return !1; if (e.canonical) { let f = new Ae({ genTypes: e.semanticTypes, canonical: e.canonical, detectLoops: Boolean(e.detectLoops), dateType: e.dateType, disallowUndefinedKeys: e.disallowUndefinedKeys, collapseBigIntegers: e.collapseBigIntegers }), h = new _c({ highWaterMark: e.readableHighWaterMark }); f.pipe(h), n.sort(([c], [y]) => { f.pushAny(c); let x = h.read(); f.pushAny(y); let M = h.read(); return x.compare(M) }); for (let [c, y] of n) { if (e.disallowUndefinedKeys && typeof c == "undefined") throw new Error("Invalid Map key: undefined"); if (!(e.pushAny(c) && e.pushAny(y))) return !1 } } else for (let [f, h] of n) { if (e.disallowUndefinedKeys && typeof f == "undefined") throw new Error("Invalid Map key: undefined"); if (!(e.pushAny(f) && e.pushAny(h))) return !1 } return !(i.indefinite && !e.push(jf)) } static _pushTypedArray(e, r) { let i = 64, n = r.BYTES_PER_ELEMENT, { name: f } = r.constructor; return f.startsWith("Float") ? (i |= 16, n /= 2) : f.includes("U") || (i |= 8), (f.includes("Clamped") || n !== 1 && !nh.isBigEndian()) && (i |= 4), i |= { 1: 0, 2: 1, 4: 2, 8: 3 }[n], e._pushTag(i) ? Ae._pushBuffer(e, nt.from(r.buffer, r.byteOffset, r.byteLength)) : !1 } static _pushArrayBuffer(e, r) { return Ae._pushBuffer(e, nt.from(r)) } static encodeIndefinite(e, r, i = {}) { if (r == null) { if (this == null) throw new Error("No object to encode"); r = this } let { chunkSize: n = 4096 } = i, f = !0, h = typeof r, c = null; if (h === "string") { f = f && e._pushUInt8(Ge.UTF8_STRING << 5 | Ot.INDEFINITE); let y = 0; for (; y < r.length;) { let x = y + n; f = f && e._pushString(r.slice(y, x)), y = x } f = f && e.push(jf) } else if (c = nh.bufferishToBuffer(r)) { f = f && e._pushUInt8(Ge.BYTE_STRING << 5 | Ot.INDEFINITE); let y = 0; for (; y < c.length;) { let x = y + n; f = f && Ae._pushBuffer(e, c.slice(y, x)), y = x } f = f && e.push(jf) } else if (Array.isArray(r)) f = f && Ae.pushArray(e, r, { indefinite: !0 }); else if (r instanceof Map) f = f && Ae._pushMap(e, r, { indefinite: !0 }); else { if (h !== "object") throw new Error("Invalid indefinite encoding"); f = f && e._pushObject(r, { indefinite: !0, skipTypes: !0 }) } return f } static encode(...e) { return new Ae()._encodeAll(e) } static encodeCanonical(...e) { return new Ae({ canonical: !0 })._encodeAll(e) } static encodeOne(e, r) { return new Ae(r)._encodeAll([e]) } static encodeAsync(e, r) { return new Promise((i, n) => { let f = [], h = new Ae(r); h.on("data", c => f.push(c)), h.on("error", n), h.on("finish", () => i(nt.concat(f))), h.pushAny(e), h.end() }) } static get SEMANTIC_TYPES() { return Nm } static set SEMANTIC_TYPES(e) { Nm = e } static reset() { Ae.SEMANTIC_TYPES = Xe({}, sh) }
          }; Object.assign(sh, { Array: Ae.pushArray, Date: Ae._pushDate, Buffer: Ae._pushBuffer, [nt.name]: Ae._pushBuffer, Map: Ae._pushMap, NoFilter: Ae._pushNoFilter, [_c.name]: Ae._pushNoFilter, RegExp: Ae._pushRegexp, Set: Ae._pushSet, ArrayBuffer: Ae._pushArrayBuffer, Uint8ClampedArray: Ae._pushTypedArray, Uint8Array: Ae._pushTypedArray, Uint16Array: Ae._pushTypedArray, Uint32Array: Ae._pushTypedArray, Int8Array: Ae._pushTypedArray, Int16Array: Ae._pushTypedArray, Int32Array: Ae._pushTypedArray, Float32Array: Ae._pushTypedArray, Float64Array: Ae._pushTypedArray, URL: Ae._pushURL, Boolean: Ae._pushBoxed, Number: Ae._pushBoxed, String: Ae._pushBoxed }); typeof BigUint64Array != "undefined" && (sh[BigUint64Array.name] = Ae._pushTypedArray); typeof BigInt64Array != "undefined" && (sh[BigInt64Array.name] = Ae._pushTypedArray); Ae.reset(); Lm.exports = Ae
        }); var zm = I((xI, jm) => { "use strict"; var { Buffer: Hm } = ct(), IS = xc(), RS = Lf(), { MT: TS } = di(), Kr = class extends Map { constructor(e) { super(e) } static _encode(e) { return IS.encodeCanonical(e).toString("base64") } static _decode(e) { return RS.decodeFirstSync(e, "base64") } get(e) { return super.get(Kr._encode(e)) } set(e, r) { return super.set(Kr._encode(e), r) } delete(e) { return super.delete(Kr._encode(e)) } has(e) { return super.has(Kr._encode(e)) } *keys() { for (let e of super.keys()) yield Kr._decode(e) } *entries() { for (let e of super.entries()) yield [Kr._decode(e[0]), e[1]] } [Symbol.iterator]() { return this.entries() } forEach(e, r) { if (typeof e != "function") throw new TypeError("Must be function"); for (let i of super.entries()) e.call(this, i[1], Kr._decode(i[0]), this) } encodeCBOR(e) { if (!e._pushInt(this.size, TS.MAP)) return !1; if (e.canonical) { let r = Array.from(super.entries()).map(i => [Hm.from(i[0], "base64"), i[1]]); r.sort((i, n) => i[0].compare(n[0])); for (let i of r) if (!(e.push(i[0]) && e.pushAny(i[1]))) return !1 } else for (let r of super.entries()) if (!(e.push(Hm.from(r[0], "base64")) && e.pushAny(r[1]))) return !1; return !0 } }; jm.exports = Kr }); var Wm = I(Fe => { "use strict"; Fe.Commented = km(); Fe.Diagnose = Dm(); Fe.Decoder = Lf(); Fe.Encoder = xc(); Fe.Simple = yc(); Fe.Tagged = vc(); Fe.Map = zm(); Fe.comment = Fe.Commented.comment; Fe.decodeAll = Fe.Decoder.decodeAll; Fe.decodeFirst = Fe.Decoder.decodeFirst; Fe.decodeAllSync = Fe.Decoder.decodeAllSync; Fe.decodeFirstSync = Fe.Decoder.decodeFirstSync; Fe.diagnose = Fe.Diagnose.diagnose; Fe.encode = Fe.Encoder.encode; Fe.encodeCanonical = Fe.Encoder.encodeCanonical; Fe.encodeOne = Fe.Encoder.encodeOne; Fe.encodeAsync = Fe.Encoder.encodeAsync; Fe.decode = Fe.Decoder.decodeFirstSync; Fe.leveldb = { decode: Fe.Decoder.decodeFirstSync, encode: Fe.Encoder.encode, buffer: !0, name: "cbor" }; Fe.reset = function () { Fe.Encoder.reset(), Fe.Tagged.reset() } }); Rc(exports); b6(exports, { DID_DOCUMENTS: () => Ec, TRUSTED_ISSUERS: () => Ac, verifyPassURI: () => n6, verifyPassURIOffline: () => i6 }); var tn = qi(Oc()), zS = tn.default.base16, Dc = tn.default.base32, WS = tn.default.base32hex, KS = tn.default.base64, VS = tn.default.base64url, GS = tn.default.codec; function S6(t, e) { try { var r = t() } catch (i) { return e(i) } return r && r.then ? r.then(void 0, e) : r } function E6() { let t = new Map; return function (e, r) { try { let n = function (h) { if (i) return h; let c = t.get(e.didUrl); return c !== void 0 ? c : Promise.resolve(r()).then(function (y) { var x; return ((x = y.didResolutionMetadata) == null ? void 0 : x.error) !== "notFound" && t.set(e.didUrl, y), y }) }, i, f = function () { if (e.params && e.params["no-cache"] === "true") return i = 1, Promise.resolve(r()) }(); return Promise.resolve(f && f.then ? f.then(n) : n(f)) } catch (i) { return Promise.reject(i) } } } function A6(t, e) { return e() } var B6 = "(?:%[0-9a-fA-F]{2})", Fc = `(?:[a-zA-Z0-9._-]|${B6})`, I6 = "([a-z0-9]+)", R6 = `((?:${Fc}*:)*(${Fc}+))`, Uc = "[a-zA-Z0-9_.:%-]", T6 = `;${Uc}+=${Uc}*`, q6 = `((${T6})*)`, k6 = "(/[^#?]*)?", P6 = "([?][^#]*)?", C6 = "(#.*)?", O6 = new RegExp(`^did:${I6}:${R6}${q6}${k6}${P6}${C6}$`); function D6(t) { if (t === "" || !t) return null; let e = t.match(O6); if (e) { let r = { did: `did:${e[1]}:${e[2]}`, method: e[1], id: e[2], didUrl: t }; if (e[4]) { let i = e[4].slice(1).split(";"); r.params = {}; for (let n of i) { let f = n.split("="); r.params[f[0]] = f[1] } } return e[6] && (r.path = e[6]), e[7] && (r.query = e[7].slice(1)), e[8] && (r.fragment = e[8].slice(1)), r } return null } var Gf = { didResolutionMetadata: {}, didDocument: null, didDocumentMetadata: {} }; function F6(t) { return function (e, r, i) { try { return Promise.resolve(S6(function () { return Promise.resolve(t(e, r, i)).then(function (n) { return vr(Xe({}, Gf), { didResolutionMetadata: { contentType: "application/did+ld+json" }, didDocument: n }) }) }, function (n) { return vr(Xe({}, Gf), { didResolutionMetadata: { error: "notFound", message: n.toString() } }) })) } catch (n) { return Promise.reject(n) } } } var uh = class { constructor(e = {}, r = {}) { this.registry = void 0, this.cache = void 0, this.registry = e, this.cache = r.cache === !0 ? E6() : r.cache || A6, r.legacyResolvers && Object.keys(r.legacyResolvers).map(i => { this.registry[i] || (this.registry[i] = F6(r.legacyResolvers[i])) }) } resolve(e, r = {}) { try { let i = this, n = D6(e); if (n === null) return Promise.resolve(vr(Xe({}, Gf), { didResolutionMetadata: { error: "invalidDid" } })); let f = i.registry[n.method]; return f ? Promise.resolve(i.cache(n, () => f(n.did, n, i, r))) : Promise.resolve(vr(Xe({}, Gf), { didResolutionMetadata: { error: "unsupportedDidMethod" } })) } catch (i) { return Promise.reject(i) } } }; var jc = qi(Hc()); function U6(t, e) { try { var r = t() } catch (i) { return e(i) } return r && r.then ? r.then(void 0, e) : r } var N6 = function (t) { try { return Promise.resolve((0, jc.default)(t, { mode: "cors" })).then(function (e) { if (e.status >= 400) throw new Error(`Bad response ${e.statusText}`); return e.json() }) } catch (e) { return Promise.reject(e) } }; function Rt(t, e, r) { if (!t.s) { if (r instanceof ch) if (r.s) e & 1 && (e = r.s), r = r.v; else { r.o = Rt.bind(null, t, e); return } if (r && r.then) { r.then(Rt.bind(null, t, e), Rt.bind(null, t, 2)); return } t.s = e, t.v = r; let i = t.o; i && i(t) } } var L6 = "/.well-known/did.json", ch = function () { function t() { } return t.prototype.then = function (e, r) { let i = new t, n = this.s; if (n) { let f = n & 1 ? e : r; if (f) { try { Rt(i, 1, f(this.v)) } catch (h) { Rt(i, 2, h) } return i } else return this } return this.o = function (f) { try { let h = f.v; f.s & 1 ? Rt(i, 1, e ? e(h) : h) : r ? Rt(i, 1, r(h)) : Rt(i, 2, h) } catch (h) { Rt(i, 2, h) } }, i }, t }(); function zn(t) { return t instanceof ch && t.s & 1 } function H6(t, e) { var r; do { var i = t(); if (i && i.then) if (zn(i)) i = i.v; else { r = !0; break } var n = e(); if (zn(n) && (n = n.v), !n) return i } while (!n.then); let f = new ch, h = Rt.bind(null, f, 2); return (r ? i.then(c) : n.then(y)).then(void 0, h), f; function c(x) { for (i = x; n = e(), zn(n) && (n = n.v), !!n;) { if (n.then) { n.then(y).then(void 0, h); return } if (i = t(), i && i.then) if (zn(i)) i = i.v; else { i.then(c).then(void 0, h); return } } Rt(f, 1, i) } function y(x) { if (x) { do { if (i = t(), i && i.then) if (zn(i)) i = i.v; else { i.then(c).then(void 0, h); return } if (x = e(), zn(x) && (x = x.v), !x) { Rt(f, 1, i); return } } while (!x.then); x.then(y).then(void 0, h) } else Rt(f, 1, i) } } function zc() { return { web: function (e, r) { try { let n = function () { var A; let B = typeof ((A = M) == null ? void 0 : A["@context"]) != "undefined" ? "application/did+ld+json" : "application/did+json"; return f ? { didDocument: M, didDocumentMetadata: x, didResolutionMetadata: { error: "notFound", message: f } } : { didDocument: M, didDocumentMetadata: x, didResolutionMetadata: { contentType: B } } }, i, f = null, h = decodeURIComponent(r.id) + L6, c = r.id.split(":"); c.length > 1 && (h = c.map(decodeURIComponent).join("/") + "/did.json"); let y = `https://${h}`, x = {}, M = null, E = H6(function () { function A() { if (!i) { var T; ((T = M) == null ? void 0 : T.id) === e || (f = "resolver_error: DID document id does not match requested did") } } let B = U6(function () { return Promise.resolve(N6(y)).then(function (T) { M = T }) }, function (T) { f = `resolver_error: DID must resolve to a valid https URL containing a JSON document: ${T}`, i = 1 }); return B && B.then ? B.then(A) : A(B) }, function () { return !i && !1 }); return Promise.resolve(E && E.then ? E.then(n) : n(E)) } catch (i) { return Promise.reject(i) } } } } var j6 = zc(), z6 = new uh(Xe({}, j6)); function W6(t) { return Vf(this, null, function* () { return yield z6.resolve(t) }) } var Wc = { resolve: W6 }; function dh() { return Date.now() / 1e3 } function Kc(t) { let e = t; for (; e.length % 8 != 0;)e += "="; return e } var $m = qi(Vc()), Xm = qi(Ef()); var Km = qi(ct()), Vm = qi(dm()), Mc = qi(As()), Sc = qi(Wm()); window.Buffer = Km.Buffer; window.process = Vm.default; window.TextDecoder = Mc.default.TextDecoder; window.TextEncoder = Mc.default.TextEncoder; var Gm = t => Sc.default.encode(t), oh = t => Sc.default.decode(t); var qS = Xm.default.ec, kS = new qS("p256"); function Ym(t, e) { let [r, , i, n] = t.value; if (!e.x || !e.y) return !1; let f = Buffer.from(e.x, "base64"), h = Buffer.from(e.y, "base64"), c = `04${f.toString("hex")}${h.toString("hex")}`, y = kS.keyFromPublic(c, "hex"), x = Buffer.from(r), M = Buffer.alloc(0), E = Buffer.from(i), B = Gm(["Signature1", x, M, E]), T = $m.sha256.digest(B), C = { r: n.slice(0, n.length / 2), s: n.slice(n.length / 2) }; return y.verify(T, C) } var Oe = class extends Error { constructor(e, r = null) { super(e.message); this.violates = e, this.cwtClaims = r } }; function Zm(t) { if (t.length !== 16) throw new Oe({ message: `CTI must be 16 octets, but was ${t.length} octets.`, section: "RFC4122.4.1", link: "https://datatracker.ietf.org/doc/html/rfc4122#section-4.1", description: "The COVID Pass is malformed or has been modified." }); let e = t.toString("hex"), r = e.slice(0, 8), i = e.slice(8, 12), n = e.slice(12, 16), f = e.slice(16, 18), h = e.slice(18, 20), c = e.slice(20, 32); return `urn:uuid:${`${r}-${i}-${n}-${f}${h}-${c}`}` } function Jm(t) { let e = t.get(7), r; if (e) try { r = Zm(e) } catch (E) { } let i = t.get(1), n; i && typeof i == "string" && (n = i.toString()); let f = t.get(5), h; f && typeof f == "number" && (h = f); let c = t.get(4), y; c && typeof c == "number" && (y = c); let x = t.get("vc"), M; return x && (M = x), { jti: r, iss: n, nbf: h, exp: y, vc: M } } function Qm(t) { if (!t.jti) throw new Oe({ message: "CWT Token ID claim MUST be present", section: "2.1.0.1.1", link: "https://nzcp.covid19.health.nz/#cwt-claims", description: "The COVID Pass is malformed or has been modified." }); if (!t.iss) throw new Oe({ message: "Issuer claim MUST be present", section: "2.1.0.2.1", link: "https://nzcp.covid19.health.nz/#cwt-claims", description: "The COVID Pass is malformed or has been modified." }); if (!t.nbf) throw new Oe({ message: "Not Before claim MUST be present and MUST be a timestamp encoded as an integer in the NumericDate format (as specified in [RFC8392] section 2)", section: "2.1.0.3.1", link: "https://nzcp.covid19.health.nz/#cwt-claims", description: "The COVID Pass is malformed or has been modified." }); if (!t.exp) throw new Oe({ message: "Not Before claim MUST be present and MUST be a timestamp encoded as an integer in the NumericDate format (as specified in [RFC8392] section 2)", section: "2.1.0.4.1", link: "https://nzcp.covid19.health.nz/#cwt-claims", description: "The COVID Pass is malformed or has been modified." }); if (!(dh() >= t.nbf)) throw new Oe({ message: "The current datetime is after or equal to the value of the `nbf` claim", link: "https://nzcp.covid19.health.nz/#cwt-claims", section: "2.1.0.3.3", description: "The COVID Pass is not yet activated." }); if (!(dh() < t.exp)) throw new Oe({ message: "The current datetime is before the value of the `exp` claim", link: "https://nzcp.covid19.health.nz/#cwt-claims", section: "2.1.0.4.3", description: "The COVID Pass has expired." }); if (!t.vc) throw new Oe({ message: "Verifiable Credential CWT claim MUST be present", section: "2.1.0.5.1", link: "https://nzcp.covid19.health.nz/#cwt-claims", description: "The COVID Pass is malformed or has been modified." }); if (!(t.vc["@context"] instanceof Array && t.vc["@context"][0] === "https://www.w3.org/2018/credentials/v1" && t.vc["@context"][1] === "https://nzcp.covid19.health.nz/contexts/v1")) throw new Oe({ message: "Verifiable Credential JSON-LD Context property doesn't conform to New Zealand COVID Pass example", link: "https://nzcp.covid19.health.nz/#verifiable-credential-claim-structure", section: "2.3.2", description: "The COVID Pass is malformed or has been modified." }); if (!(t.vc.type instanceof Array && t.vc.type[0] === "VerifiableCredential" && t.vc.type[1] === "PublicCovidPass")) throw new Oe({ message: "Verifiable Credential Type property doesn't conform to New Zealand COVID Pass example", link: "https://nzcp.covid19.health.nz/#verifiable-credential-claim-structure", section: "2.3.5", description: "The COVID Pass is malformed or has been modified." }); if (t.vc.version !== "1.0.0") throw new Oe({ message: "Verifiable Credential Version property MUST be 1.0.0", link: "https://nzcp.covid19.health.nz/#verifiable-credential-claim-structure", section: "2.3.8", description: "The QR code is not a valid NZ COVID Pass." }); if (t.vc.credentialSubject) { if (!t.vc.credentialSubject.givenName) throw new Oe({ message: "Missing REQUIRED 'givenName' in credentialSubject property", link: "https://nzcp.covid19.health.nz/#publiccovidpass", section: "2.4.1.2.1", description: '"Given Name" missing from NZ COVID Pass.' }); if (!t.vc.credentialSubject.dob) throw new Oe({ message: "Missing REQUIRED 'dob' in credentialSubject property", link: "https://nzcp.covid19.health.nz/#publiccovidpass", section: "2.4.1.2.2", description: '"Date of Birth" missing from NZ COVID Pass.' }) } else throw new Oe({ message: "Verifiable Credential Credential Subject property MUST be present", link: "https://nzcp.covid19.health.nz/#verifiable-credential-claim-structure", section: "2.3.9", description: "The COVID Pass is malformed or has been modified." }); return { jti: t.jti, iss: t.iss, nbf: t.nbf, exp: t.exp, vc: t.vc } } function e6(t) { let e = t.get(4), r = t.get(1); return { kid: e ? e.toString() : void 0, alg: r === -7 ? "ES256" : void 0 } } var PS = "https://w3.org/ns/did/v1", CS = "did:web:nzcp.covid19.health.nz", OS = [{ id: "did:web:nzcp.covid19.health.nz#key-1", controller: "did:web:nzcp.covid19.health.nz", type: "JsonWebKey2020", publicKeyJwk: { kty: "EC", crv: "P-256", x: "zRR-XGsCp12Vvbgui4DD6O6cqmhfPuXMhi1OxPl8760", y: "Iv5SU6FuW-TRYh5_GOrJlcV_gpF_GpFQhCOD8LSk3T0" } }], DS = ["did:web:nzcp.covid19.health.nz#key-1"], t6 = { "@context": PS, id: CS, verificationMethod: OS, assertionMethod: DS }; var FS = "did:web:nzcp.identity.health.nz", US = ["https://w3.org/ns/did/v1", "https://w3id.org/security/suites/jws-2020/v1"], NS = [{ id: "did:web:nzcp.identity.health.nz#z12Kf7UQ", controller: "did:web:nzcp.identity.health.nz", type: "JsonWebKey2020", publicKeyJwk: { kty: "EC", crv: "P-256", x: "DQCKJusqMsT0u7CjpmhjVGkHln3A3fS-ayeH4Nu52tc", y: "lxgWzsLtVI8fqZmTPPo9nZ-kzGs7w7XO8-rUU68OxmI" } }], LS = ["did:web:nzcp.identity.health.nz#z12Kf7UQ"], r6 = { id: FS, "@context": US, verificationMethod: NS, assertionMethod: LS }; var Ec = { MOH_LIVE: r6, MOH_EXAMPLE: t6 }, Ac = { MOH_LIVE: "did:web:nzcp.identity.health.nz", MOH_EXAMPLE: "did:web:nzcp.covid19.health.nz" }; var i6 = (t, e) => { var f, h, c; let r = e && e.didDocument ? Array.isArray(e.didDocument) ? e.didDocument : [e.didDocument] : [Ec.MOH_LIVE], i = r.map(y => y.id), n = e && e.trustedIssuer ? Array.isArray(e.trustedIssuer) ? e.trustedIssuer : [e.trustedIssuer] : i; try { let y = a6(t), x = f6(y), M = s6(y), E = o6(M, n), A = (f = r.find(T => T.id === E)) != null ? f : null, B = h6(E, x, M, A, y); return { success: !0, violates: null, expires: new Date(B.exp * 1e3), validFrom: new Date(B.nbf * 1e3), credentialSubject: B.vc.credentialSubject, raw: B } } catch (y) { let x = y; if ("violates" in x) { let M = x, E = M.cwtClaims; return { success: !1, violates: M.violates, expires: (E == null ? void 0 : E.exp) ? new Date((E == null ? void 0 : E.exp) * 1e3) : null, validFrom: (E == null ? void 0 : E.nbf) ? new Date((E == null ? void 0 : E.nbf) * 1e3) : null, credentialSubject: (c = (h = E == null ? void 0 : E.vc) == null ? void 0 : h.credentialSubject) != null ? c : null, raw: E } } else return { success: !1, violates: { message: y.message, section: "unknown", link: "" }, expires: null, validFrom: null, credentialSubject: null, raw: null } } }, n6 = (t, e) => Vf(void 0, null, function* () { var i, n; let r = e && e.trustedIssuer ? Array.isArray(e.trustedIssuer) ? e.trustedIssuer : [e.trustedIssuer] : [Ac.MOH_LIVE]; try { let f = a6(t), h = f6(f), c = s6(f), y = o6(c, r), x = yield Wc.resolve(y); if (x.didResolutionMetadata.error) throw new Oe({ message: x.didResolutionMetadata.error, link: "https://nzcp.covid19.health.nz/#ref:DID-CORE", section: "DID-CORE.1", description: "Could not resolve trusted issuer." }); let M = h6(y, h, c, x.didDocument, f); return { success: !0, violates: null, expires: new Date(M.exp * 1e3), validFrom: new Date(M.nbf * 1e3), credentialSubject: M.vc.credentialSubject, raw: M } } catch (f) { let h = f; if ("violates" in h) { let c = h, y = c.cwtClaims; return { success: !1, violates: c.violates, expires: (y == null ? void 0 : y.exp) ? new Date((y == null ? void 0 : y.exp) * 1e3) : null, validFrom: (y == null ? void 0 : y.nbf) ? new Date((y == null ? void 0 : y.nbf) * 1e3) : null, credentialSubject: (n = (i = y == null ? void 0 : y.vc) == null ? void 0 : i.credentialSubject) != null ? n : null, raw: y } } else return { success: !1, violates: { message: f.message, section: "unknown", link: "" }, expires: null, validFrom: null, credentialSubject: null, raw: null } } }), a6 = t => { if (typeof t != "string") throw new Oe({ message: "The payload of the QR Code MUST be a string", section: "4.3", link: "https://nzcp.covid19.health.nz/#2d-barcode-encoding", description: "The COVID Pass is malformed or has been modified." }); let e = /(NZCP:\/)(\d+)\/([A-Za-z2-7=]+)/, r = t.match(e); if (!r) throw new Oe({ message: "The payload of the QR Code MUST be in the form `NZCP:/<version-identifier>/<base32-encoded-CWT>`", section: "4.4", link: "https://nzcp.covid19.health.nz/#2d-barcode-encoding", description: "The QR code is not a valid NZ COVID Pass." }); let [, i, n, f] = r; if (i !== "NZCP:/") throw new Oe({ message: "The payload of the QR Code MUST begin with the prefix of `NZCP:/`", section: "4.5", link: "https://nzcp.covid19.health.nz/#2d-barcode-encoding", description: "The QR code is not a valid NZ COVID Pass." }); if (n !== "1") throw new Oe({ message: "The version-identifier portion of the payload for the specification MUST be 1", section: "4.6", link: "https://nzcp.covid19.health.nz/#2d-barcode-encoding", description: "The QR code is not a valid NZ COVID Pass." }); let h; try { h = Dc.parse(Kc(f)) } catch (y) { throw new Oe({ message: "The payload of the QR Code MUST be base32 encoded", section: "4.7", link: "https://nzcp.covid19.health.nz/#2d-barcode-encoding", description: "The COVID Pass is malformed or has been modified." }) } return oh(h) }, f6 = t => { let e = oh(t.value[0]), r = e6(e); if (!r.kid) throw new Oe({ message: "`kid` header MUST be present in the protected header section of the `COSE_Sign1` structure", section: "2.2.1.1", link: "https://nzcp.covid19.health.nz/#cwt-headers", description: "The COVID Pass is malformed or has been modified." }); if (r.alg !== "ES256") throw new Oe({ message: "`alg` claim value MUST be present in the protected header section of the `COSE_Sign1` structure and MUST be set to the value corresponding to `ES256` algorithm registration", section: "2.2.2.2", link: "https://nzcp.covid19.health.nz/#cwt-headers", description: "The COVID Pass is malformed or has been modified." }); return r }, s6 = t => { let e = oh(t.value[2]); return Jm(e) }, o6 = (t, e) => { let r = t.iss; if (!r) throw new Oe({ message: "Issuer claim MUST be present", section: "2.1.0.2.1", link: "https://nzcp.covid19.health.nz/#cwt-claims", description: "The COVID Pass is malformed or has been modified." }); if (!e.includes(r)) throw new Oe({ message: "`iss` value reported in the pass does not match one listed in the trusted issuers", link: "https://nzcp.covid19.health.nz/#trusted-issuers", section: "6.3", description: "The COVID Pass was not issued by a trusted issuer." }); return r }, h6 = (t, e, r, i, n) => { let f = `${t}#${e.kid}`; if (!(i == null ? void 0 : i.assertionMethod)) throw new Oe({ message: "The public key referenced by the decoded CWT MUST be listed/authorized under the assertionMethod verification relationship in the resolved DID document.", link: "https://nzcp.covid19.health.nz/#did-document", section: "5.1.1", description: "The COVID Pass is malformed or has been modified." }); let h = i.assertionMethod; if (typeof h == "string" && (h = [h]), !h.includes(f)) throw new Oe({ message: "The public key referenced by the decoded CWT MUST be listed/authorized under the assertionMethod verification relationship in the resolved DID document.", link: "https://nzcp.covid19.health.nz/#did-document", section: "5.1.1", description: "The COVID Pass is malformed or has been modified." }); if (!i.verificationMethod) throw new Oe({ message: "No matching verificationMethod method for the assertionMethod", link: "https://nzcp.covid19.health.nz/#ref:DID-CORE", section: "DID-CORE.2", description: "The COVID Pass is malformed or has been modified." }); let c = i.verificationMethod.find(M => M.id === f); if (!c) throw new Oe({ message: "No matching verificationMethod for the assertionMethod", link: "https://nzcp.covid19.health.nz/#ref:DID-CORE", section: "DID-CORE.2", description: "The COVID Pass is malformed or has been modified." }); let y = c == null ? void 0 : c.publicKeyJwk; if (!y || !(y == null ? void 0 : y.x) || !(y == null ? void 0 : y.y)) throw new Oe({ message: "The public key referenced by the decoded CWT MUST be a valid P-256 public key", link: "https://nzcp.covid19.health.nz/#did-document", section: "5.1.2", description: "The COVID Pass is malformed or has been modified." }); if ((c == null ? void 0 : c.type) !== "JsonWebKey2020") throw new Oe({ message: "The expression of the public key referenced by the decoded CWT MUST be in the form of a JWK as per [RFC7517].", link: "https://nzcp.covid19.health.nz/#did-document", section: "5.1.3", description: "The COVID Pass is malformed or has been modified." }); if (y.crv !== "P-256" || y.kty !== "EC") throw new Oe({ message: "This public key JWK expression MUST set a crv property which has a value of P-256. Additionally, the JWK MUST have a kty property set to EC.", link: "https://nzcp.covid19.health.nz/#did-document", section: "5.1.5", description: "The COVID Pass is malformed or has been modified." }); if (!Ym(n, y)) throw new Oe({ message: "Retrieved public key does not validate `COSE_Sign1` structure", link: "https://nzcp.covid19.health.nz/#cryptographic-digital-signature-algorithm-selection", section: "3", description: "The COVID Pass is malformed or has been modified." }); try { return Qm(r) } catch (M) { throw "violates" in M ? new Oe(M.violates, r) : M } };
        /*!
         * The buffer module from node.js, for the browser.
         *
         * @author   Feross Aboukhadijeh <https://feross.org>
         * @license  MIT
         */
        /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
        /*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
        /**
         * [js-sha256]{@link https://github.com/emn178/js-sha256}
         *
         * @version 0.9.0
         * @author Chen, Yi-Cyuan [emn178@gmail.com]
         * @copyright Chen, Yi-Cyuan 2014-2017
         * @license MIT
         */


      }).call(this)
    }).call(this, require('_process'), require("buffer").Buffer)
  }, { "_process": 4, "buffer": 2 }]
}, {}, [5]);
